module powerbi.visuals {
        export interface MyViewModel {};

        //Please note that class name has to be in PascalCase!
        export class Lift implements IVisual {
            /**
             * Informs the System what it can do
             * Fields, Formatting options, data reduction & QnA hints
             */
            public static capabilities: VisualCapabilities = {
                dataRoles: [{
                    name: 'Values',
                    kind: VisualDataRoleKind.GroupingOrMeasure,
                    displayName: 'Values'
                },{
                    name: 'XAxis',
                    kind: VisualDataRoleKind.GroupingOrMeasure,
                    displayName: 'X Axis'
                }],
                objects: {
                    Legend: {
                        displayName: 'Legends',
                        properties: {
                            enableLegend: {
                                displayName: 'Enable',
                                description: 'Option to enable legends',
                                type: {
                                    bool: true
                                }
                            },
                            enableLegendClick: {
                                displayName: 'Enable Click',
                                description: 'Option to enable click on legends',
                                type: {
                                    bool: true
                                }
                            }
                        }
                    },                    
                    Line: {
                        displayName: 'Line Configurations',
                        properties: {
                            enableStepLine: {
                                displayName: 'Step Line',
                                description: 'Option to enable step line',
                                type: {
                                    bool: true
                                }
                            },
                            enableMarker: {
                                displayName: 'Marker',
                                description: 'Option to enable marker',
                                type: {
                                    bool: true
                                }
                            },
                            markerWidth: {
                                displayName: 'Marker Width',
                                description: 'Option to set marker width',
                                type: {
                                    numeric: true
                                }
                            },
                            lineWidth: {
                                displayName: 'Line Width',
                                description: 'Option to set line width',
                                type: {
                                    numeric: true
                                }
                            }
                        }
                    },
                    Lift: {
                        displayName: 'Lift Configurations',
                        properties: {
                            dragLineColor: {
                                displayName: 'Drag Line Color',
                                description: 'Option to set drag line color',
                                type: {
                                    fill: { solid: { color: true } }
                                }
                            },
                            dragLineWidth: {
                                displayName: 'Drag Line Width',
                                description: 'Option to set drag line width',
                                type: {
                                    numeric: true
                                }
                            },
                            strokeColor: {
                                displayName: 'Stroke Color',
                                description: 'Option to set stroke color',
                                type: {
                                    fill: { solid: { color: true } }
                                }
                            },
                            strokeWidth: {
                                displayName: 'Stroke Width',
                                description: 'Option to set stroke width',
                                type: {
                                    numeric: true
                                }
                            }
                        }
                    },
                    XAxis: {
                        displayName: 'X Axis',
                        properties: {
                            xAxisEnableLabels: {
                                displayName: 'Enable Labels',
                                description: 'Option to enable labels',
                                type: {
                                    bool: true
                                }
                            },
                            xAXisFontSize: {
                                displayName: 'Font Size',
                                description: 'Option to set font size of title',
                                type: {
                                    formatting: { fontSize: true }
                                }
                            },
                            xAxisGridLineColor: {
                                displayName: 'Grid Line Color',
                                description: 'Option to set grid line color',
                                type: {
                                    fill: { solid: { color: true } }
                                }
                            },
                            xAxisGridLineWidth: {
                                displayName: 'Grid Line Width',
                                description: 'Option to set grid line width',
                                type: {
                                    numeric: true
                                }
                            }
                        }
                    },
                    YAxis: {
                        displayName: 'Y Axis',
                        properties: {
                            yAxisEnableLabels: {
                                displayName: 'Enable Labels',
                                description: 'Option to enable labels',
                                type: {
                                    bool: true
                                }
                            },
                            yAXisFontSize: {
                                displayName: 'Font Size',
                                description: 'Option to set font size of title',
                                type: {
                                    formatting: { fontSize: true }
                                }
                            },
                            yAxisGridLineColor: {
                                displayName: 'Grid Line Color',
                                description: 'Option to set grid line color',
                                type: {
                                    fill: { solid: { color: true } }
                                }
                            },
                            yAxisGridLineWidth: {
                                displayName: 'Grid Line Width',
                                description: 'Option to set grid line width',
                                type: {
                                    numeric: true
                                }
                            }
                        }
                    }
                },
                dataViewMappings: [{
                    conditions: [
                        { "XAxis": { "max": 1 } },
                        { "Values": {}}
                    ],
                    table: {
                        rows: {
				            by: 'Values',
                            select: [{for: { in: 'Values' }},{for: { in: 'XAxis' }}],
                            dataReductionAlgorithm: { window: { count: 30000000 } }
                        },
                        rowCount: {
                            preferred: {
                                min: 1
                            }
                        }
                    }
                }],
                sorting: {
                    custom: {},
                },
                suppressDefaultTitle: true,
                supportsSelection: false,
                disableVisualDetails: true,
            };


            private element: JQuery;
            private viewport: IViewport;
            private root: D3.Selection;
            private style: IVisualStyle;
            private colors: IDataColorPalette;
            private hostService: IVisualHostServices;
            public dataView: DataView;
            // Convert a DataView into a view model
            public static converter(dataView: DataView): MyViewModel {
                return {};
            }

            /* One time setup*/
            public init(options: VisualInitOptions): void {
                this.root = d3.select(options.element.get(0));

                this.style = options.style;
                this.viewport = _.clone(options.viewport);
                this.hostService = options.host;
                this.colors = this.style.colorPalette.dataColors;

                this.element = options.element;

                d3.select(options.element.get(0))
                    .append('div')
                    .classed('DataDiv', true)
                    .attr("id", "chartLiftDiv");
                d3.select(options.element.get(0))
                    .append('div')
                    .classed('errorMessage', true)
                    .text("No data available")
                    .style({
                        'display': 'none',
                        'text-align': 'center',
                        'top': this.viewport.height / 2 + 'px',
                        'position': 'relative',
                        'width': '100%'
                    });
            }

            /* Called for data, size, formatting changes*/
            public update(options: VisualUpdateOptions) {
                var dataViews = options.dataViews;
                if (!dataViews || 0 === dataViews.length || !dataViews[0].table) {
                    this.root.select('.errorMessage').style({
                        'display': 'block',
                        'top': this.viewport.height / 2 + 'px'
                    });
                    return;
                }
                this.dataView = dataViews[0];
                this.root.select('.errorMessage').style({
                    'display': 'none',
                    'top': this.viewport.height / 2 + 'px'
                });
                var config = {
                    "chart": {
                        "renderTo": "chartLiftDiv",
                        "type": "lift",
                        "isResponsive": false,
                        "margin": [
                            20,
                            10,
                            10,
                            10
                        ],
                        "style": {
                            "width": "100%",
                            "height": Math.max(document.documentElement.clientHeight, window.innerHeight || 0) + "px",
                            "border": "0px solid silver"
                        }
                    },
                    "title": {
                        "align": "center",
                        "text": "0",
                        "x": 0,
                        "y": 0,
                        "floating": false,
                        "style": {
                            "fill": "#000000",
                            "fontSize": "0px",
                            "fontFamily": "Segoe UI",
                            "textAnchor": "middle"
                        }
                    },
                    "plotOptions": {
                        "line": {
                            "stepLine": this.getBoolFieldValue(this.dataView, 'Line', 'enableStepLine'),//false,
                            "marker": {
                                "enabled": this.getBoolFieldValue(this.dataView, 'Line', 'enableMarker'),//false,
                                "fillColor": "",
                                "lineWidth": 1,
                                "lineColor": "",
                                "width": this.getNumericFieldValue(this.dataView, 'Line', 'markerWidth')//4
                            },
                            "color": [
                                "#2980b9",
                                "#27ae60",
                                "#CC0000",
                                "#75962A",
                                "#4572a7",
                                "#aa4643",
                                "#89a54e",
                                "#80699b",
                                "#3d96ae",
                                "#db843d",
                                "#0066CC"
                            ],
                            "lineWidth": this.getNumericFieldValue(this.dataView, 'Line', 'lineWidth'),//4,
                            "lineDashStyle": ""
                        },
                        "lift": {
                            "dragAreaFill": "",
                            "dragAreaOpacity": 0.3,
                            "dragLineStyle": "5,5",
                            "dragLineWidth": this.getNumericFieldValue(this.dataView, 'Lift', 'dragLineWidth'),//5,
                            "dragLineColor": this.getColorFieldValue(this.dataView, 'Lift', 'dragLineColor'),//"black",
                            "dragWindowFill": "transparent",
                            "dragWindowBorderStyle": "",
                            "dragWindowOpacity": 0,
                            "dragCircleFill": "#505151",
                            "intersectionMarker": {
                                "radius": 20,
                                "strokeColor": this.getColorFieldValue(this.dataView, 'Lift', 'strokeColor'),//"white",
                                "strokeWidth": this.getNumericFieldValue(this.dataView, 'Lift', 'strokeWidth'),
                                "fontStyle": {
                                    "fill": "#ffffff",
                                    "fontSize": "11px",
                                    "fontFamily": "Segoe UI",
                                    "fontWeight": "bold"
                                },
                                "dx": 0,
                                "dy": 2
                            }
                        }
                    },
                    "legend": {
                        "enabled": this.getBoolFieldValue(this.dataView, 'Legend', 'enableLegend'),
                        "enableClick": this.getBoolFieldValue(this.dataView, 'Legend', 'enableLegendClick'),
                        "align": "center",
                        "verticalAlign": "bottom",
                        "verticalAlignLegend": false,
                        "layout": "horizontal",
                        "floating": false,
                        "borderStyle": "",
                        "borderWidth": 1,
                        "borderRadius": 2,
                        "symbolWidth": 10,
                        "symbolPadding": 3,
                        "individualDistance": 10,
                        "lineHeight": 5,
                        "style": {
                            "fill": "#444444",
                            "fontSize": "12px",
                            "fontFamily": "Segoe UI"
                        },
                        "enableTextClipping": false,
                        "clipTextFrom": "left",
                        "clippedTextLength": 10
                    },
                    "xAxis": {
                        "title": {
                            "align": "center",
                            "text": "",
                            "style": {
                                "fill": "#2A8AAD",
                                "fontSize": "0px",
                                "fontFamily": "Segoe UI",
                                "textAnchor": "middle"
                            },
                            "x": 0,
                            "y": -5
                        },
                        "labels": {
                            "enabled": this.getBoolFieldValue(this.dataView, 'XAxis', 'xAxisEnableLabels'),//true,
                            "align": "center",
                            "series": [],
                            "formatter": null,
                            "staggerLines": false,
                            "rotation": 0,
                            "style": {
                                "fill": "black",
                                "fontSize": this.getFontFieldValue(this.dataView, 'XAxis', 'xAXisFontSize') + "px",
                                "fontFamily": "Segoe UI"
                            },
                            "x": 0,
                            "y": 5
                        },
                        "numberOfGridLines": 8,
                        "gridLineWidth": this.getNumericFieldValue(this.dataView, 'XAxis', 'xAxisGridLineWidth'),//4,
                        "gridLineColor": this.getColorFieldValue(this.dataView, 'XAxis', 'xAxisGridLineColor'),//"silver",
                        "gridLineDashStyle": "solid",
                        "lineColor": "silver",
                        "lineWidth": 0,
                        "tickWidth": 0,
                        "tickHeight": 0,
                        "tickColor": "silver",
                        "tickPosition": "outside",
                        "labelSpacing": 5,
                        "shiftStartBy": 0,
                        "skipInterval": 0,
                        "alternateGridColor": "",
                        "usageWidth": 100
                    },
                    "yAxis": {
                        "title": {
                            "align": "center",
                            "text": "",
                            "style": {
                                "fill": "#2A8AAD",
                                "fontSize": "0px",
                                "fontFamily": "Segoe UI",
                                "textAnchor": "middle"
                            },
                            "x": -20,
                            "y": 0
                        },
                        "labels": {
                            "enabled": this.getBoolFieldValue(this.dataView, 'YAxis', 'yAxisEnableLabels'),//true,
                            "align": "right",
                            "series": [],
                            "staggerLines": false,
                            "rotation": 0,
                            "style": {
                                "fill": "black",
                                "fontSize": this.getFontFieldValue(this.dataView, 'YAxis', 'yAXisFontSize') + "px",
                                "fontFamily": "Segoe UI"
                            },
                            "x": -5,
                            "y": 0
                        },
                        "numberOfGridLines": 4,
                        "gridLineWidth": this.getNumericFieldValue(this.dataView, 'YAxis', 'yAxisGridLineWidth'),//0,
                        "gridLineColor": this.getColorFieldValue(this.dataView, 'YAxis', 'yAxisGridLineColor'),//"silver",
                        "gridLineDashStyle": "shortdash",
                        "lineWidth": 0,
                        "lineColor": "silver",
                        "tickWidth": 0,
                        "tickHeight": 0,
                        "tickPosition": "onaxis",
                        "tickColor": "silver",
                        "labelSpacing": 5,
                        "shiftStartBy": 0,
                        "skipInterval": 0,
                        "alternateGridColor": ""
                    },
                    "tooltip": {
                        "enabled": true,
                        "customTooltip": null,
                        "style": {
                            "padding": "2px 5px",
                            "border": "2px solid silver",
                            "backgroundColor": "#fff",
                            "color": "#444",
                            "font": "14px \"Segoe UI\""
                        }
                    },
                    "animation": {
                        "enabled": false,
                        "type": 1
                    },
                    "series": []
                };

                var roles = {
                     "Values": [],
                     "XAxis": []
                 }
                var obj, data =[],jCount, iCount, keys;
                for(iCount = 0;iCount<this.dataView.metadata.columns.length;iCount++){
                    keys = Object.keys(this.dataView.metadata.columns[iCount].roles);
                    for(jCount=0;jCount<keys.length;jCount++){
                        if ('XAxis' === keys[jCount] || typeof (this.dataView.table.rows[0][iCount]) === 'number') {
                            roles[keys[jCount]].push(iCount);
                        }
                    }
                }
                if(0 === roles.XAxis.length){
                    document.getElementById('chartLiftDiv').innerHTML = "";
                    return;
                }
                 var obj, data = [],
                     sectionHeader;
                 if (0 != this.dataView.table.columns.length) {
                     sectionHeader = this.dataView.table.columns[roles.XAxis[0]].displayName;
                 }
     
                 for (iCount = 0; iCount < roles.Values.length; iCount++) {
                     if(typeof(this.dataView.table.rows[0][roles.Values[iCount]]) === 'number'){
                         obj = {
                             name: this.dataView.table.columns[roles.Values[iCount]].displayName,
                             data: []
                         };
                         data.push(obj);
                     }
                 }
                config.xAxis.labels.series = [];
                for (jCount = 0; jCount < this.dataView.table.rows.length; jCount++) {
                    config.xAxis.labels.series.push(this.dataView.table.rows[jCount][roles.XAxis[0]]);
                    for (iCount = 0; iCount < roles.Values.length; iCount++) {
                        data[iCount].data.push(this.dataView.table.rows[jCount][roles.Values[iCount]]);
                    }
                }
                config.series = data;
                document.getElementById('chartLiftDiv').innerHTML = "";
                MAQ.charts(config);
            }

            /*About to remove your visual, do clean up here */
            public destroy() {}

            public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstanceEnumeration {
                var enumeration = new ObjectEnumerationBuilder();

                switch (options.objectName) {
                    case 'Legend':
                        enumeration.pushInstance({
                            objectName: options.objectName,
                            displayName: 'Legend',
                            selector: null,
                            properties: {
                                enableLegend: this.getBoolFieldValue(this.dataView, 'Legend', 'enableLegend'),
                                enableLegendClick: this.getBoolFieldValue(this.dataView, 'Legend', 'enableLegendClick')
                            }
                        });
                        break;
                    case 'Line':
                        enumeration.pushInstance({
                            objectName: options.objectName,
                            displayName: 'Line',
                            selector: null,
                            properties: {
                                enableStepLine: this.getBoolFieldValue(this.dataView, 'Line', 'enableStepLine'),
                                enableMarker: this.getBoolFieldValue(this.dataView, 'Line', 'enableMarker'),
                                markerWidth: this.getNumericFieldValue(this.dataView, 'Line', 'markerWidth'),
                                lineWidth: this.getNumericFieldValue(this.dataView, 'Line', 'lineWidth')
                            }
                        });
                        break;
                    case 'Lift':
                        enumeration.pushInstance({
                            objectName: options.objectName,
                            displayName: 'Lift',
                            selector: null,
                            properties: {
                                dragLineColor: this.getColorFieldValue(this.dataView, 'Lift', 'dragLineColor'),
                                dragLineWidth: this.getNumericFieldValue(this.dataView, 'Lift', 'dragLineWidth'),
                                strokeColor: this.getColorFieldValue(this.dataView, 'Lift', 'strokeColor'),
                                strokeWidth: this.getNumericFieldValue(this.dataView, 'Lift', 'strokeWidth')
                            }
                        });
                        break;
                    case 'XAxis':
                        enumeration.pushInstance({
                            objectName: options.objectName,
                            displayName: 'X Axis',
                            selector: null,
                            properties: {
                                xAxisEnableLabels: this.getBoolFieldValue(this.dataView, 'XAxis', 'xAxisEnableLabels'),
                                xAXisFontSize: this.getFontFieldValue(this.dataView, 'XAxis', 'xAXisFontSize'),
                                xAxisGridLineColor: this.getColorFieldValue(this.dataView, 'XAxis', 'xAxisGridLineColor'),
                                xAxisGridLineWidth: this.getNumericFieldValue(this.dataView, 'XAxis', 'xAxisGridLineWidth')
                            }
                        });
                        break;
                    case 'YAxis':
                        enumeration.pushInstance({
                            objectName: options.objectName,
                            displayName: 'Y Axis',
                            selector: null,
                            properties: {
                                yAxisEnableLabels: this.getBoolFieldValue(this.dataView, 'YAxis', 'yAxisEnableLabels'),
                                yAXisFontSize: this.getFontFieldValue(this.dataView, 'YAxis', 'yAXisFontSize'),
                                yAxisGridLineColor: this.getColorFieldValue(this.dataView, 'YAxis', 'yAxisGridLineColor'),
                                yAxisGridLineWidth: this.getNumericFieldValue(this.dataView, 'YAxis', 'yAxisGridLineWidth')
                            }
                        });
                        break;
                }
                return enumeration.complete();
            }

            private getBoolFieldValue(dataView: DataView, area, property) {
                if (dataView.metadata.objects && dataView.metadata.objects.hasOwnProperty(area)) {
                    if (dataView.metadata.objects[area].hasOwnProperty(property)) {
                        return dataView.metadata.objects[area][property];
                    }
                }
                return false;
            }
            private getNumericFieldValue(dataView: DataView, area, property) {
                if (dataView.metadata.objects && dataView.metadata.objects.hasOwnProperty(area)) {
                    if (dataView.metadata.objects[area].hasOwnProperty(property)) {
                        return dataView.metadata.objects[area][property];
                    }
                }
                return 1;
            }
            private getFontFieldValue(dataView: DataView, area, property) {
                if (dataView.metadata.objects && dataView.metadata.objects.hasOwnProperty(area)) {
                    if (dataView.metadata.objects[area].hasOwnProperty(property)) {
                        return dataView.metadata.objects[area][property];
                    }
                }
                return 11;
            }
            private getColorFieldValue(dataView: DataView, area, property) {
                if (dataView.metadata.objects && dataView.metadata.objects.hasOwnProperty(area)) {
                    if (dataView.metadata.objects[area].hasOwnProperty(property)) {
                        return dataView.metadata.objects[area][property]['solid'].color;
                    }
                }
                return '#000';
            }
        }
    }
    /*jslint white: true, devel:true, browser: true, this:true, for:true, single:true, multivar:true */
    /*global MAQ, window,oDimensionTotalTitle,oGrpELESum,oData*/
    /*Create the MAQ Object*/
var MAQ = {};

function resetTimeline(chartConfigOptions) {
    'use strict';
    var oNavigatorWindow = document.getElementById('MAQCharts-NavWindow-' + chartConfigOptions.chart.renderTo);
    createRangeSlider(chartConfigOptions, chartConfigOptions.timeline.originalSeries, 'MAQCharts-TimeLineDrill-' + chartConfigOptions.chart.renderTo, 'year');
    expandFullNavigator(chartConfigOptions);
    chartConfigOptions.timeline.rangeStart = 0;
    chartConfigOptions.timeline.rangeEnd = chartConfigOptions.timeline.originalSeries.length - 1;
    var fNavigatorShiftRatio = chartConfigOptions.timeline.originalSeries.length / chartConfigOptions.fNavigatorWidth;
    MAQ.updateTimeLineDisplayArea(chartConfigOptions, fNavigatorShiftRatio * oNavigatorWindow.x.baseVal.value, fNavigatorShiftRatio * (oNavigatorWindow.x.baseVal.value + oNavigatorWindow.width.baseVal.value));
}

function restoreOriginalValues(chartConfigOptions) {
    'use strict';
    if (chartConfigOptions.chart.enableTimeline) {
        chartConfigOptions.timeline.series = chartConfigOptions.timeline.originalSeries;
        chartConfigOptions.svgELE = chartConfigOptions.originalSVGELE;
        chartConfigOptions.availHeight = chartConfigOptions.availHeightAfterTitledrawn * (1 - chartConfigOptions.timeline.heightRatio) - chartConfigOptions.timeline.timelinePadding;
    }
    chartConfigOptions.availWidth = chartConfigOptions.width;
    chartConfigOptions.availX = 0;
    chartConfigOptions.availY = chartConfigOptions.availYAfterTitleDrawn;
}

function clone(obj) {
    'use strict';
    // Handle the 3 simple types, and null or undefined
    if (null === obj || 'object' !== typeof obj) {
        return obj;
    }
    var copy, len, iCounter = 0,
        attr;
    // Handle Date
    if (obj instanceof Date) {
        copy = new Date();
        copy.setTime(obj.getTime());
        return copy;
    }
    // Handle Array
    if (obj instanceof Array) {
        copy = [];
        len = obj.length;
        for (iCounter = 0; iCounter < len; iCounter += 1) {
            copy[iCounter] = clone(obj[iCounter]);
        }
        return copy;
    }
    // Handle Object
    if (obj instanceof Object) {
        copy = {};
        Object.keys(obj).forEach(function(attr) {
            copy[attr] = clone(obj[attr]);
        });
        return copy;
    }
    throw new Error('Unable to copy obj! Its type isn\'t supported.');
}
/*
 * MAQ.utils: MAQ chart utility functions
 */
if (undefined === MAQ.utils) {
    MAQ.utils = {};
}
MAQ.utils.clone = clone;
MAQ.utils.isNumber = function(fNumber) {
    'use strict';
    return !isNaN(parseFloat(fNumber)) && isFinite(fNumber);
};
MAQ.utils.getTextDim = function(sText, oStyle, chartConfigOptions) {
    'use strict';
    var oAttr = {
            x: 10,
            y: 10,
            text: sText,
            style: oStyle
        },
        oText = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttr),
        oDim;
    chartConfigOptions.svgELE.appendChild(oText);
    oDim = MAQ.getObjectDimension(oText);
    chartConfigOptions.svgELE.removeChild(oText);
    return oDim;
};
MAQ.utils.getMultiLineSVGText = function(sSvgNS, oChartRoot, sText, oTextAttr, maxChars, iData) {
    'use strict';
    var sTextItem,
        iDy = 0,
        iLineSpacing = 0,
        sTextKey,
        oTextGrp = MAQ.createSVGElement(sSvgNS, 'g', {}),
        iMaxWidth = 0,
        iSignX = 1,
        iSignY = -1,
        iOffsetX = 0,
        iTotalHeight = 0,
        iDeltaX = 15,
        //**Convert Text into multiline array**//
        sTexts = [],
        iLastIndex = 0,
        iTextLen = sText.length,
        sTempText,
        i;
    while (true) {
        if (sText.length <= maxChars) {
            sTexts.push(sText + ' : ' + (iData || ''));
            break;
        }
        sTempText = sText.substr(iLastIndex, maxChars);
        i = Math.max(sTempText.lastIndexOf(','), sTempText.lastIndexOf(' '), sTempText.lastIndexOf('.'), sTempText.lastIndexOf(';'));
        if (i <= 0) {
            i = maxChars;
        }
        sTexts.push(sText.substr(iLastIndex, i + 1));
        iLastIndex += i + 1;
        if (iLastIndex >= iTextLen) {
            sTexts[sTexts.length - 1] = sTexts[sTexts.length - 1] + ' : ' + (iData || '');
            break;
        }
    }
    //**Create the multiline text SVG**//
    Object.keys(sTexts).forEach(function(sTextKey) {
        sTextItem = MAQ.utils.getTextDim(sTexts[sTextKey], oTextAttr.style || {}, {
            svgNS: sSvgNS,
            svgELE: oChartRoot
        });
        iDy = sTextItem.height + iLineSpacing;
        iMaxWidth = Math.max(iMaxWidth, sTextItem.width);
        oTextAttr.text = sTexts[sTextKey];
        oTextAttr.y += iDy;
        iTotalHeight += iDy;
        oTextGrp.appendChild(MAQ.createSVGElement(sSvgNS, 'text', oTextAttr));
    });
    if (-iDeltaX < oTextAttr.x && oTextAttr.x < iDeltaX) {
        iSignX = -0.5;
        iSignY = 0;
    } else if (oTextAttr.x < -iDeltaX) {
        iSignX = -1;
        iOffsetX = -6;
    } else {
        iSignX = 0;
        iOffsetX = 6;
    }
    MAQ.addAttr(oTextGrp, 'transform', 'matrix(1 0 0 1 ' + (iSignX * iMaxWidth + iOffsetX) + ' ' + iSignY * iTotalHeight / 2 + ')');
    return oTextGrp;
};
MAQ.utils.isSafe = function(literalToCheck) {
    'use strict';
    if (!literalToCheck) {
        return false;
    }
    return true;
};
/*
   pivotArray: Performs a matrix transpose style tranformation
   @param {arr} 2D array to be pivoted
   */
MAQ.utils.pivotArray = function(arr) {
    'use strict';
    //return if the passed array is not 2D
    if (!('[object Array]' === Object.prototype.toString.call(arr) && '[object Array]' === Object.prototype.toString.call(arr[0]))) {
        console.log('Passed argument is not a 2D array');
        return;
    }
    var pivotArr = [],
        iRows = arr.length,
        iCols = arr[0].length,
        iCount,
        jCount;
    for (iCount = 0; iCount < iCols; iCount += 1) {
        pivotArr[iCount] = [];
        for (jCount = 0; jCount < iRows; jCount += 1) {
            pivotArr[iCount].push(arr[jCount][iCount]);
        }
    }
    return pivotArr;
};
/*
   toLinear: Converts a 2D array into 1D array
   @param {arr} 2D array to be convert
   */
MAQ.utils.toLinear = function(arr) {
    'use strict';
    //return if the passed array is not 2D
    if (!('[object Array]' === Object.prototype.toString.call(arr) && '[object Array]' === Object.prototype.toString.call(arr[0]))) {
        console.log('Passed argument is not a 2D array');
        return;
    }
    var linearArr = [],
        iCount;
    for (iCount = 0; iCount < arr.length; iCount += 1) {
        linearArr = linearArr.concat(arr[iCount]);
    }
    return linearArr;
};
MAQ.utils.formatters = {
    trimText: function(sInput) {
        'use strict';
        if (sInput.length >= 13) {
            sInput = sInput.substring(0, 9) + '...';
        }
        return sInput;
    },
    /*
      insertCommas: Formats the number in comma separator format ($ x,xxx,xxx.xx)
      @param {sInput} number to be formatted
      @param {iDecimalPlace} number to decimal values to be shown
      */
    insertCommas: function(sInput, iDecimalPlaces) {
        'use strict';
        if (0 === parseFloat(sInput)) {
            return '0';
        }
        if (!sInput || isNaN(sInput)) {
            return 'N/A';
        }
        // Check for validity of decimal places parameter
        if (!iDecimalPlaces || isNaN(iDecimalPlaces)) {
            iDecimalPlaces = 0; // Default value is 0
        }
        var fTempValue = parseFloat(sInput),
            sTempValue = fTempValue.toString(),
            aDigits,
            rPattern,
            sIntegerDigits,
            sFractionDigits,
            decimalLength;
        if (-1 !== sTempValue.indexOf('.')) {
            decimalLength = sTempValue.substring(sTempValue.indexOf('.') + 1).length;
            if (iDecimalPlaces < decimalLength) {
                sTempValue = fTempValue.toFixed(iDecimalPlaces).toString();
            }
        }
        aDigits = sTempValue.split('.');
        sIntegerDigits = aDigits[0];
        sFractionDigits = aDigits.length > 1 ? '.' + aDigits[1] : '';
        sIntegerDigits = sIntegerDigits.toString();
        rPattern = /(\d+)(\d{3})/;
        while (rPattern.test(sIntegerDigits)) {
            sIntegerDigits = sIntegerDigits.replace(rPattern, '$1' + ',' + '$2');
        }
        return sIntegerDigits + sFractionDigits;
    },
    addPercent: function(sInput, iDecimalPlaces) {
        'use strict';
        if (0 === parseFloat(sInput)) {
            return '0%';
        }
        if (!sInput || isNaN(parseFloat(sInput))) {
            return 'N/A';
        }
        if ((!iDecimalPlaces || isNaN(iDecimalPlaces)) && iDecimalPlaces !== 0) {
            iDecimalPlaces = 1; // Default value is 1
        }
        return MAQ.utils.formatters.insertCommas(sInput, iDecimalPlaces) + '%';
    },
    /*
      scaleFormatter: Formats the number in K, M, B form (x.xxM)
      @param {sInput} number to be formatted
      @param {iDecimalPlace} number to decimal values to be shown
      */
    scaleFormatter: function(sInput, iDecimalPlaces) {
        'use strict';
        //TODO: Add trillion data formatter also
        if (0 === parseFloat(sInput)) {
            return '0';
        }
        if (!sInput || isNaN(sInput)) {
            return 'N/A';
        }
        var fTempValue = parseFloat(sInput),
            sTempValue,
            aDigits,
            iTempValue,
            rPattern,
            sCurrency,
            sIntegerDigits,
            sFractionDigits,
            decimalLength;
        if (fTempValue < 0) {
            sInput = -1 * fTempValue;
        } else {
            sInput = fTempValue;
        }
        // Check for validity of decimal places parameter
        if (!iDecimalPlaces || isNaN(iDecimalPlaces)) {
            iDecimalPlaces = 0; // Default value is 0
        }
        sTempValue = sInput.toString();
        if (-1 !== sTempValue.indexOf('.')) {
            decimalLength = sTempValue.substring(sTempValue.indexOf('.') + 1).length;
            if (iDecimalPlaces < decimalLength) {
                sTempValue = sInput.toFixed(iDecimalPlaces).toString();
            }
        }
        aDigits = sTempValue.split('.');
        sIntegerDigits = aDigits[0];
        sFractionDigits = aDigits.length > 1 ? '.' + aDigits[1] : '';
        // Converting thousand to M
        iTempValue = parseInt(sIntegerDigits, 10);
        sCurrency = '';
        if (iTempValue >= 1000000000) {
            sIntegerDigits = iTempValue / 1000000000;
            sCurrency = 'B';
            sFractionDigits = '';
            sIntegerDigits = sIntegerDigits.toFixed(iDecimalPlaces).toString();
        } else if (iTempValue < 1000000000 && iTempValue >= 1000000) {
            sIntegerDigits = iTempValue / 1000000;
            sCurrency = 'M';
            sFractionDigits = '';
            sIntegerDigits = sIntegerDigits.toFixed(iDecimalPlaces).toString();
        } else if (iTempValue < 1000000 && iTempValue >= 1000) {
            sIntegerDigits = iTempValue / 1000;
            sCurrency = 'K';
            sFractionDigits = '';
            sIntegerDigits = sIntegerDigits.toFixed(iDecimalPlaces).toString();
        }
        rPattern = /(\d+)(\d{3})/;
        while (rPattern.test(sIntegerDigits)) {
            sIntegerDigits = sIntegerDigits.replace(rPattern, '$1' + ',' + '$2');
        }
        return (fTempValue < 0 ? '-' : '') + sIntegerDigits + sFractionDigits + sCurrency;
    },
    revenueFormatter: function(sInput, iDecimalPlaces) {
        'use strict';
        if (0 === parseFloat(sInput)) {
            return '$0';
        }
        if (!sInput || isNaN(sInput)) {
            return 'N/A';
        }
        // Check for validity of decimal places parameter
        if (!iDecimalPlaces || isNaN(iDecimalPlaces)) {
            if (iDecimalPlaces !== 0) {
                iDecimalPlaces = 2; // Default value is 0
            }
        }
        var sTempValue = MAQ.utils.formatters.scaleFormatter(sInput, iDecimalPlaces);
        return parseFloat(sTempValue) < 0 ? '-$' + sTempValue.substr(1) : '$' + sTempValue;
    }
};
/*
 * MAQ.styles: MAQ charts style Object
 */
MAQ.styles = {
    //id of the dynamic style sheet
    styleSheetName: 'MAQCharts-Style-Sheet',
    //reference to the MAQcharts style tag
    styleTag: null,
    //track of whether style tag was created or not
    isInitialized: false,
    rules: [],
    /*
     * initStyles: adds the MAQcharts style tag to the document head and sets isInitialized to true
     */
    initStyles: function() {
        'use strict';
        if (this.isInitialized) {
            return this.styleTag;
        }
        //get ref to document head
        var head = document.head || document.getElementsByTagName('head')[0],
            //create the style tag
            style = document.createElement('style');
        //set style type and id
        style.type = 'text/css';
        style.id = this.styleSheetName;
        //append style to head
        head.appendChild(style);
        this.styleTag = style;
        this.isInitialized = true;
        return this.styleTag;
    },
    /*
     * removeStyles: removes the MAQcharts style tag to the document head and sets isInitialized to false
     */
    removeStyles: function() {
        'use strict';
        if (!this.isInitialized) {
            return;
        }
        var head = document.head || document.getElementsByName('head')[0];
        head.removeChild(this.styleTag);
        this.isInitialized = false;
        this.styleTag = null;
    },
    /*
     * addRule: adds a style rule to the MAQcharts style sheet
     * @param {selector}: the CSS selector to add the styles to
     * @param {rule}: the CSS rules separated by semicolon
     */
    addRule: function(selector, rule) {
        'use strict';
        //if selector already exists in styles then return to avoid duplicate rules
        if (undefined !== this.rules[selector]) {
            return;
        }
        var styleTag, sheet, iRuleLength;
        if (!this.isInitialized) {
            this.initStyles();
        }
        styleTag = this.styleTag;
        sheet = styleTag.sheet || styleTag.styleSheet;
        iRuleLength = sheet.cssRules ? sheet.cssRules.length : sheet.rules.length;
        // add a new rule to the style sheet
        if (sheet.insertRule) {
            sheet.insertRule(selector + '{' + rule + '}', iRuleLength);
        } else {
            sheet.addRule(selector, rule);
        }
        //add the selector to tracker
        this.rules[selector] = 1;
    },
    /*
     * jsonToRule: converts a json string or object to semicolon separated css rules
     * @param {sJson}: the CSS rules in json string or object form
     */
    jsonToRule: function(sJson) {
        'use strict';
        var oJson,
            rule = '',
            key;
        if ('string' === typeof sJson) {
            oJson = JSON.parse(sJson);
        } else {
            //else assume it is an Object
            oJson = sJson;
        }

        Object.keys(oJson).forEach(function(key) {
            rule += key + ':' + oJson[key] + ';';
        });
        return rule;
    },
    /*
     * addClass: adds css class to specified object or array of objects
     * @param {oElements}: array of elements or a single element on which class has to be added
     * @param {sClass}: the class to be added
     */
    addClass: function(oElements, sClass) {
        'use strict';
        if (!oElements) {
            return;
        }

        function add_Class(oEle) {
            if (!oEle) {
                return;
            }
            var sClasses = oEle.getAttribute('class');
            if (oEle.classList && oEle.classList.add) {
                oEle.classList.add(sClass);
            } else if (!sClasses) {
                oEle.setAttribute('class', sClass);
            } else if (-1 === sClasses.indexOf(sClass)) {
                sClasses += ' ' + sClass;
                oEle.setAttribute('class', sClasses);
            }
        }
        var iCount = 0,
            iLen;
        if (oElements.length > 0) {
            iLen = oElements.length;
            for (iCount = 0; iCount < iLen; iCount += 1) {
                add_Class(oElements[iCount]);
            }
        } else if (undefined === oElements.length) {
            add_Class(oElements);
        }
    },
    /*
     * addClass: removes css class from specified object or array of objects
     * @param {oElements}: array of elements or a single element from which class has to be removed
     * @param {sClass}: the class to be removed
     */
    removeClass: function(oElements, sClass) {
        'use strict';
        if (!oElements) {
            return;
        }

        function remove_class(oEle) {
            var sClasses = oEle.getAttribute('class');
            if (oEle.classList && oEle.classList.add) {
                oEle.classList.remove(sClass);
                return;
            }
            if (!sClasses || -1 === sClasses.indexOf(sClass)) {
                return;
            }
            sClasses = sClasses.replace(new RegExp(sClass + 's?', 'g'), '');
            oEle.setAttribute('class', sClasses);
        }
        var iCount = 0,
            iLen;
        if (oElements.length > 0) {
            iLen = oElements.length;
            for (iCount = 0; iCount < iLen; iCount += 1) {
                remove_class(oElements[iCount]);
            }
        } else if (undefined === oElements.length) {
            remove_class(oElements);
        }
    }
};
/*
MAQ.charts: Take config from user and call to chart rendering functions
@param {chartConfigOptions} User configuration
*/
MAQ.charts = function(chartConfigOptions) {
    'use strict';
    var x, sResult, oTreemapOptions, oToolTip, oTTStyle, self;
    this.chartOptions = {
        chart: {
            renderTo: '',
            type: '',
            margin: [5],
            isResponsive: false,
            enableTimeline: false,
            style: {
                width: '500px',
                height: '500px'
            }
        },
        title: {
            align: 'left',
            text: '',
            floating: false,
            x: 0,
            y: 0,
            style: {}
        },
        timeline: {
            rangeDisplay: 'chart',
            heightRatio: 0,
            dragStart: 0,
            // should be between 0 and data.length
            dragWidth: 250,
            // should be less than total width of range slider
            dragEnd: 250,
            slider: {
                fill: '#ccc',
                stroke: '#808280',
                'stroke-width': 1
            },
            sliderContainer: {
                fill: 'transparent',
                stroke: '#cdcdcd',
                'stroke-width': 1
            },
            gizmo: {
                shape: 'triangle',
                fill: 'white',
                stroke: '#666'
            },
            dimmer: {
                fill: 'rgb(224, 219, 219)',
                stroke: 'rgb(224, 219, 219)',
                opacity: 0.6
            },
            drillBoxes: {
                fill: 'rgba(255,255,255,0.2)',
                stroke: '#ccc',
                'stroke-width': 2,
                fontStyle: {
                    fontSize: '12px',
                    fill: 'black',
                    textAnchor: 'middle',
                    cursor: 'pointer'
                }
            }
        },
        plotOptions: {
            colors: [
                '#DDDF0D',
                '#7798BF',
                '#55BF3B',
                '#DF5353',
                '#aaeeee',
                '#ff0066',
                '#eeaaee',
                '#55BF3B',
                '#DF5353',
                '#7798BF',
                '#aaeeee'
            ],
            pattern: [''],
            waterfall: {
                padding: 10,
                grouping: {
                    enabled: false,
                    index: 0
                },
                colors: [],
                opacity: 0.8,
                borderColor: '',
                borderRadius: 0,
                borderWidth: 1,
                staggeredLine: {
                    align: 'left',
                    enabled: true,
                    staggeredLineStyle: {
                        'border-top': '2px dashed #2f2f2f',
                        'z-index': 1000
                    }
                },
                singleColumnStack: {
                    enabled: false,
                    stackLabel: '',
                    formatter: ''
                },
                isCustomLegends: '',
                isBudgetForecastDiff: true,
                auxiliaryLabel: {
                    height: 20,
                    formatter: '',
                    style: {
                        fontSize: '12px',
                        fontFamily: 'Segoe UI',
                        color: '#444',
                        textAlign: 'right'
                    }
                },
                section: {
                    labelStyle: {
                        color: '#444',
                        fontSize: '12px',
                        fontFamily: 'Segoe UI',
                        paddingLeft: '5px'
                    },
                    horizontal: {
                        division: []
                    },
                    vertical: {
                        division: [],
                        seriesDivision: {
                            chartMetric: [],
                            chartMetricStyle: [],
                            chartLabelStyle: [],
                            nonChartMetric: [],
                            nonChartMetricStyle: [],
                            nonChartLabelStyle: []
                        }
                    }
                },
                errorCheck: {
                    notNullSeries: ['Revenue']
                }
            },
            brick: {
                opacity: '1',
                style: {
                    width: '159px',
                    height: '159px',
                    marginLeft: '61px',
                    marginTop: '15px'
                },
                brickCount: 10,
                type: 'vertical',
                brickStyle: {
                    border: '0.5px solid #000',
                    height: '15px',
                    width: '15px',
                    padding: '0',
                    margin: '0'
                }
            },
            line: {
                stepLine: false,
                nullValues: 'ignore',
                marker: {
                    enabled: true,
                    fillColor: '#FFF',
                    lineWidth: 2,
                    lineColor: null,
                    width: 0,
                    shape: ['circle'],
                    hover: {
                        enabled: true,
                        style: {
                            opacity: 1
                        }
                    },
                    style: {
                        opacity: 0.5
                    }
                },
                color: ['#0066CC'],
                lineWidth: 2,
                lineDashStyle: 'shortdash'
            },
            lift: {
                dragAreaFill: 'silver',
                dragAreaOpacity: 0.5,
                dragLineStyle: '5,5',
                dragLineWidth: 4,
                dragLineColor: 'black',
                dragWindowFill: 'transparent',
                dragWindowBorderStyle: '',
                dragWindowOpacity: 0,
                dragCircleFill: '#0066CC',
                intersectionMarker: {
                    radius: 20,
                    strokeColor: 'white',
                    strokeWidth: 4,
                    fontStyle: {
                        fill: '#fff',
                        fontSize: '10px',
                        fontFamily: 'Segoe UI',
                        fontWeight: 'bold'
                    },
                    dx: 0,
                    dy: 0
                },
                onDisplayAreaChange: function() {
                    return;
                }
            },
            area: {
                stepLine: false,
                marker: {
                    enabled: false,
                    shape: ['circle'],
                    fillColor: '',
                    lineWidth: 1,
                    lineColor: '',
                    width: 4,
                    hover: {
                        enabled: false,
                        style: {
                            opacity: 1
                        }
                    },
                    style: {}
                },
                color: [],
                opacity: 0.8,
                lineWidth: 1,
                lineDashStyle: '',
                strokes: []
            },
            column: {
                padding: 5,
                groupPadding: 2,
                hover: {
                    enabled: true,
                    style: {
                        opacity: 0.8
                    }
                },
                background: {
                    enabled: false,
                    color: '#EEEEEE'
                },
                stacked: true,
                multiColored: true,
                drill: false,
                drillSeparatorColor: '#DBDBDB',
                drillSeparatorWidth: 1.5,
                drillSeparatorStyle: '4, 1',
                drillColor: [],
                color: [],
                opacity: 0.8,
                borderColor: '',
                borderRadius: 0,
                borderWidth: 1,
                borderDashStyle: '',
                similarColor: false,
                valueBox: {
                    enabled: false,
                    position: 'top',
                    marginBottom: 0,
                    formatter: null,
                    style: {
                        fill: '#444',
                        fontSize: '14px',
                        fontFamily: 'Segoe UI'
                    }
                }
            },
            bar: {
                padding: 5,
                groupPadding: 2,
                stacked: true,
                multiColored: true,
                color: [],
                hover: {
                    enabled: true,
                    style: {
                        opacity: 0.7
                    }
                },
                opacity: 0.8,
                borderColor: '',
                borderRadius: 0,
                borderWidth: 1,
                pushBlankSeries: true,
                borderDashStyle: '',
                valueBox: {
                    enabled: false,
                    position: 'top',
                    marginBottom: 0,
                    style: {
                        fill: '#444',
                        fontSize: '14px',
                        fontFamily: 'Segoe UI'
                    }
                }
            },
            pie: {
                color: [],
                opacity: 0.8,
                borderColor: '',
                borderWidth: 1,
                borderDashStyle: '',
                hover: {
                    enabled: true,
                    style: {
                        cursor: 'pointer',
                        opacity: 0.6
                    }
                },
                dataLabels: {
                    enabled: true,
                    formatter: null,
                    lineWidth: 1,
                    lineColor: '#333333',
                    style: {
                        color: '#333',
                        fontSize: '13px',
                        fontFamily: 'Segoe UI'
                    }
                },
                sliceOnSelect: true,
                resetPreviousSliced: true,
                emptyPie: false
            },
            donut: {
                color: [],
                opacity: 1,
                borderColor: '',
                borderWidth: 1,
                borderDashStyle: '',
                innerRadius: false,
                outerRadius: false,
                dataLabels: {
                    enabled: true,
                    formatter: null,
                    lineWidth: 1,
                    multiline: true,
                    maxChars: 25,
                    lineLengthFactor: 8,
                    lineColor: '#333333',
                    style: {
                        color: '#333',
                        fontSize: '16px',
                        fontFamily: 'Segoe UI'
                    }
                },
                showTotal: {
                    enabled: true,
                    formatter: '',
                    title: {
                        text: '',
                        style: {
                            'text-anchor': 'middle'
                        },
                        x: 0,
                        y: 0
                    },
                    spacing: 18,
                    sumvalue: {
                        style: {
                            'text-anchor': 'middle'
                        },
                        x: 0,
                        y: 0
                    }
                }
            },
            gauge: {
                color: [
                    '#E71E27',
                    '#FBD116',
                    '#6BBE56'
                ],
                //zone colors
                opacity: 1,
                borderColor: '#000',
                gaugeWidth: 40,
                gaugeAngle: 180,
                // Do not update value.. Functionality yet to be implemented.
                pointerHeight: 17,
                pointerWidth: 17,
                borderWidth: 0,
                borderDashStyle: '',
                zone1Angle: 20,
                // red zone angle
                zone2Angle: 20,
                // yelow zone angle
                radius: 120,
                // outer radius for gauge chart
                minValue: 0,
                maxValue: 400,
                target: 200,
                // target line value
                variance: '-8.8%',
                // variance value,
                varianceText: 'MoM Variance',
                pointerValue: 100,
                // pointer value
                dataLabels: {
                    enabled: true,
                    LabelStyle: {
                        color: 'black',
                        fontSize: '12px',
                        fontFamily: 'Segoe UI',
                        padding: '0px',
                        background: '#fff'
                    },
                    ValueStyle: {
                        color: 'green',
                        fontSize: '26px',
                        fontFamily: 'Segoe UI',
                        padding: '10px',
                        formatter: '',
                        targetLineColor: '#fff',
                        pointerColor: '#333'
                    },
                    ActualValueStyle: {
                        color: 'orange',
                        fontSize: '30px',
                        fontFamily: 'Segoe UI'
                    }
                }
            },
            funnel: {
                type: 1,
                color: [],
                opacity: 0.8,
                borderColor: '',
                borderWidth: 1,
                borderDashStyle: '',
                secondaryLabels: {
                    enabled: true,
                    style: {
                        fill: '#000',
                        fontSize: '12px',
                        fontFamily: 'Segoe UI'
                    },
                    dx: 0,
                    dy: 0
                },
                dataLabels: {
                    enabled: true,
                    formatter: null,
                    position: 'center',
                    lineWidth: 1,
                    lineColor: '#333333',
                    dx: 0,
                    dy: 0,
                    style: {
                        fill: '#000',
                        fontSize: '13px',
                        fontFamily: 'Segoe UI'
                    }
                }
            },
            horizontalFunnel: {
                DrillDown: 'Some',
                color: [
                    '9b4f95',
                    'ac88b5',
                    '682079'
                ],
                direction: true,
                connector: true,
                RectangleSize: 78,
                ConnectorSize: 15,
                GapBetweenConnector: 10,
                MaxHeight: 133,
                content: {
                    data: [
                        [
                            'Select Lead 0%',
                            40505247.0896,
                            1262,
                            0.20854193155066,
                            40420952.4546
                        ],
                        [
                            'Qualify Lead 10%',
                            23683584.6195,
                            586, -10.83350373574327,
                            26561080.2395
                        ]
                    ]
                },
                legends: [
                    'Revenue',
                    'Opportunities',
                    'Wk/wk revenue',
                    'Previous week'
                ],
                RowLabels: [
                    'Select Lead 0%',
                    'Qualify Lead 10%'
                ],
                Title: 'Leads',
                StartingYPos: 18
            },
            stock: {
                padding: 15,
                opacity: 0.8,
                borderColor: 'silver',
                borderRadius: 2,
                borderWidth: 1,
                borderDashStyle: 'solid',
                lineWidth: 2,
                lineColor: '#444',
                lineDashStyle: ''
            },
            bubble: {
                color: [
                    '#0066CC',
                    '#CC0000',
                    '#75962A',
                    '#4572a7',
                    '#aa4643',
                    '#89a54e',
                    '#80699b',
                    '#3d96ae',
                    '#db843d'
                ]
            },
            spiderweb: {
                color: [
                    '#0066CC',
                    '#CC0000',
                    '#75962A'
                ],
                axis: {
                    labels: {
                        series: [],
                        style: {
                            fill: '#555555',
                            fontSize: '12px',
                            fontFamily: 'Segoe UI'
                        }
                    },
                    lineWidth: 2,
                    lineColor: '#BBBBBB',
                    numberOfGridLines: 4
                },
                lineWidth: 2
            },
            combolinecolumn: {
                color: [
                    '#0066CC',
                    '#CC0000',
                    '#75962A'
                ]
            },
            timeline: {
                stepLine: false,
                marker: {
                    enabled: true,
                    shape: ['circle'],
                    fillColor: '',
                    lineWidth: 1,
                    lineColor: 'black',
                    width: 6,
                    hover: {
                        enabled: true,
                        style: {
                            opacity: '1 !important'
                        }
                    },
                    style: {
                        opacity: 0
                    }
                },
                rangeDisplay: 'chart',
                heightRatio: 0.3,
                dragStart: 0,
                // should be between 0 and data.length
                dragWidth: 250,
                // should be less than total width of range slider
                dragEnd: 250,
                gizmo: {
                    shape: 'triangle',
                    fill: 'white',
                    stroke: '#666'
                },
                dimmer: {
                    fill: 'rgb(224, 219, 219)',
                    stroke: 'rgb(224, 219, 219)',
                    opacity: 0.6
                },
                drillBoxes: {
                    fill: 'rgba(255,255,255,0.2)',
                    stroke: '#ccc',
                    'stroke-width': 2,
                    fontStyle: {
                        fontSize: '12px',
                        fill: 'black',
                        textAnchor: 'middle',
                        cursor: 'pointer'
                    }
                },
                onChange: '',
                color: ['#0066CC'],
                lineWidth: 2,
                lineDashStyle: '',
                strokes: [],
                opacity: 1,
                xAxisLabelCount: 10
            },
            bowtie: {
                branch: {
                    left: {
                        fieldName: '',
                        fillColor: '#DBDBDB',
                        title: {
                            text: '',
                            align: '',
                            style: {}
                        }
                    },
                    right: {
                        fieldName: '',
                        fillColor: '#DBDBDB',
                        title: {
                            text: '',
                            align: '',
                            style: {}
                        }
                    },
                    spacing: 10,
                    drillDepenedency: 'independent',
                    drillFunction: '',
                    drillBackFunction: ''
                },
                label: {
                    left: {
                        enabled: false,
                        header: [],
                        headerStyle: {},
                        colModel: []
                    },
                    right: {
                        enabled: false,
                        header: [],
                        headerStyle: {},
                        colModel: []
                    },
                    headerDataSpacing: 0
                },
                showTotal: {
                    enabled: true,
                    side: 'max',
                    formatter: '',
                    title: {
                        text: '',
                        style: {}
                    },
                    spacing: 10,
                    style: {}
                }
            },
            halfbowtie: {
                branch: {
                    fieldName: '',
                    fillColor: '#DBDBDB',
                    title: {
                        text: '',
                        align: '',
                        style: {}
                    },
                    spacing: 10,
                    drillDepenedency: 'dependent',
                    drillFunction: '',
                    drillBackFunction: '',
                    navigationHierarchy: []
                },
                label: {
                    enabled: false,
                    header: [],
                    headerStyle: {},
                    colModel: [],
                    headerDataSpacing: 0,
                    headerList: []
                },
                showTotal: {
                    enabled: true,
                    side: 'max',
                    formatter: '',
                    titleTextArray: [],
                    title: {
                        text: '',
                        style: {}
                    },
                    spacing: 10,
                    style: {}
                },
                halfbowtieDataSet: []
            },
            treemap: {
                fieldName: '',
                fieldColor: '',
                drillThrough: {
                    type: 'click',
                    style: {}
                },
                title: {
                    fieldName: '',
                    style: {}
                }
            }
        },
        legend: {
            enabled: true,
            enableClick: true,
            align: 'center',
            verticalAlign: 'bottom',
            verticalAlignLegend: false,
            borderColor: 'silver',
            borderStyle: '',
            borderWidth: 1,
            borderRadius: 5,
            layout: 'horizontal',
            floating: false,
            symbolWidth: 11,
            symbolHeight: 11,
            symbolPadding: 5,
            symbolRadius: 3,
            individualDistance: 5,
            lineHeight: 3,
            customOrder: [],
            hover: {
                enabled: true,
                staticTooltip: false,
                style: {
                    'stroke-width': '3px'
                },
                counterStyle: {
                    opacity: 0.3
                },
                chartStyle: {
                    opacity: 1,
                    'stroke-width': '2px'
                },
                counterChartStyle: {
                    opacity: 0.2
                }
            },
            style: {
                fill: '#444',
                fontSize: '14px',
                fontFamily: 'Segoe UI'
            },
            labelFormat: 1,
            enableTextClipping: false,
            clipTextFrom: 'left',
            clippedTextLength: 10,
            x: 0,
            y: 0
        },
        events: {
            onAnimationComplete: null,
            onTimelineUpdate: null,
            onNavigatorMove: null
        },
        xAxis: {
            title: {
                align: 'left',
                text: '',
                style: {},
                x: 0,
                y: 0
            },
            labels: {
                enabled: true,
                align: 'center',
                series: [],
                formatter: null,
                staggerLines: false,
                rotation: 0,
                style: {},
                x: 0,
                y: 0
            },
            dualxAxis: [{
                labels: {
                    style: {}
                },
                title: {
                    text: '',
                    style: {},
                    x: 0,
                    y: 0
                }
            }, {
                title: {
                    text: '',
                    style: {},
                    x: 0,
                    y: 0
                },
                labels: {
                    enabled: true,
                    align: 'left',
                    series: [],
                    formatter: null,
                    staggerLines: false,
                    rotation: 0,
                    style: {},
                    x: 0,
                    y: 0
                }
            }],
            dualAxisEnabled: false,
            numberOfGridLines: 10,
            lineWidth: 0,
            lineColor: 'silver',
            gridLineWidth: 1,
            gridLineColor: 'silver',
            gridLineDashStyle: 'solid',
            tickWidth: 5,
            tickHeight: 1,
            tickColor: 'silver',
            tickPosition: 'onAxis',
            labelSpacing: 3,
            shiftStartBy: 0,
            skipInterval: 0,
            alternateGridColor: null,
            usageWidth: 100
        },
        yAxis: {
            title: {
                align: 'left',
                text: '',
                style: {},
                x: 0,
                y: 0
            },
            labels: {
                enabled: true,
                align: 'right',
                staggerLines: false,
                series: [],
                formatter: null,
                rotation: 0,
                style: {},
                x: 0,
                y: 0
            },
            dualyAxis: {
                axisLeft: {
                    title: {
                        align: 'left',
                        text: '',
                        style: {},
                        x: 0,
                        y: 0
                    },
                    labels: {
                        enabled: true,
                        align: 'right',
                        staggerLines: false,
                        series: [],
                        formatter: null,
                        rotation: 0,
                        style: {},
                        x: 0,
                        y: 0
                    }
                },
                axisRight: {
                    title: {
                        align: 'left',
                        text: '',
                        style: {},
                        x: 0,
                        y: 0
                    },
                    labels: {
                        enabled: true,
                        align: 'right',
                        staggerLines: false,
                        series: [],
                        formatter: null,
                        rotation: 0,
                        style: {},
                        x: 0,
                        y: 0
                    }
                }
            },
            dualAxisEnabled: false,
            minVal: null,
            maxVal: null,
            numberOfGridLines: 10,
            lineWidth: 0,
            lineColor: 'silver',
            gridLineWidth: 1,
            gridLineColor: 'silver',
            gridLineDashStyle: 'solid',
            tickWidth: 5,
            tickHeight: 1,
            tickColor: 'silver',
            tickPosition: 'onAxis',
            labelSpacing: 3,
            shiftStartBy: 0,
            skipInterval: 0,
            alternateGridColor: null
        },
        tooltip: {
            enabled: true,
            changeBorderColor: true,
            seriesLevelTooltip: false,
            customTooltip: null,
            style: {
                'border-color': 'silver',
                'font-size': '10px',
                'font-family': 'Segoe UI'
            }
        },
        onClick: {
            enabled: false,
            clickFunction: null
        },
        median: {
            enabled: true
        },
        series: [],
        animation: {
            enabled: true,
            type: 1
        }
    };
    /* Copy configuration parameters */
    self = this;
    Object.keys(chartConfigOptions).forEach(function(x) {
        MAQ.mergeObjects(x, self.chartOptions, chartConfigOptions);
    });
    /* Validate Important Options */
    sResult = MAQ.validateOptions(this.chartOptions);
    if (!sResult) {
        if (this.chartOptions.chart.type === 'treemap') {
            oTreemapOptions = this.chartOptions.plotOptions.treemap;
            oTreemapOptions.container = document.getElementById(chartConfigOptions.chart.renderTo);
            oTreemapOptions.original = {};
            oTreemapOptions.original.child = clone(chartConfigOptions.series.child);
            oTreemapOptions.currentLevel = 0;
            oTreemapOptions.selectedValue = [];
            oTreemapOptions.selectedIndex = [];
            oTreemapOptions.currentLayout = [];
            oTreemapOptions.prevLayout = [];
            oToolTip = document.createElement('div');
            oTTStyle = chartConfigOptions.tooltip.style;
            oTTStyle.position = 'absolute';
            oTTStyle.display = 'none';
            oTTStyle.minWidth = '0';
            oTTStyle.left = '0';
            oTTStyle.top = '0';
            oTTStyle.minHeight = '0';
            MAQ.applyStyle(oToolTip, oTTStyle);
            this.chartOptions.container.appendChild(oToolTip);
            this.chartOptions.tooltipDiv = oToolTip;
            MAQ.createTreemap(this.chartOptions);
        } else if ('waterfall' === this.chartOptions.chart.type) {
            MAQ.createWaterfallChart(this.chartOptions);
        } else if ('brick' === this.chartOptions.chart.type) {
            MAQ.createBrickChart(this.chartOptions);
        } else {
            this.chartOptions.svgNS = 'http://www.w3.org/2000/svg';
            this.chartOptions.xlinkNS = 'http://www.w3.org/1999/xlink';
            this.chartOptions.availX = 0;
            this.chartOptions.availY = 0;
            this.chartOptions.availWidth = 0;
            this.chartOptions.availHeight = 0;
            this.chartOptions.useFullXAxis = [
                'line',
                'area',
                'bubble',
                'combolinecolumn'
            ];
            MAQ.createSVGDoc(this.chartOptions);
            //Create SVG document
            MAQ.drawChartTitle(this.chartOptions);
            //Draw chart title
            /* Chart differntiator */
            if (this.chartOptions.chart.enableTimeline || 'timeline' === this.chartOptions.chart.type.toLowerCase()) {
                this.chartOptions.chart.enableTimeline = true;
                MAQ.createTimeLine(this.chartOptions);
            } else {
                switch (this.chartOptions.chart.type.toLowerCase()) {
                    case 'line':
                        MAQ.createLineChart(this.chartOptions);
                        break;
                    case 'area':
                        MAQ.createAreaChart(this.chartOptions);
                        break;
                    case 'column':
                        MAQ.createColumnChart(this.chartOptions);
                        break;
                    case 'bar':
                        MAQ.createBarChart(this.chartOptions);
                        break;
                    case 'pie':
                        MAQ.createPieChart(this.chartOptions);
                        break;
                    case 'donut':
                        MAQ.createPieChart(this.chartOptions);
                        break;
                    case 'funnel':
                        MAQ.createFunnelChart(this.chartOptions);
                        break;
                    case 'horizontalfunnel':
                        MAQ.createHorizontalFunnelChart(this.chartOptions);
                        break;
                    case 'stock':
                        MAQ.createStockChart(this.chartOptions);
                        break;
                    case 'bowtie':
                        this.chartOptions.plotOptions.bowtie.branch.left.currentLevel = 0;
                        this.chartOptions.plotOptions.bowtie.branch.right.currentLevel = 0;
                        this.chartOptions.plotOptions.bowtie.branch.currentLevel = 0;
                        MAQ.createBowTieChart(this.chartOptions);
                        break;
                    case 'bubble':
                        MAQ.createBubbleChart(this.chartOptions);
                        break;
                    case 'spiderweb':
                        MAQ.createSpiderWebChart(this.chartOptions);
                        break;
                    case 'combolinecolumn':
                        MAQ.createComboLineColumnChart(this.chartOptions);
                        break;
                    case 'halfbowtie':
                        this.chartOptions.plotOptions.halfbowtie.branch.currentLevel = 0;
                        MAQ.createHalfBowTieChart(this.chartOptions);
                        break;
                    case 'lift':
                        MAQ.createLiftChart(this.chartOptions);
                        break;
                    case 'gauge':
                        MAQ.createGaugeChart(this.chartOptions);
                        break;
                }
            }
        }
    } else {
        //console.log(sResult);
        return false;
    }
};
/*
MAQ.validateDirectSeriesColor: Validated the color for all the charts
@param {chartConfigOptions} user configuration parameters
@param (inData) to specify whether data values are in data object
*/
MAQ.validateDirectSeriesColor = function(chartConfigOptions, inData) {
    'use strict';
    var iCount,
        arrColor,
        iColorLength,
        iSeriesLength,
        iLine,
        iBar,
        legendColor = [],
        arrTempColorSeries = [],
        tempSeries, lineCount = 0,
        iTempSeries, barCount = 0;
    if (chartConfigOptions.chart.type === 'lift') {
        arrColor = chartConfigOptions.plotOptions.line.color;
    } else {
        arrColor = chartConfigOptions.plotOptions[chartConfigOptions.chart.type].color;
    }
    iColorLength = arrColor.length;
    /* Validating the color for Combo Line Column Chart */
    if ('combolinecolumn' === chartConfigOptions.chart.type) {
        tempSeries = chartConfigOptions.series;
        for (iTempSeries = 0; iTempSeries < tempSeries.length; iTempSeries += 1) {
            if ('line' === tempSeries[iTempSeries].type) {
                lineCount += 1;
            } else {
                barCount += 1;
            }
        }
        if (chartConfigOptions.plotOptions.combolinecolumn.line.color.length < lineCount) {
            arrColor = chartConfigOptions.plotOptions.combolinecolumn.line.color;
            iColorLength = arrColor.length;
            for (iCount = 0; iCount < lineCount; iCount += 1) {
                arrTempColorSeries.push(arrColor[iCount % iColorLength]);
            }
            chartConfigOptions.plotOptions.combolinecolumn.line.color = arrTempColorSeries;
        }
        if (chartConfigOptions.plotOptions.combolinecolumn.column.color.length < barCount) {
            arrColor = chartConfigOptions.plotOptions.combolinecolumn.column.color;
            iColorLength = arrColor.length;
            //empty the array
            arrTempColorSeries = [];
            for (iCount = 0; iCount < barCount; iCount += 1) {
                arrTempColorSeries.push(arrColor[iCount % iColorLength]);
            }
            chartConfigOptions.plotOptions.combolinecolumn.column.color = arrTempColorSeries;
        }
        /* Filling the legend color */
        iLine = 0;
        iBar = 0;
        tempSeries = chartConfigOptions.series;
        for (iTempSeries = 0; iTempSeries < tempSeries.length; iTempSeries += 1) {
            if ('line' === tempSeries[iTempSeries].type) {
                iLine += 1;
                legendColor[iTempSeries] = chartConfigOptions.plotOptions.combolinecolumn.line.color[iLine];
            } else {
                iBar += 1;
                legendColor[iTempSeries] = chartConfigOptions.plotOptions.combolinecolumn.column.color[iBar];
            }
        }
        chartConfigOptions.plotOptions.combolinecolumn.color = legendColor;
        chartConfigOptions.plotOptions.combolinecolumn.line.color = legendColor;
        if (!chartConfigOptions.plotOptions.combolinecolumn.column.multiColored) {
            chartConfigOptions.plotOptions.combolinecolumn.column.color = legendColor;
        }
        return;
    }
    /* Validating the color for all other charts */
    /* Variable: inData is used to specify whether data values are in data object */
    if (!inData) {
        iSeriesLength = chartConfigOptions.series.length;
    } else {
        iSeriesLength = chartConfigOptions.series[0].data.length;
    }
    if (iColorLength < iSeriesLength) {
        for (iCount = 0; iCount < iSeriesLength; iCount += 1) {
            arrTempColorSeries.push(arrColor[iCount % iColorLength]);
        }
        chartConfigOptions.plotOptions[chartConfigOptions.chart.type].color = arrTempColorSeries;
    }
};
/*
MAQ.validateOptions: Validates configuration parameter passed by user
@param {chartConfigOptions} user configuration parameters
*/
MAQ.validateOptions = function(chartConfigOptions) {
    'use strict';
    if (!chartConfigOptions.chart.renderTo) {
        return 'Provide an ID of element to render chart.';
    }
    var containerElement = document.getElementById(chartConfigOptions.chart.renderTo),
        oBowTie,
        oBranch,
        oYAxis,
        oXAxis;
    if (!containerElement) {
        return 'Invalid ID to render chart.';
    }
    chartConfigOptions.container = containerElement;
    if (!chartConfigOptions.chart.type) {
        return 'Kindly specify the type of chart to render.';
    }
    switch (chartConfigOptions.chart.type.toLowerCase()) {
        case 'line':
        case 'lift':
        case 'bubble':
        case 'area':
        case 'spiderweb':
            MAQ.validateDirectSeriesColor(chartConfigOptions, false);
            if (!chartConfigOptions.series.length) {
                //return 'Require atleast 1 series to plot the chart';
            }
            break;
        case 'column':
        case 'bar':
            MAQ.validateDirectSeriesColor(chartConfigOptions, true);
            if (!chartConfigOptions.series.length) {
               // return 'Require atleast 1 series to plot the chart';
            }
            break;
        case 'pie':
        case 'donut':
        case 'gauge':
            MAQ.validateDirectSeriesColor(chartConfigOptions, false);
            break;
        case 'combolinecolumn':
            MAQ.validateDirectSeriesColor(chartConfigOptions, false);
            break;
        case 'funnel':
            MAQ.validateDirectSeriesColor(chartConfigOptions, false);
            if (!chartConfigOptions.series.length) {
                //return 'Require atleast 1 series to plot the chart';
            }
            break;
        case 'stock':
            break;
        case 'bowtie':
            if (!chartConfigOptions.series.length || chartConfigOptions.series.length !== 2) {
                return 'Require two different series to plot the chart';
            }
            oBowTie = chartConfigOptions.plotOptions.bowtie;
            oBranch = oBowTie.branch;
            if (oBranch.drillDepenedency === 'independent' || oBranch.drillDepenedency === 'dependent') {
                if (oBranch.drillDepenedency === 'dependent') {
                    if (!oBranch.drillDepenedency || (oBranch.drillDepenedency && typeof window[oBranch.drillFunction] !== 'function')) {
                        return 'Value in drillDependency is not a valid function';
                    }
                }
            } else {
                return 'Not a valid dependency type';
            }
            if (!(oBowTie.branch.left.fieldName && oBowTie.branch.right.fieldName)) {
                return 'Field name for both left and right bow is required';
            }
            if (oBowTie.label.left.enabled) {
                if (oBowTie.label.left.header.length !== oBowTie.label.left.colModel.length) {
                    return 'Number of columns does not match with number of headers for left branch';
                }
            }
            if (oBowTie.label.right.enabled) {
                if (oBowTie.label.right.header.length !== oBowTie.label.right.colModel.length) {
                    return 'Number of columns does not match with number of headers for right branch';
                }
            }
            break;
        case 'horizontalfunnel':
            break;
        case 'timeline':
            break;
        case 'halfbowtie':
            break;
        case 'treemap':
            break;
        case 'waterfall':
            break;
        case 'brick':
            break;
        default:
            return 'Not a chart type';
    }
    oYAxis = chartConfigOptions.yAxis;
    oXAxis = chartConfigOptions.xAxis;
    switch (chartConfigOptions.chart.type) {
        case 'line':
        case 'area':
        case 'column':
            if (oYAxis.numberOfGridLines < 2) {
                oYAxis.numberOfGridLines = 2;
            }
            oXAxis.numberOfGridLines = oYAxis.numberOfGridLines;
            break;
        case 'bar':
            if (oXAxis.numberOfGridLines < 2) {
                oXAxis.numberOfGridLines = 2;
            }
            oYAxis.numberOfGridLines = oXAxis.numberOfGridLines;
            break;
    }
};
/*
MAQ.animateElement: Used to perform animation on SVG element
@param {oELE} element to animate
@param {sPropertyToAnimate} property name of element to animate
@param {sAnimateValue} value to set for the property
@param {iDuration} duration of animation
*/
MAQ.animateElement = function(oELE, sPropertyToAnimate, sAnimateValue, iDuration) {
    'use strict';
    var currentVal = oELE.getAttributeNS(null, sPropertyToAnimate),
        increment,
        counter,
        process;
    if (currentVal.indexOf('px') > -1) {
        currentVal = currentVal.split('px')[0];
    }
    currentVal = parseInt(currentVal, 10);
    iDuration = iDuration / 3.5;
    increment = (sAnimateValue - currentVal) / iDuration;
    counter = 1;
    process = setInterval(function() {
        currentVal += increment;
        MAQ.addAttr(oELE, sPropertyToAnimate, currentVal);
        if (counter >= iDuration) {
            clearInterval(process);
        }
        counter += 1;
    }, 1);
};
/*
MAQ.animateClipElement: Used to perform animation on clip element
@param {oELE} element to animate
@param {sPropertyToAnimate} property name of element to animate
@param {sAnimateValue} value to set for the property
@param {iDuration} duration of animation
*/
MAQ.animateClipElement = function(oELE, sPropertyToAnimate, sAnimateValue, iDuration) {
    'use strict';
    if (null !== document.getElementById(oELE)) {
        var currentVal = document.getElementById(oELE).getAttribute(sPropertyToAnimate),
            increment,
            counter,
            process;
        if (!currentVal) {
            currentVal = '0';
        }
        if (currentVal.indexOf('px') > -1) {
            currentVal = currentVal.split('px')[0];
        }
        currentVal = parseInt(currentVal, 10);
        iDuration = iDuration / 3.5;
        increment = (sAnimateValue - currentVal) / iDuration;
        counter = 1;
        process = setInterval(function() {
            if (null !== document.getElementById(oELE)) {
                currentVal += increment;
                document.getElementById(oELE).setAttribute(sPropertyToAnimate, currentVal);
                if (counter >= iDuration) {
                    clearInterval(process);
                }
                counter += 1;
            }
        }, 1);
    }
};
/*
MAQ.mergeObjects: Merges objects together like jQuery.extend
@param {x} input object of type: property name of object to merge
@param {oDest} destination object
@param {oSource} source object
*/
MAQ.mergeObjects = function(x, oDest, oSource) {
    'use strict';
    var copy, attr;
    if (typeof oSource[x] === 'string' || typeof oSource[x] === 'number') {
        oDest[x] = oSource[x];
    }
    if (oDest[x] instanceof Date) {
        copy = new Date();
        copy.setTime(oSource[x].getTime());
        oDest[x] = copy;
    }
    if (oDest[x] instanceof Array) {
        if (oSource[x].length > 0) {
            oDest[x] = oSource[x].slice(0);
        }
    }
    if (oDest[x] instanceof Object) {
        attr = null;
        Object.keys(oSource[x]).forEach(function(attr) {
            if (oDest[x].hasOwnProperty(attr)) {
                if (typeof oSource[x][attr] !== 'object') {
                    oDest[x][attr] = oSource[x][attr];
                } else if (oDest[x][attr] instanceof Array) {
                    MAQ.mergeObjects(attr, oDest[x], oSource[x]);
                } else {
                    if (oDest[x][attr]) {
                        if (Object.keys(oDest[x][attr]).length === 0) {
                            oDest[x][attr] = oSource[x][attr];
                        }
                    }
                    MAQ.mergeObjects(attr, oDest[x], oSource[x]);
                }
            } else {
                oDest[x][attr] = oSource[x][attr];
                MAQ.mergeObjects(attr, oDest[x], oSource[x]);
            }
        });
    }
};
/*
isSeriesEnabled: To check is series is enabled
@param {oSeries} user configuration parameters
@param {iSeriesIndex} series of legend enabled/ disabled
*/
function isSeriesEnabled(oSeries, iSeriesIndex) {
    'use strict';
    if (oSeries[iSeriesIndex] && oSeries[iSeriesIndex].enabled === undefined) {
        oSeries[iSeriesIndex].enabled = true;
    }
    return oSeries[iSeriesIndex].enabled;
}
/*
MAQ.computeStrokeDashStyle: Returns SVG value of stroke-dash for a user-friendly name
@param {sDashType} user friendly stroke-dash name
*/
MAQ.computeStrokeDashStyle = function(sDashType) {
    'use strict';
    var sStrokeDashValue = '',
        oDash = {
            solid: '',
            shortdash: '6,2',
            shortdot: '2,2',
            shortdashdot: '6,2,2,2',
            shortdashdotdot: '6,2,2,2,2,2',
            dot: '2,6',
            dash: '8,6',
            longdash: '16,6',
            dashdot: '8,6,2,6',
            longdashdot: '16,6,2,6',
            longdashdotdot: '16,6,2,6,2,6'
        };
    if (oDash[sDashType]) {
        sStrokeDashValue = oDash[sDashType];
    }
    return sStrokeDashValue;
};
/*
MAQ.addAttr: Adds an attribute to object
@param {oELE} input object
@param {sAttrName} attribute name
@param {sAttrValue} attribute value
*/
MAQ.addAttr = function(oELE, sAttrName, sAttrValue) {
    'use strict';
    if (oELE && sAttrValue && ('string' === typeof(sAttrValue) ? -1 === sAttrValue.indexOf('NaN'): true)) {
        oELE.setAttribute(sAttrName, sAttrValue);
    }
};
/*
MAQ.applyStyle: Applies to object
@param {oELE} input object
@param {oStyle} style object containing styling properties
*/
MAQ.applyStyle = function(oELE, oStyle) {
    'use strict';
    if (oStyle && typeof oStyle === 'object') {
        var oStyleColl = Object.keys(oStyle),
            iStyleCounter = 0,
            iNumOfStyle = oStyleColl.length;
        for (iStyleCounter = iNumOfStyle; 0 <= iStyleCounter; iStyleCounter -= 1) {
            oELE.style[oStyleColl[iStyleCounter]] = oStyle[oStyleColl[iStyleCounter]];
        }
    }
};
/*
MAQ.applyMargin: applies margin to chart
@param {chartConfigOptions} user configuration parameters
@param {oMargin} margin array
*/
MAQ.applyMargin = function(chartConfigOptions, oMargin) {
    'use strict';
    if (oMargin.length <= 1 || oMargin.length > 4 || oMargin.length === 3) {
        /*Condition Change*/
        if (1 !== oMargin.length || 0 >= oMargin[0]) {
            oMargin[0] = 5;
        }
        oMargin[1] = oMargin[0];
        oMargin[2] = oMargin[0];
        oMargin[3] = oMargin[0];
    } else if (oMargin.length === 2) {
        oMargin[2] = oMargin[0];
        oMargin[3] = oMargin[1];
    }
    chartConfigOptions.availX += oMargin[3];
    chartConfigOptions.availY += oMargin[0];
    chartConfigOptions.availWidth -= oMargin[1] + oMargin[3];
    chartConfigOptions.availHeight -= oMargin[0] + oMargin[2];
};
/*
MAQ.applyFormatter: applies formatting to data
@param {sText} data to be formatted
@param {sFormatterName} formatter function/ function name
*/
MAQ.applyFormatter = function(sText, sFormatterName) {
    'use strict';
    if (sFormatterName) {
        if (typeof window[sFormatterName] === 'function') {
            sText = window[sFormatterName](sText);
        } else if (MAQ.utils.formatters[sFormatterName] && typeof MAQ.utils.formatters[sFormatterName] === 'function') {
            sText = MAQ.utils.formatters[sFormatterName](sText);
        } else if (typeof sFormatterName === 'function') {
            sText = sFormatterName(sText);
        }
    }
    return sText;
};
/*
MAQ.removeAllChildren: removes all child nodes
@param {oELE} input object
*/
MAQ.removeAllChildren = function(oELE) {
    'use strict';
    while (oELE.hasChildNodes()) {
        oELE.removeChild(oELE.lastChild);
    }
};
/*
MAQ.getMinMax: Returns minimum and maximum value
               Compares users min and max with min and max from Array and returns best result
@param {oDataArray} array of values
@param {min} user's minimum value
@param {max} user's maximum value
*/
MAQ.getMinMax = function(oDataArray, min, max, fieldName) {
    'use strict';
    var iDataArrayLength = oDataArray.length,
        iDataCounter = 0,
        iSum = 0,
        iCurrentValue = 0;
    if (iDataArrayLength) {
        for (iDataCounter = 0; iDataCounter < iDataArrayLength; iDataCounter += 1) {
            iCurrentValue = oDataArray[iDataCounter];
            if (iCurrentValue && typeof iCurrentValue === 'object') {
                if (iCurrentValue[fieldName]) {
                    iCurrentValue = iCurrentValue[fieldName];
                }
            }
            if (typeof iCurrentValue === 'number') {
                iSum += iCurrentValue;
                if (min > iCurrentValue) {
                    min = iCurrentValue;
                }
                if (max < iCurrentValue) {
                    max = iCurrentValue;
                }
            }
            if (typeof iCurrentValue === 'string') {
                if (min.length > iCurrentValue.length) {
                    min = iCurrentValue;
                }
                if (max.length < iCurrentValue.length) {
                    max = iCurrentValue;
                }
            }
        }
    } else {
        min = Math.min(0, min);
        max = Math.max(0, max);
        iSum = 0;
    }
    return {
        min: min,
        max: max,
        total: iSum
    };
};
/*
MAQ.getMinMaxForPie: Returns minimum and maximum value
               Compares users min and max with min and max from Array and returns best result
@param {oDataArray} array of values
@param {min} user's minimum value
@param {max} user's maximum value
*/
MAQ.getMinMaxForPie = function(oDataArray, min, max, fieldName) {
    'use strict';
    var iDataArrayLength = oDataArray.length,
        iDataCounter = 0,
        iSum = 0,
        iCurrentValue = 0;
    if (iDataArrayLength) {
        for (iDataCounter = 0; iDataCounter < iDataArrayLength; iDataCounter += 1) {
            if (isSeriesEnabled(oDataArray, iDataCounter)) {
                iCurrentValue = oDataArray[iDataCounter];
                if (iCurrentValue && typeof iCurrentValue === 'object') {
                    if (iCurrentValue[fieldName]) {
                        iCurrentValue = iCurrentValue[fieldName];
                    }
                }
                if (typeof iCurrentValue === 'number') {
                    iSum += iCurrentValue;
                    if (min > iCurrentValue) {
                        min = iCurrentValue;
                    }
                    if (max < iCurrentValue) {
                        max = iCurrentValue;
                    }
                }
                if (typeof iCurrentValue === 'string') {
                    if (min.length > iCurrentValue.length) {
                        min = iCurrentValue;
                    }
                    if (max.length < iCurrentValue.length) {
                        max = iCurrentValue;
                    }
                }
            }
        }
    } else {
        min = 0;
        max = 0;
        iSum = 0;
    }
    return {
        min: min,
        max: max,
        total: iSum
    };
};
/*
MAQ.getNormalized_Min_Max_Interval: Returns mormalized minimum and maximum value along with axis inteval
@param {iMin} minimum value
@param {iMax} maximum value
@param {iNumberOfAxis} # of axis on X or Y axis
*/
MAQ.getNormalized_Min_Max_Interval = function(iMin, iMax, iNumberOfAxis) {
    'use strict';
    var iOgMax = iMax,
        iOgMin = iMin,
        iInterval,
        fExponent,
        oMultiple,
        iMultipleLength,
        iNormalizationFactor,
        oNormalizationFactor,
        modRes,
        iCounter,
        iIndexPos,
        bMax,
        bMin,
        iNegAxisCount,
        iPosAxisCount,
        iOpNum,
        iLogMultiple,
        iRem,
        iOptimumMax;
    if (iMin < 0) {
        iMax -= iMin;
    }
    bMax = false;
    bMin = false;
    if (iMax < 10) {
        iMax = iMax * 100;
        bMax = true;
    }
    if (Math.abs(iMin) < 10) {
        iMin = iMin * 100;
        bMin = true;
    }
    if (bMax && bMin) {
        iOgMax = iOgMax * 100;
        iOgMin = iOgMin * 100;
    }
    iInterval = Math.ceil(iMax / iNumberOfAxis);
    fExponent = Math.floor(Math.log(iInterval) / Math.log(10));
    oMultiple = [
        2,
        5,
        10
    ];
    iMultipleLength = oMultiple.length;
    iNormalizationFactor = 0;
    oNormalizationFactor = [];
    for (iCounter = 0; iCounter < iMultipleLength; iCounter += 1) {
        modRes = iInterval % Math.pow(oMultiple[iCounter], fExponent);
        oNormalizationFactor[iCounter] = modRes;
        iNormalizationFactor = modRes > iNormalizationFactor ? modRes : iNormalizationFactor;
    }
    iIndexPos = oNormalizationFactor.lastIndexOf(iNormalizationFactor);
    iInterval += Math.pow(oMultiple[iIndexPos], fExponent) - iNormalizationFactor;
    iMax = iOgMax + iInterval - Math.abs(iOgMax) % iInterval;
    if (iMin < 0) {
        iMin = iOgMin - (iOgMin % iInterval + iInterval);
        iNegAxisCount = -(iMin / iInterval);
        iPosAxisCount = iNumberOfAxis - iNegAxisCount;
        if (0 === iPosAxisCount) {
            iPosAxisCount = 1;
        }
        iOptimumMax = iPosAxisCount * iInterval;
        if (iOptimumMax < iOgMax) {
            iOpNum = Math.ceil(iOgMax);
            iLogMultiple = Math.pow(oMultiple[iIndexPos], fExponent);
            while (true) {
                if (iOpNum % iPosAxisCount === 0 && iOpNum % iLogMultiple === 0) {
                    if (iOpNum / iPosAxisCount / iNegAxisCount % iLogMultiple === 0) {
                        break;
                    }
                    iRem = iOpNum / iPosAxisCount / iNegAxisCount % iLogMultiple;
                    iOpNum += iRem;
                } else {
                    if (iOpNum % iPosAxisCount !== 0) {
                        iOpNum = iOpNum + (iPosAxisCount - iOpNum % iPosAxisCount);
                    }
                    if (iOpNum % iLogMultiple !== 0) {
                        iOpNum = iOpNum + (iLogMultiple - iOpNum % iLogMultiple);
                    }
                }
            }
            iMax = iOpNum;
            iInterval = iOpNum / iPosAxisCount;
            iMin = -(iInterval * iNegAxisCount);
        } else {
            iMax = iOptimumMax;
        }
    } else {
        iMax = iInterval * iNumberOfAxis;
    }
    if (bMax && bMin) {
        iInterval = iInterval / 100;
        iMax = iMax / 100;
        iMin = iMin / 100;
    } else {
        iMax = Math.round(iMax);
        iMin = Math.round(iMin);
    }
    return {
        min: iMin,
        max: iMax,
        interval: iInterval
    };
};
/*
MAQ.getObjectDimension: Returns SVG element dimensions like x, y, width and height
@param {oELE} SVG element
*/
MAQ.getObjectDimension = function(oELE) {
    'use strict';
    if (oELE) {
        var oMDim = {};
        var oDim = oELE.getBBox();
        var oDim1 = oELE.getBoundingClientRect();
        oMDim.x = oDim.x;
        oMDim.y = oDim.y;
        oMDim.width = oDim1.width;
        oMDim.height = oDim1.height;
        return oMDim;
    }
};
/*
MAQ.createSVGDoc: Creates SVG document to hold the chart content
@param {chartConfigOptions} user configuration parameters
*/
MAQ.createSVGDoc = function(chartConfigOptions) {
    'use strict';
    chartConfigOptions.container.style.position = 'relative';
    var svgELE = document.createElementNS(chartConfigOptions.svgNS, 'svg');
    MAQ.addAttr(svgELE, 'xmlns', chartConfigOptions.svgNS);
    MAQ.addAttr(svgELE, 'xmlns:xlink', chartConfigOptions.xlinkNS);
    //write viewbox code here
    var sViewBox = '0 0 ';
    if (!chartConfigOptions.chart.style.width) {
        chartConfigOptions.chart.style.width = '500px';
    }
    if (!chartConfigOptions.chart.style.height) {
        chartConfigOptions.chart.style.height = '500px';
    }
    MAQ.applyStyle(svgELE, chartConfigOptions.chart.style);
    chartConfigOptions.container.appendChild(svgELE);
    //Firefox major fix - Do not edit
    chartConfigOptions.availWidth = 0 === svgELE.clientWidth ? 0 === chartConfigOptions.container.clientWidth ? parseInt(chartConfigOptions.chart.style.width, 10) : chartConfigOptions.container.clientWidth : svgELE.clientWidth;
    chartConfigOptions.availHeight = 0 === svgELE.clientHeight ? 0 === chartConfigOptions.container.clientHeight ? parseInt(chartConfigOptions.chart.style.height, 10) : chartConfigOptions.container.clientHeight : svgELE.clientHeight;
    //store total witdh & height for future reference
    chartConfigOptions.width = chartConfigOptions.availWidth;
    chartConfigOptions.height = chartConfigOptions.availHeight;
    //Responsiveness code
    if (true === chartConfigOptions.chart.isResponsive && 'treemap' !== chartConfigOptions.chart.type) {
        //Get the width and height to be used for setting the viewBox
        var iWidth = parseInt(chartConfigOptions.chart.style.width, 10);
        chartConfigOptions.availWidth = parseInt(chartConfigOptions.chart.style.width, 10);
        var iHeight = parseInt(chartConfigOptions.chart.style.height, 10);
        chartConfigOptions.availHeight = parseInt(chartConfigOptions.chart.style.height, 10);
        sViewBox += iWidth + ' ' + iHeight;
        MAQ.addAttr(svgELE, 'viewBox', sViewBox);
        MAQ.addAttr(svgELE, 'preserveAspectRatio', 'xMinYMin meet');
        //Apply percentage width and height to svg root
        svgELE.style.width = '100%';
        svgELE.style.height = '100%';
        MAQ.styles.addClass(svgELE, 'MAQChartsSvgRoot');
        //Hack to maintain height and width ratio of container div
        chartConfigOptions.container.style.height = '0';
        chartConfigOptions.container.style.paddingTop = iHeight / iWidth * 100 + '%';
        svgELE.style.position = 'absolute';
        svgELE.style.top = '0';
        svgELE.style.left = '0';
    }
    var oToolTip = document.createElement('div');
    var oTTStyle = chartConfigOptions.tooltip.style;
    oTTStyle.position = 'absolute';
    oTTStyle.display = 'none';
    oTTStyle.minWidth = '0';
    oTTStyle.minHeight = '0';
    oTTStyle.top = '0';
    oTTStyle.left = '0';
    MAQ.applyStyle(oToolTip, oTTStyle);
    chartConfigOptions.container.appendChild(oToolTip);
    chartConfigOptions.svgELE = svgELE;
    chartConfigOptions.tooltipDiv = oToolTip;
};
/*
MAQ.createSVGElement: Creates any SVG element
@param {nameSpace} SVG namespace
@param {sELEName} SVG element name
@param {oAttr} attibute object consisting of attributes and style object
*/
MAQ.createSVGElement = function(nameSpace, sELEName, oAttr) {
    'use strict';
    var oSVGELE = document.createElementNS(nameSpace, sELEName);
    if (undefined !== oAttr) {
        var oAttrColl = Object.keys(oAttr),
            iAttrCounter = 0,
            iAttrLength = oAttrColl.length;
        for (iAttrCounter = 0; iAttrCounter < iAttrLength; iAttrCounter += 1) {
            switch (oAttrColl[iAttrCounter].toLowerCase()) {
                case 'text':
                    oSVGELE.appendChild(document.createTextNode(oAttr.text));
                    break;
                case 'style':
                    MAQ.applyStyle(oSVGELE, oAttr.style);
                    break;
                case 'image':
                    oSVGELE.setAttributeNS(nameSpace, 'href', oAttr.image);
                    break;
                default:
                    MAQ.addAttr(oSVGELE, oAttrColl[iAttrCounter], oAttr[oAttrColl[iAttrCounter]]);
                    break;
            }
        }
    }
    return oSVGELE;
};
/*
MAQ.drawChartTitle: Renders chart title
@param {chartConfigOptions} user configuration parameters
*/
MAQ.drawChartTitle = function(chartConfigOptions) {
    'use strict';
    var oTitle = chartConfigOptions.title;
    if (oTitle && oTitle.text) {
        var oAttr = {
            x: 0,
            y: 0,
            text: oTitle.text,
            style: oTitle.style
        };
        switch (oTitle.align.toLowerCase()) {
            case 'center':
                oAttr.x = chartConfigOptions.availWidth / 2;
                oAttr.style.textAnchor = 'middle';
                break;
            case 'right':
                oAttr.x = chartConfigOptions.availWidth;
                oAttr.style.textAnchor = 'end';
                break;
        }
        var oTitleObj = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttr),
            oGrpELE = document.createElementNS(chartConfigOptions.svgNS, 'g');
        oGrpELE.setAttribute('class', 'MAQCharts-title');
        oGrpELE.appendChild(oTitleObj);
        chartConfigOptions.svgELE.appendChild(oGrpELE);
        var oDim = MAQ.getObjectDimension(oTitleObj);
        MAQ.addAttr(oTitleObj, 'y', Math.abs(oDim.y));
        if (oTitle.x) {
            MAQ.addAttr(oTitleObj, 'dx', oTitle.x);
        }
        if (oTitle.y) {
            MAQ.addAttr(oTitleObj, 'dy', oTitle.y);
        }
        if (!chartConfigOptions.title.floating) {
            chartConfigOptions.availX = 0;
            chartConfigOptions.availY = oDim.height;
            chartConfigOptions.availWidth -= chartConfigOptions.availX;
            chartConfigOptions.availHeight -= oDim.height;
            if (oTitle.y > 0) {
                chartConfigOptions.availY += oTitle.y;
                chartConfigOptions.availHeight -= oTitle.y;
            }
        }
    }
};
/*
redrawChart: Redraw chart on selected legend
@param {oParam} user configuration parameters (config) and index of legend series (seriesIndex)
*/
function redrawChart(evt, oParam) {
    'use strict';
    if (oParam.config.series[oParam.seriesIndex].enabled) {
        oParam.config.series[oParam.seriesIndex].enabled = false;
    } else if (0 !== oParam.config.series[oParam.seriesIndex].data) {
        oParam.config.series[oParam.seriesIndex].enabled = true;
    } else {
        return; //#62 donut bug fix
    }
    if (true === oParam.config.chart.isResponsive && 'treemap' !== oParam.config.chart.type) {
        oParam.config.availWidth = parseInt(oParam.config.chart.style.width, 10);
        oParam.config.availHeight = parseInt(oParam.config.chart.style.height, 10);
    } else {
        //Firefox major fix - Do not edit
        oParam.config.availWidth = 0 === oParam.config.svgELE.clientWidth ? 0 === oParam.config.container.clientWidth ? parseInt(oParam.config.svgELE.style.width, 10) : oParam.config.container.clientWidth : oParam.config.svgELE.clientWidth;
        oParam.config.availHeight = 0 === oParam.config.svgELE.clientHeight ? 0 === oParam.config.container.clientHeight ? parseInt(oParam.config.svgELE.style.height, 10) : oParam.config.container.clientHeight : oParam.config.svgELE.clientHeight;
    }

    if (!oParam.config.chart.enableTimeline) {
        var oGrpDisplayArea = oParam.config.svgELE;
        MAQ.removeAllChildren(oGrpDisplayArea);
        oParam.config.availX = 0;
        oParam.config.availY = 0;
        MAQ.drawChartTitle(oParam.config);
    } else {
        oParam.config.availHeight = oParam.config.availHeightAfterTitledrawn;
        var elements = document.getElementsByClassName('MAQCharts-TimeLineDisplayArea');
        oParam.config.availHeight = oParam.config.availHeight * (1 - oParam.config.timeline.heightRatio) - oParam.config.timeline.timelinePadding;
        MAQ.removeAllChildren(elements[0]);
        oParam.config.svgELE = elements[0];
    }

    switch (oParam.config.chart.type.toLowerCase()) {
        case 'line':
            MAQ.createLineChart(oParam.config);
            break;
        case 'area':
            MAQ.createAreaChart(oParam.config);
            break;
        case 'column':
            MAQ.createColumnChart(oParam.config);
            break;
        case 'bar':
            oParam.config.plotOptions.bar.pushBlankSeries = false;
            MAQ.createBarChart(oParam.config);
            break;
        case 'pie':
            MAQ.createPieChart(oParam.config);
            break;
        case 'donut':
            MAQ.createPieChart(oParam.config);
            break;
        case 'funnel':
            MAQ.createFunnelChart(oParam.config);
            break;
        case 'stock':
            MAQ.createStockChart(oParam.config);
            break;
        case 'bowtie':
            MAQ.createBowTieChart(oParam.config);
            break;
        case 'bubble':
            MAQ.createBubbleChart(oParam.config);
            break;
        case 'spiderweb':
            MAQ.createSpiderWebChart(oParam.config);
            break;
        case 'timeline':
            MAQ.createTimelineChart(oParam.config);
            break;
        case 'combolinecolumn':
            MAQ.createComboLineColumnChart(oParam.config);
            break;
        case 'lift':
            MAQ.createLiftChart(oParam.config);
            break;
        case 'gauge':
            MAQ.drawChartTitle(oParam.config);
            MAQ.createGaugeChart(oParam.config);
            break;
        case 'brick':
            MAQ.createBrickChart(oParam.config);
            break;
    }
    restoreOriginalValues(oParam.config);
}
/*
END: MAQ.redrawChart: Redraw chart on selected legend
*/
function removeLegendHover(evt, oParam) {
    'use strict';
    //remove all the hover effects
    var oLegendActive = document.querySelectorAll('.MAQCharts-legend-hover'),
        oChartActive = document.querySelectorAll('g.legendActive'),
        oLegendDim = document.querySelectorAll('.MAQCharts-legend-dim'),
        oChartDim = document.querySelectorAll('g.legendDim');
    MAQ.styles.removeClass(oLegendActive, 'MAQCharts-legend-hover');
    MAQ.styles.removeClass(oChartActive, 'legendActive');
    MAQ.styles.removeClass(oLegendDim, 'MAQCharts-legend-dim');
    MAQ.styles.removeClass(oChartDim, 'legendDim');
    //console.log('removed legend hover effects for ' + oParam.seriesIndex);
    /*Remove Legend Hover Effects*/
    //1. Static Tooltip Popup
    if (oParam.config.legend.hover.staticTooltip) {
        MAQ.showHideStaticTooltips(oParam, false);
    }
}
/*
 * applyLengendHover: This method applies the legend hover styles and effects to the corresponding chart plot on hovering of a legend
 * @param {oParam} user configuration parameters (config) and index of legend series (seriesIndex)
 */
function applyLegendHover(evt, oParam) {
    'use strict';
    //first remove all the previous hover effects
    removeLegendHover(evt, oParam);
    var aLegends = oParam.config.legend.legends,
        iCount = 0;
    var iLen = aLegends.length;
    var oChartPlots = oParam.config.plotOptions[oParam.config.chart.type][oParam.config.chart.type + 's'],
        oMarkers;
    if (!oChartPlots) {
        return;
    }
    if (oParam.config.plotOptions[oParam.config.chart.type].marker) {
        oMarkers = oParam.config.plotOptions[oParam.config.chart.type].marker.markers;
    }
    var oEles = [];
    for (iCount = 0; iCount < iLen; iCount += 1) {
        oEles.push(aLegends[iCount].shape);
        oEles.push(aLegends[iCount].text);
    }
    //add counter effect to all legends
    MAQ.styles.addClass(oEles, 'MAQCharts-legend-dim');
    //remove counter effect from the hovered legend
    MAQ.styles.removeClass(aLegends[oParam.config.legend.customOrder[oParam.seriesIndex]].shape, 'MAQCharts-legend-dim');
    MAQ.styles.removeClass(aLegends[oParam.config.legend.customOrder[oParam.seriesIndex]].text, 'MAQCharts-legend-dim');
    //add hover styles to the hovered legend
    MAQ.styles.addClass(aLegends[oParam.config.legend.customOrder[oParam.seriesIndex]].shape, 'MAQCharts-legend-hover');
    MAQ.styles.addClass(aLegends[oParam.config.legend.customOrder[oParam.seriesIndex]].text, 'MAQCharts-legend-hover');
    //add counter effect to all the charts plots
    MAQ.styles.addClass(oChartPlots, 'legendDim');
    if (oMarkers) {
        MAQ.styles.addClass(oMarkers, 'legendDim');
    }
    //remove the counter effect from the chart plot corresponding to hovered legend
    MAQ.styles.removeClass(oChartPlots[oParam.seriesIndex], 'legendDim');
    if (oMarkers) {
        MAQ.styles.removeClass(oMarkers[oParam.seriesIndex], 'legendDim');
    }
    //add hover styles to the chart plot corresponding to the hovered legend
    MAQ.styles.addClass(oChartPlots[oParam.seriesIndex], 'legendActive');
    if (oMarkers) {
        MAQ.styles.addClass(oMarkers[oParam.seriesIndex], 'legendActive');
    }
    /*Add Legend Hover Effects*/
    //1. Static Tooltip
    if (oParam.config.legend.hover.staticTooltip) {
        MAQ.showHideStaticTooltips(oParam, true);
    }
}
/*
MAQ.getMousePos: Gets the current mouse pointer position
@param {obj} object
@param {evt} event
*/
function getMousePos(obj, evt) {
    'use strict';
    // get canvas position
    var top = 0,
        left = 0,
        mouseX,
        mouseY;
    while (obj.tagName !== 'BODY') {
        top += obj.offsetTop;
        left += obj.offsetLeft;
        obj = obj.offsetParent;
    }
    // return relative mouse position
    mouseX = evt.clientX - left + window.pageXOffset;
    mouseY = evt.clientY - top + window.pageYOffset;
    return {
        x: mouseX,
        y: mouseY
    };
}
/*
MAQ.showToolTip: Renders the tooltip on SVG
@param {evt} event
@param {oParam} user configuration parameters and series parameters
*/
function showToolTip(evt, oParam) {
    'use strict';
    var oConfig = oParam.config;
    var oSVG = oConfig.svgELE,
        fInterval = oConfig.plotIntervalWidth,
        oCord = getMousePos(oConfig.container, evt),
        oToolTip = oConfig.tooltipDiv,
        oMarker;
    oToolTip.style.display = 'block';
    oToolTip.style.zIndex = 20;
    if (!oParam.type) {
        var oSeries = oConfig.series[oParam.seriesIndex],
            oLabels = oConfig.series.label,
            oPoint = oSVG.createSVGPoint();
        oPoint.x = evt.clientX;
        oPoint.y = evt.clientY;
        var oSVGCord = oPoint.matrixTransform(oSVG.getScreenCTM().inverse()),
            iSelectedIndex = 0;
        if (oParam.isPosavail) {
            iSelectedIndex = oParam.position;
        } else {
            //if this is multi stacked combo line
            if (undefined !== oParam.rowIndex) {
                iSelectedIndex = MAQ.getDataIndexPosition(oSVGCord, oSeries.xPos[oParam.rowIndex], fInterval);
            } else {
                iSelectedIndex = MAQ.getDataIndexPosition(oSVGCord, oSeries.xPos, fInterval);
            }
        }
        var iMarkerGrps, oCircle, iCount = 0;
        //This "if" drives the marker style changing feature on hover
        if (oSeries.xPos && oSeries.xPos.length > 1 && oConfig.plotOptions[oConfig.chart.type].marker) {
            oMarker = oConfig.plotOptions[oConfig.chart.type].marker;
            if (oMarker.hover && oMarker.hover.enabled && oMarker.markers) {
                iMarkerGrps = oMarker.markers.length;
                if (oConfig.tooltip.seriesLevelTooltip) {
                    for (iCount = 0; iCount < iMarkerGrps; iCount += 1) {
                        if (oMarker.markers[iCount].childNodes[iSelectedIndex]) {
                            oCircle = oMarker.markers[iCount].childNodes[iSelectedIndex];
                            if (undefined !== oMarker.markers[iCount].prevSelectedId) {
                                MAQ.styles.removeClass(oMarker.markers[iCount].childNodes[oMarker.markers[iCount].prevSelectedId], 'MAQCharts-marker-hover');
                            }
                            MAQ.styles.addClass(oCircle, 'MAQCharts-marker-hover');
                            oMarker.markers[iCount].prevSelectedId = iSelectedIndex;
                        }
                    }
                } else {
                    oCircle = oMarker.markers[oParam.seriesIndex].childNodes[iSelectedIndex];
                    if (undefined !== oMarker.markers[oParam.seriesIndex].prevSelectedId) {
                        MAQ.styles.removeClass(oMarker.markers[oParam.seriesIndex].childNodes[oMarker.markers[oParam.seriesIndex].prevSelectedId], 'MAQCharts-marker-hover');
                    }
                    MAQ.styles.addClass(oCircle, 'MAQCharts-marker-hover');
                    oMarker.markers[oParam.seriesIndex].prevSelectedId = iSelectedIndex;
                }
            }
        }
        var sToolTipFunctionName = oConfig.tooltip.customTooltip;
        if (sToolTipFunctionName) {
            var oExtParam = {
                seriesIndex: oParam.seriesIndex,
                dataIndex: iSelectedIndex,
                chartOptions: oConfig
            };
            //this if is for multi stacked combo line column chart
            if (oParam.rowIndex) {
                oExtParam.rowIndex = oParam.rowIndex;
            }
            oToolTip.innerHTML = MAQ.applyFormatter(oExtParam, sToolTipFunctionName);
        } else {
            var sChartType = oConfig.chart.type,
                iLen,
                i,
                tempValue;
            switch (sChartType.toLowerCase()) {
                case 'pie':
                case 'donut':
                case 'funnel':
                    oSeries = oConfig.series[iSelectedIndex];
                    oToolTip.innerHTML = '<b>' + oSeries.name + ': </b>' + Math.round(oSeries.data * 100) / 100;
                    break;
                case 'stock':
                    oToolTip.innerHTML = '<b>' + oLabels[iSelectedIndex] + ': </b><br/>' + 'Low: ' + (Math.round(oSeries.low[iSelectedIndex] * 100) / 100 || '-') + '<br />' + 'High: ' + (Math.round(oSeries.high[iSelectedIndex] * 100) / 100 || '-') + '<br />' + 'Open: ' + (Math.round(oSeries.open[iSelectedIndex] * 100) / 100 || '-') + '<br />' + 'Close: ' + (Math.round(oSeries.close[iSelectedIndex] * 100) / 100 || '-');
                    break;
                case 'bubble':
                    if (oConfig.plotOptions.bubble.consistentBubble) {
                        oToolTip.innerHTML = '<b>' + oSeries.name + '</b><br/>' + '<b>Scale-x value: </b>' + (Math.round(oSeries.data.scaleX[iSelectedIndex] * 100) / 100 || '-') + '<br/><b>Scale-y value: </b>' + (Math.round(oSeries.data.scaleY[iSelectedIndex] * 100) / 100 || '-');
                    } else {
                        oToolTip.innerHTML = '<b>' + oSeries.name + '</b><br/>' + '<b>Scale-x value: </b>' + (Math.round(oSeries.data.scaleX[iSelectedIndex] * 100) / 100 || '-') + '<br/><b>Scale-y value: </b>' + (Math.round(oSeries.data.scaleY[iSelectedIndex] * 100) / 100 || '-') + '<br/><b>Bubble Size: </b>' + (Math.round(oSeries.data.radius[iSelectedIndex] * 100) / 100 || '-');
                    }
                    break;
                case 'spiderweb':
                    oToolTip.innerHTML = '<b>' + oSeries.name + '</b><br/>';
                    iLen = oSeries.data.length;
                    for (i = 0; i < iLen; i += 1) {
                        oToolTip.innerHTML += oConfig.plotOptions.spiderweb.axis.labels.series[i] + ': ' + (Math.round(oSeries.data[i] * 100) / 100 || '-') + '<br/>';
                    }
                    break;
                case 'combolinecolumn':
                    if (oConfig.plotOptions.combolinecolumn.column.multiStacked) {
                        oToolTip.innerHTML = '<b>' + oSeries.name + '</b><br/>' + oLabels[iSelectedIndex] + ': ' + (Math.round(oSeries.data[oParam.rowIndex][iSelectedIndex] * 100) / 100 || '-');
                        break;
                    }
                    /* falls through */
                case 'timeline':
                    if (oConfig.tooltip.seriesLevelTooltip) {
                        iLen = oConfig.series.length;
                        tempValue = '<b>' + oLabels[iSelectedIndex] + '</b>';
                        for (i = 0; i < iLen; i += 1) {
                            oSeries = oConfig.series[i];
                            tempValue += '<br/>' + oSeries.name + ': ' + '<b>' + (Math.round(oSeries.data[iSelectedIndex] * 100) / 100 || 0) + '</b>';
                        }
                    } else {
                        tempValue = '<b>' + oSeries.name + '</b><br/>' + oLabels[iSelectedIndex] + ': ' + (Math.round(oSeries.data[iSelectedIndex] * 100) / 100 || 0);
                    }
                    oToolTip.innerHTML = tempValue;
                    break;
                case 'gauge':
                    if (iSelectedIndex <= 1) {
                        oToolTip.innerHTML = '<b>' + oConfig.series[iSelectedIndex].name + '</b>:<br/>' + MAQ.applyFormatter(oConfig.series[iSelectedIndex].value, 'insertCommas');
                    } else {
                        oToolTip.innerHTML = '<b>Min</b> : ' + MAQ.applyFormatter(oConfig.series[iSelectedIndex].minValue, 'insertCommas') + '<br/><b>Max</b> : ' + MAQ.applyFormatter(oConfig.series[iSelectedIndex].maxValue, 'insertCommas');
                    }
                    break;
                default:
                    oToolTip.innerHTML = '<b>' + oSeries.name + '</b><br/>' + oLabels[iSelectedIndex] + ': ' + (Math.round(oSeries.data[iSelectedIndex] * 100) / 100 || 0);
                    break;
            }
        }
    } else {
        oToolTip.innerHTML = oParam.value;
    }
    //if changeBorder is true and series level tool tip is false then change the border color
    if (oConfig.tooltip.changeBorderColor && !oConfig.tooltip.seriesLevelTooltip) {
        var oPlotOptions = oConfig.plotOptions[oConfig.chart.type.toLowerCase()];
        oToolTip.style.borderColor = oPlotOptions.color && oPlotOptions.color[oParam.seriesIndex % oPlotOptions.color.length] || evt.target.getAttribute('fill') || oConfig.tooltip.style['border-color'];
    }
    var fTopCordinate = oCord.y - oToolTip.clientHeight - 5;
    if (fTopCordinate <= 10) {
        fTopCordinate = oCord.y + 10;
    }
    var fLeftCordinate = oCord.x - oToolTip.clientWidth - 10;
    if (fLeftCordinate <= 10) {
        fLeftCordinate = oCord.x + 10;
    }
    oToolTip.style.top = fTopCordinate + 'px';
    oToolTip.style.left = fLeftCordinate + 'px';
}

function hideToolTip(evt, oParam) {
    'use strict';
    if (undefined === oParam.toolTip) {
        if (oParam.style) {
            oParam.style.display = 'none';
        }
        return;
    }
    var oConfig = oParam.config;
    var oSeries = oConfig.series[oParam.seriesIndex],
        oMarker,
        iMarkerGrps,
        iCount = 0;
    if (oSeries.xPos && oSeries.xPos.length > 1 && oConfig.plotOptions[oConfig.chart.type].marker) {
        oMarker = oConfig.plotOptions[oConfig.chart.type].marker;
        if (oMarker.hover && oMarker.hover.enabled && oMarker.markers) {
            iMarkerGrps = oMarker.markers.length;
            if (oConfig.tooltip.seriesLevelTooltip) {
                for (iCount = 0; iCount < iMarkerGrps; iCount += 1) {
                    if (undefined !== oMarker.markers[iCount].prevSelectedId) {
                        MAQ.styles.removeClass(oMarker.markers[iCount].childNodes[oMarker.markers[iCount].prevSelectedId], 'MAQCharts-marker-hover');
                    }
                }
            } else {
                if (undefined !== oMarker.markers[oParam.seriesIndex].prevSelectedId) {
                    MAQ.styles.removeClass(oMarker.markers[oParam.seriesIndex].childNodes[oMarker.markers[oParam.seriesIndex].prevSelectedId], 'MAQCharts-marker-hover');
                }
            }
        }
    }
    oParam.toolTip.style.display = 'none';
}
/*
 * MAQ.showHideStaticTooltips: Shows or hides static tooltips for each data point of the selected series
 * @param {oParam} user configuration options and seriesIndex
 * @param {bShow} whether to show or hide
 * **NOTE: Currently only supported for line charts
 */
MAQ.showHideStaticTooltips = function(oParam, bShow) {
    'use strict';
    if ('line' !== oParam.config.chart.type.toLowerCase()) {
        console.log('Static tooltips are only supported for line charts.');
        return;
    }
    var oConfig = oParam.config,
        oGrpTooltips = oConfig.plotGroup.querySelectorAll('.MAQCharts-plotArea-tooltips'),
        oSelGrpTooltip = oConfig.plotGroup.querySelector('#MAQCharts-plotArea-tooltips-' + (oParam.seriesIndex + 1)),
        oGrp;
    //find static tooltip class under plot Options group
    //apply display none to all the static tooltip groups
    if (oGrpTooltips && oGrpTooltips.length > 0) {
        Object.keys(oGrpTooltips).forEach(function(oGrp) {
            MAQ.addAttr(oGrpTooltips[oGrp], 'display', 'none');
        });
    }
    //use series index to get the right group
    //remove display none from the selected series static tooltip.
    if (oSelGrpTooltip && bShow) {
        MAQ.addAttr(oSelGrpTooltip, 'display', '');
    }
};
/*
MAQ.drawLegend: Renders chart legend title
@param {chartConfigOptions} user configuration parameters
*/
MAQ.drawLegend = function(chartConfigOptions) {
    'use strict';
    var oLegend = chartConfigOptions.legend,
        oLegStyle,
        oChartStyle,
        oLegCStyle,
        oChartCStyle,
        sRectRule,
        sRectCRule,
        sTextRule,
        sTextCRule,
        sChartRule,
        sChartCRule,
        obj;
    if (oLegend.enabled) {
        oLegend.legends = [];
        if (chartConfigOptions.series.length > 0) {
            var iNumSymbols = chartConfigOptions.series.length,
                iNoOfLegendLines = 1,
                iPadding = 4,
                oDim,
                iSeriesLen = chartConfigOptions.series.length,
                oAttr = {
                    class: 'MAQCharts-legend'
                },
                oGrpLegend = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr),
                customOrder = chartConfigOptions.legend.customOrder;
            chartConfigOptions.svgELE.appendChild(oGrpLegend);
            oAttr = {
                class: 'MAQCharts-legend-labels'
            };
            var oGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
            oGrpLegend.appendChild(oGrpELE);
            var oParam = {};
            var oSymbolAttr = {
                x: 0,
                y: 0,
                rx: oLegend.symbolRadius,
                ry: oLegend.symbolRadius,
                width: oLegend.symbolWidth,
                height: oLegend.symbolHeight,
                fill: '',
                opacity: 1
            };
            var oTextAttr = {
                x: 0,
                y: 0,
                text: '',
                style: JSON.parse(JSON.stringify(oLegend.style))
            };
            var oColor = chartConfigOptions.plotOptions[chartConfigOptions.chart.type].color,
                imaxWidth = 0,
                iSCounter = 0,
                oRectELE,
                sTempText,
                bAttachTooltip,
                iTextLen,
                oTextELE,
                oToolTip;
            //init customOrder if not initialized
            if (customOrder instanceof Array && customOrder.length < iSeriesLen) {
                for (iSCounter = 0; iSCounter < iSeriesLen; iSCounter += 1) {
                    customOrder[iSCounter] = iSCounter;
                }
            }
            if (oLegend.verticalAlignLegend) {
                oLegend.align = 'left';
                imaxWidth = 0;
                //Function to find the max width of a particular legend and then assigning the max width to each legend for horizontal alignment between legends
                //Updated by OL StoreBI team
                for (iSCounter = 0; iSCounter < iNumSymbols; iSCounter += 1) {
                    //Create the temporary HTML element to calculate width
                    obj = document.createElement('span');
                    MAQ.applyStyle(obj, oLegend.style);
                    obj.style.position = 'absolute';
                    obj.style.visibility = 'hidden';
                    obj.innerText = chartConfigOptions.series[customOrder[iSCounter]].name;
                    document.body.appendChild(obj);
                    if (obj.clientWidth > imaxWidth) {
                        imaxWidth = obj.clientWidth;
                    }
                    //Delete the temporary HTML element used to calculate width
                    document.body.removeChild(obj);
                }
            }
            for (iSCounter = 0; iSCounter < iNumSymbols; iSCounter += 1) {
                if (!isSeriesEnabled(chartConfigOptions.series, customOrder[iSCounter])) {
                    oSymbolAttr.opacity = 0.3;
                    oTextAttr.opacity = 0.3;
                } else {
                    oSymbolAttr.opacity = 1;
                    oTextAttr.opacity = 1;
                    oTextAttr.style.fill = oLegend.style.fill;
                }
                oSymbolAttr.fill = oColor[customOrder[iSCounter]];
                oRectELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'rect', oSymbolAttr);
                oGrpELE.appendChild(oRectELE);
                oSymbolAttr.x += oSymbolAttr.width + oLegend.symbolPadding;
                oTextAttr.x = oSymbolAttr.x;
                oTextAttr.text = chartConfigOptions.series[customOrder[iSCounter]].name;
                /* Code for clipping the text to specified number of characters */
                sTempText = '';
                bAttachTooltip = false;
                if (oLegend.enableTextClipping && oLegend.clipTextFrom && 'string' === typeof oLegend.clipTextFrom) {
                    iTextLen = oTextAttr.text.length;
                    if (oLegend.clippedTextLength && 'number' === typeof oLegend.clippedTextLength && iTextLen > oLegend.clippedTextLength) {
                        sTempText = oTextAttr.text;
                        bAttachTooltip = true;
                        switch (oLegend.clipTextFrom.toLowerCase()) {
                            case 'right':
                                oTextAttr.text = '...' + oTextAttr.text.substring(iTextLen - oLegend.clippedTextLength, iTextLen);
                                break;
                            default:
                                oTextAttr.text = oTextAttr.text.substring(0, oLegend.clippedTextLength) + '...';
                                break;
                        }
                    }
                }
                oTextELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oTextAttr);
                oGrpELE.appendChild(oTextELE);
                if (bAttachTooltip) {
                    oParam = {
                        value: sTempText,
                        config: chartConfigOptions,
                        type: 'axis'
                    };
                    oToolTip = chartConfigOptions.tooltipDiv;
                    MAQ.addEventListener(oTextELE, 'mouseover', showToolTip, oParam);
                    MAQ.addEventListener(oTextELE, 'mouseout', hideToolTip, oToolTip);
                }
                oParam = {
                    config: chartConfigOptions,
                    grpNumber: customOrder[iSCounter]
                };
                if (oLegend.enableClick) {
                    oTextELE.style.cursor = 'pointer';
                    oRectELE.style.cursor = 'pointer';
                }
                oDim = MAQ.getObjectDimension(oTextELE);
                //verticalAlignLegend property is set to true.
                //Changing width to a const imaxWidth
                if (oLegend.verticalAlignLegend) {
                    oTextELE.style.width = imaxWidth;
                }
                if (oLegend.layout === 'horizontal') {
                    // if verticalAlignLegend property is set to true
                    //Changing width to a const imaxWidth
                    if (oLegend.verticalAlignLegend && oSymbolAttr.x + imaxWidth > chartConfigOptions.availWidth || oSymbolAttr.x + oDim.width > chartConfigOptions.availWidth) {
                        oSymbolAttr.x = 0;
                        oSymbolAttr.y = iNoOfLegendLines * oDim.height;
                        iNoOfLegendLines += 1;
                        MAQ.addAttr(oRectELE, 'x', oSymbolAttr.x);
                        MAQ.addAttr(oRectELE, 'y', oSymbolAttr.y);
                        oSymbolAttr.x += oSymbolAttr.width + oLegend.symbolPadding;
                        oTextAttr.x = oSymbolAttr.x;
                        MAQ.addAttr(oTextELE, 'x', oTextAttr.x);
                    }
                    MAQ.addAttr(oTextELE, 'y', oSymbolAttr.y + Math.abs(oDim.y) - (oDim.height - oSymbolAttr.height) / 2);
                    if (oLegend.verticalAlignLegend) {
                        oSymbolAttr.x += imaxWidth + oLegend.individualDistance;
                    } else {
                        oSymbolAttr.x += oDim.width + oLegend.individualDistance;
                    }
                } else if (oLegend.layout === 'vertical') {
                    MAQ.addAttr(oTextELE, 'y', oTextAttr.y + oDim.height - oSymbolAttr.height / 2);
                    oSymbolAttr.x = 0;
                    oSymbolAttr.y += oSymbolAttr.height + oLegend.lineHeight;
                    oTextAttr.y = oSymbolAttr.y;
                }
                oParam = {
                    seriesIndex: customOrder[iSCounter],
                    config: chartConfigOptions
                };
                if (chartConfigOptions.legend.enableClick) {
                    /*Call to Redraw Charts on toggling the legends*/
                    MAQ.addEventListener(oRectELE, 'click', redrawChart, oParam);
                    MAQ.addEventListener(oTextELE, 'click', redrawChart, oParam);
                }
                if (chartConfigOptions.legend.hover.enabled && isSeriesEnabled(chartConfigOptions.series, customOrder[iSCounter])) {
                    MAQ.addEventListener(oRectELE, 'mouseover', applyLegendHover, oParam);
                    MAQ.addEventListener(oTextELE, 'mouseover', applyLegendHover, oParam);
                    MAQ.addEventListener(oRectELE, 'mouseout', removeLegendHover, oParam);
                    MAQ.addEventListener(oTextELE, 'mouseout', removeLegendHover, oParam);
                }
                oLegend.legends.push({
                    shape: oRectELE,
                    text: oTextELE
                });
            }
            if (chartConfigOptions.legend.hover.enabled) {
                //define rule names
                sRectRule = '#' + chartConfigOptions.chart.renderTo + ' .MAQCharts-legend-labels>rect.MAQCharts-legend-hover';
                sRectCRule = '#' + chartConfigOptions.chart.renderTo + ' .MAQCharts-legend-labels>rect.MAQCharts-legend-dim';
                sTextRule = '#' + chartConfigOptions.chart.renderTo + ' .MAQCharts-legend-labels>text.MAQCharts-legend-hover';
                sTextCRule = '#' + chartConfigOptions.chart.renderTo + ' .MAQCharts-legend-labels>text.MAQCharts-legend-dim';
                sChartRule = '#' + chartConfigOptions.chart.renderTo + ' .MAQCharts-plotArea>g.legendActive';
                sChartCRule = '#' + chartConfigOptions.chart.renderTo + ' .MAQCharts-plotArea>g.legendDim';
                //set rule variables
                oLegStyle = MAQ.styles.jsonToRule(chartConfigOptions.legend.hover.style);
                oLegCStyle = MAQ.styles.jsonToRule(chartConfigOptions.legend.hover.counterStyle);
                oChartStyle = MAQ.styles.jsonToRule(chartConfigOptions.legend.hover.chartStyle);
                oChartCStyle = MAQ.styles.jsonToRule(chartConfigOptions.legend.hover.counterChartStyle);
                //add the rules to MAQ charts style sheet
                MAQ.styles.addRule(sRectRule + ', ' + sTextRule, oLegStyle);
                MAQ.styles.addRule(sRectCRule + ', ' + sTextCRule, oLegCStyle);
                MAQ.styles.addRule(sChartRule, oChartStyle);
                MAQ.styles.addRule(sChartCRule, oChartCStyle);
            }
            oDim = MAQ.getObjectDimension(oGrpELE);
            oSymbolAttr = {
                x: -iPadding,
                y: -iPadding,
                rx: oLegend.borderRadius,
                ry: oLegend.borderRadius,
                width: oDim.width + iPadding * 2,
                height: oDim.height + iPadding,
                stroke: oLegend.borderColor,
                fill: 'transparent',
                'stroke-width': oLegend.borderWidth,
                'stroke-dasharray': MAQ.computeStrokeDashStyle(oLegend.borderStyle)
            };
            var oBorderRect = MAQ.createSVGElement(chartConfigOptions.svgNS, 'rect', oSymbolAttr);
            oGrpLegend.insertBefore(oBorderRect, oGrpELE);
            oDim = MAQ.getObjectDimension(oGrpLegend);
            var iLegendX, iLegendY, oLayout = [
                0,
                0
            ];
            oAttr = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            };
            switch (oLegend.verticalAlign.toLowerCase()) {
                case 'middle':
                    iLegendY = (chartConfigOptions.availY + chartConfigOptions.availHeight) / 2 - oDim.height / 2;
                    break;
                case 'top':
                    oLayout[0] = 1;
                    iLegendY = chartConfigOptions.availY + iPadding;
                    oAttr.y += oDim.height;
                    oAttr.height -= oDim.height;
                    break;
                default:
                    oLayout[0] = 1;
                    iLegendY = chartConfigOptions.availY + chartConfigOptions.availHeight - oDim.height;
                    oAttr.height -= oDim.height + iPadding;
                    break;
            }
            switch (oLegend.align.toLowerCase()) {
                case 'center':
                    iLegendX = chartConfigOptions.availWidth / 2 - oDim.width / 2;
                    break;
                case 'right':
                    oLayout[1] = 1;
                    iLegendX = chartConfigOptions.availWidth - oDim.width;
                    oAttr.width = iLegendX - chartConfigOptions.availWidth - iPadding;
                    break;
                case 'left':
                    iLegendX = iPadding * 2;
                    break;
                default:
                    oLayout[1] = 1;
                    iLegendX = chartConfigOptions.availX + iPadding * 2;
                    //verticalAlignLegend property is set to true
                    //Changing the required variables
                    if (oLegend.verticalAlignLegend) {
                        oAttr.x += imaxWidth;
                        // oDim.width
                        oAttr.width -= imaxWidth; // oDim.width
                    } else {
                        oAttr.x += oDim.width;
                        oAttr.width -= oDim.width;
                    }
                    break;
            }
            iLegendX += oLegend.x;
            iLegendY += oLegend.y;
            MAQ.addAttr(oGrpLegend, 'transform', 'translate(' + iLegendX + ',' + iLegendY + ')');
            if (!oLegend.floating) {
                chartConfigOptions.availX += oAttr.x;
                chartConfigOptions.availY += oAttr.y;
                chartConfigOptions.availWidth += oAttr.width;
                chartConfigOptions.availHeight += oAttr.height;
                if (oLayout[0] && oLayout[1]) {
                    if (oLegend.verticalAlign === 'top') {
                        chartConfigOptions.availY -= oDim.height;
                    }
                    chartConfigOptions.availHeight += oDim.height;
                }
            }
        }
    }
};
/*
MAQ.drawYAxisTitle: Renders X-axis title
@param {chartConfigOptions} user configuration parameters
*/
MAQ.drawYAxisTitle = function(chartConfigOptions) {
    'use strict';
    var oYAxis = chartConfigOptions.yAxis,
        count,
        oAttr,
        oGrpELE,
        axis,
        oTitleObj,
        oDim = null;
    if (oYAxis.title.text) {
        if (!oYAxis.dualAxisEnabled) {
            oAttr = {
                class: 'MAQCharts-yAxisTitle'
            };
            if ('combolinecolumn' === chartConfigOptions.chart.type) {
                axis = oYAxis.dualyAxis.axisLeft;
            } else {
                axis = oYAxis;
            }
            oGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
            chartConfigOptions.svgELE.appendChild(oGrpELE);
            oAttr = {
                x: chartConfigOptions.availX,
                y: chartConfigOptions.y,
                text: axis.title.text,
                style: axis.title.style
            };
            if (axis.title.x) {
                oAttr.dx = axis.title.x;
            }
            if (axis.title.y) {
                oAttr.dy = axis.title.y;
            }
            switch (axis.title.align.toLowerCase()) {
                case 'center':
                    oAttr.y = chartConfigOptions.availHeight / 2;
                    oAttr.style.textAnchor = 'middle';
                    break;
                case 'right':
                    oAttr.y = chartConfigOptions.availHeight;
                    oAttr.style.textAnchor = 'end';
                    break;
            }
            oTitleObj = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttr);
            oGrpELE.appendChild(oTitleObj);
            oDim = MAQ.getObjectDimension(oTitleObj);
            oAttr.x += Math.abs(oDim.height);
            MAQ.addAttr(oTitleObj, 'x', oAttr.x);
            MAQ.addAttr(oTitleObj, 'transform', 'rotate(270 ' + Math.abs(oAttr.x) + ',' + oAttr.y + ')');
            chartConfigOptions.availX += oDim.height;
            chartConfigOptions.availWidth -= oDim.height;
            if (axis.title.y > 0) {
                chartConfigOptions.availX += axis.title.y;
                chartConfigOptions.availWidth -= axis.title.y;
            }
        } else {
            if (oYAxis.dualyAxis.axisLeft && oYAxis.dualyAxis.axisRight) {
                count = 0;
                var iXvalue;
                for (count = 0; count < 2; count += 1) {
                    if (count === 0) {
                        axis = oYAxis.dualyAxis.axisLeft;
                    } else {
                        axis = oYAxis.dualyAxis.axisRight;
                    }
                    oAttr = {
                        class: 'MAQCharts-yAxisTitle'
                    };
                    oGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
                    iXvalue = chartConfigOptions.availX;
                    if (1 === count) {
                        iXvalue = chartConfigOptions.availWidth + 5;
                    }
                    chartConfigOptions.svgELE.appendChild(oGrpELE);
                    oAttr = {
                        x: iXvalue,
                        y: chartConfigOptions.y,
                        text: axis.title.text,
                        style: axis.title.style
                    };
                    if (axis.title.x) {
                        oAttr.dx = axis.title.x;
                    }
                    if (axis.title.y) {
                        oAttr.dy = axis.title.y;
                    }
                    switch (axis.title.align.toLowerCase()) {
                        case 'center':
                            oAttr.y = chartConfigOptions.availHeight / 2;
                            oAttr.style.textAnchor = 'middle';
                            break;
                        case 'right':
                            oAttr.y = chartConfigOptions.availHeight;
                            oAttr.style.textAnchor = 'end';
                            break;
                    }
                    oTitleObj = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttr);
                    oGrpELE.appendChild(oTitleObj);
                    oDim = MAQ.getObjectDimension(oTitleObj);
                    if (!count) {
                        oAttr.x += Math.abs(oDim.height);
                        chartConfigOptions.availX += oDim.height;
                    }
                    chartConfigOptions.availWidth -= oDim.height;
                    MAQ.addAttr(oTitleObj, 'x', oAttr.x);
                    MAQ.addAttr(oTitleObj, 'transform', 'rotate(270 ' + Math.abs(oAttr.x) + ',' + oAttr.y + ')');
                    if (axis.title.y > 0) {
                        chartConfigOptions.availX += axis.title.y;
                        chartConfigOptions.availWidth -= axis.title.y;
                    }
                }
            }
        }
    }
};
/*
MAQ.drawXAxisTitle: Renders X-axis title
@param {chartConfigOptions} user configuration parameters
*/
MAQ.drawXAxisTitle = function(chartConfigOptions) {
    'use strict';
    var oXAxis = chartConfigOptions.xAxis;
    var oTitleObj, oAttr, oGrpELE, oDim = null;
    if (oXAxis.title.text) {
        if (!oXAxis.dualAxisEnabled) {
            oAttr = {
                class: 'MAQCharts-xAxisTitle'
            };
            oGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
            chartConfigOptions.svgELE.appendChild(oGrpELE);
            oAttr = {
                x: chartConfigOptions.availX,
                y: chartConfigOptions.availY + chartConfigOptions.availHeight - 4,
                text: oXAxis.title.text,
                style: oXAxis.title.style
            };
            switch (oXAxis.title.align.toLowerCase()) {
                case 'center':
                    oAttr.x += chartConfigOptions.availWidth / 2;
                    oAttr.style.textAnchor = 'middle';
                    break;
                case 'right':
                    oAttr.x += chartConfigOptions.availWidth;
                    oAttr.style.textAnchor = 'end';
                    break;
            }
            oTitleObj = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttr);
            oGrpELE.appendChild(oTitleObj);
            if (oXAxis.title.x) {
                MAQ.addAttr(oTitleObj, 'dx', oXAxis.title.x);
            }
            if (oXAxis.title.y) {
                MAQ.addAttr(oTitleObj, 'dy', oXAxis.title.y);
            }
            oDim = MAQ.getObjectDimension(oTitleObj);
            chartConfigOptions.availHeight -= oDim.height;
            if (oXAxis.title.y < 0) {
                chartConfigOptions.availHeight -= Math.abs(oXAxis.title.y);
            }
        } else {
            if (oXAxis.dualxAxis.length === 2) {
                var count = 0,
                    iYvalue;
                for (count = 0; count < 2; count += 1) {
                    oAttr = {
                        class: 'MAQCharts-xAxisTitle'
                    };
                    oGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
                    chartConfigOptions.svgELE.appendChild(oGrpELE);
                    iYvalue = chartConfigOptions.availY + chartConfigOptions.availHeight - 4;
                    if (1 === count) {
                        iYvalue = chartConfigOptions.availY;
                    }
                    oAttr = {
                        x: chartConfigOptions.availX,
                        y: iYvalue,
                        text: chartConfigOptions.xAxis.dualxAxis[count].title.text,
                        style: chartConfigOptions.xAxis.dualxAxis[count].title.style
                    };
                    switch (oXAxis.title.align.toLowerCase()) {
                        case 'center':
                            oAttr.x += chartConfigOptions.availWidth / 2;
                            oAttr.style.textAnchor = 'middle';
                            break;
                        case 'right':
                            oAttr.x += chartConfigOptions.availWidth;
                            oAttr.style.textAnchor = 'end';
                            break;
                    }
                    oTitleObj = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttr);
                    oGrpELE.appendChild(oTitleObj);
                    if (oXAxis.title.x) {
                        MAQ.addAttr(oTitleObj, 'dx', oXAxis.title.x);
                    }
                    if (oXAxis.title.y) {
                        MAQ.addAttr(oTitleObj, 'dy', oXAxis.title.y);
                    }
                    oDim = MAQ.getObjectDimension(oTitleObj);
                    chartConfigOptions.availHeight -= oDim.height;
                    if (oXAxis.title.y < 0) {
                        chartConfigOptions.availHeight -= Math.abs(oXAxis.title.y);
                    }
                }
            }
        }
    }
};
/*
MAQ.getAxisSpacing: Computes space around axis lines
@param {chartConfigOptions} user configuration parameters
@param {oAxis} axis object
@param {sBigData} biggest data in the axis label set
@param {bFlag} flag to decide xAxis or yAxis
*/
MAQ.getAxisSpacing = function(chartConfigOptions, oAxis, sBigData, bFlag) {
    'use strict';
    var oAxisLabel = oAxis.labels,
        fSpacing,
        oAttr,
        oText,
        oDimAxis;
    if (oAxisLabel.enabled) {
        sBigData = MAQ.applyFormatter(sBigData, oAxisLabel.formatter);
    } else {
        sBigData = '';
    }
    fSpacing = 0;
    oAttr = {
        x: 10,
        y: 10,
        text: sBigData,
        style: oAxisLabel.style
    };
    if (oAxisLabel.rotation) {
        oAttr.transform = 'rotate( ' + oAxisLabel.rotation + ' 0,0)';
    }
    oText = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttr);
    chartConfigOptions.svgELE.appendChild(oText);
    oDimAxis = MAQ.getObjectDimension(oText);
    chartConfigOptions.svgELE.removeChild(oText);
    if (bFlag) {
        fSpacing = oDimAxis.height;
    } else {
        fSpacing = oDimAxis.width + oAxis.labelSpacing;
    }
    if (!oAxisLabel.rotation) {
        if (oAxisLabel.staggerLines) {
            fSpacing = 2 * (oDimAxis.height + oAxis.labelSpacing);
        }
    }
    oAxis.tickPosition = oAxis.tickPosition.toLowerCase();
    if (oAxis.tickPosition === 'onaxis') {
        if (bFlag) {
            fSpacing += oAxis.tickHeight / 2;
        } else {
            fSpacing += oAxis.tickWidth / 2;
        }
    } else if (oAxis.tickPosition === 'outside') {
        if (bFlag) {
            fSpacing += oAxis.tickHeight;
        } else {
            fSpacing += oAxis.tickWidth;
        }
    }
    fSpacing = Math.ceil(fSpacing);
    return fSpacing;
};
var iglobalCounter = 0,
    ioriginalyAxisLength,
    ioriginalxAxisLength;
/*
MAQ.drawAxis: Renders both the axes
@param {chartConfigOptions} user configuration parameters
*/
MAQ.drawAxis = function(chartConfigOptions) {
    'use strict';
    var iCounter = 0,
        iLength = 0,
        sBigData = '',
        bottomSpacing = 0,
        leftSpacing = 0,
        sChartType = chartConfigOptions.chart.type,
        xAxis = chartConfigOptions.xAxis,
        yAxis = chartConfigOptions.yAxis,
        xAxisLabel = xAxis.labels,
        yAxisLabel = yAxis.labels,
        xAxisSeries = xAxisLabel.series,
        yAxisSeries = yAxisLabel.series,
        xAxisSeriesLength = 0,
        yAxisSeriesLength = 0,
        yAxisLimit = 0;
    var oAttr = {
        class: 'MAQCharts-chartArea',
        transform: 'translate(' + chartConfigOptions.availX + ',' + chartConfigOptions.availY + ')'
    };
    var oChartContainerGroup = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    chartConfigOptions.svgELE.appendChild(oChartContainerGroup);
    var oDataInfo = null,
        oNormalizedData,
        iStart,
        iInterval,
        oTimelineData,
        temp,
        oGridAreaGrpELE,
        iNumberOfGridLines,
        oGrpYAxis,
        oGrpYAxisLblNTick,
        oAttrYAxis,
        oYAxisLine,
        intervalHeight,
        oAttrTick;
    //Funnel Chart variables
    var fTotalInterval,
        oSeries = chartConfigOptions.series,
        fdelta,
        fConnectorHeight,
        fFunnelGap,
        fTubeHeight;
    /* Compute Space for X-Axis Labels */
    if (sChartType === 'bar') {
        xAxisSeries = yAxisSeries.slice(0);
        if (iglobalCounter === 0) {
            ioriginalyAxisLength = chartConfigOptions.yAxis.labels.series.length;
            ioriginalxAxisLength = chartConfigOptions.xAxis.labels.series.length;
            iglobalCounter += 1;
        }
    }
    /*Condition Change*/
    if (xAxisSeries.length <= 0) {
        iLength = chartConfigOptions.series[0].data.length;
        oTimelineData = chartConfigOptions.timeline.series;
        for (iCounter = 0; iCounter < iLength; iCounter += 1) {
            if (chartConfigOptions.isTimeLineChart) {
                xAxisSeries[iCounter] = MAQ.formatDate(new Date(oTimelineData[iCounter]), 'mmm dd');
            } else {
                xAxisSeries[iCounter] = iCounter + 1;
            }
        }
    }
    /* Compute Space for Y-Axis Labels */
    iLength = yAxis.numberOfGridLines;
    oNormalizedData = chartConfigOptions.plotOptions[sChartType].normalizedData;
    if (iLength !== (oNormalizedData.max - oNormalizedData.min) / oNormalizedData.interval) {
        iLength += 1;
    }
    if ('funnel' !== sChartType) {
        iStart = oNormalizedData.min;
        iInterval = oNormalizedData.interval;
        for (iCounter = 0; iCounter <= iLength; iCounter += 1) {
            yAxisSeries[iCounter] = iStart;
            iStart += iInterval;
            iStart = Math.round(iStart * 100) / 100;
        }
    } else {
        for (iCounter = 0; iCounter < chartConfigOptions.series.length; iCounter += 1) {
            yAxisSeries[iCounter] = chartConfigOptions.series[iCounter].name;
        }
    }
    xAxisSeriesLength = xAxisSeries.length;
    if (chartConfigOptions.useFullXAxis.indexOf(sChartType) > -1) {
        xAxisSeriesLength -= 1;
    }
    yAxisSeriesLength = iLength;
    if (sChartType === 'bar') {
        temp = [];
        temp = xAxisSeries.slice();
        xAxisSeries = yAxisSeries.slice(0);
        yAxisSeries = temp.slice(0);
        chartConfigOptions.yAxis.labels.series = yAxisSeries;
        iNumberOfGridLines = yAxis.numberOfGridLines;
        yAxis.numberOfGridLines = iNumberOfGridLines;
        xAxisSeries = xAxisSeries.slice(0, iNumberOfGridLines + 1);
        xAxisSeriesLength = xAxisSeries.length;
        if (chartConfigOptions.plotOptions.bar.pushBlankSeries) {
            yAxisSeriesLength = yAxisSeries.length;
            yAxisSeries.push('');
        } else {
            yAxisSeriesLength = yAxisSeries.length > 0 ? yAxisSeries.length - 1 : 0;
        }
        yAxisSeries.reverse();
        yAxisLimit = 1;
        xAxis.shiftStartBy = 0;
        xAxisSeriesLength -= 1;
    }
    oDataInfo = MAQ.getMinMax(xAxisSeries, '', '');
    sBigData = oDataInfo.max;
    bottomSpacing = MAQ.getAxisSpacing(chartConfigOptions, xAxis, sBigData, true);
    oDataInfo = MAQ.getMinMax(yAxisSeries, '', '');
    sBigData = oDataInfo.max;
    leftSpacing = MAQ.getAxisSpacing(chartConfigOptions, yAxis, sBigData, false);
    /* Plot Y-Axis, Y-Axis-Ticks, Y-Axis-GridLines and Y-Axis-Labels */
    oAttr = {
        class: 'MAQCharts-yAxis-gridArea'
    };
    oGridAreaGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    oAttr = {
        class: 'MAQCharts-yAxis'
    };
    oGrpYAxis = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    oChartContainerGroup.appendChild(oGrpYAxis);
    oAttr = {
        class: 'MAQCharts-yAxis-Grid-Labels-Ticks'
    };
    oGrpYAxisLblNTick = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    oChartContainerGroup.appendChild(oGrpYAxisLblNTick);
    chartConfigOptions.yLabels = oGrpYAxisLblNTick;
    oGrpYAxisLblNTick.appendChild(oGridAreaGrpELE);
    oAttrYAxis = {
        x1: 0 + leftSpacing,
        y1: 0,
        x2: 0 + leftSpacing,
        y2: chartConfigOptions.availHeight - bottomSpacing,
        stroke: chartConfigOptions.yAxis.lineColor,
        'stroke-width': yAxis.lineWidth
    };
    oAttrYAxis.y2 += oAttrYAxis.y1;
    oYAxisLine = MAQ.createSVGElement(chartConfigOptions.svgNS, 'line', oAttrYAxis);
    oGrpYAxis.appendChild(oYAxisLine);
    if (yAxis.shiftStartBy > 0) {
        oAttrYAxis.y1 += yAxis.shiftStartBy;
    }
    intervalHeight = (oAttrYAxis.y2 - oAttrYAxis.y1) / yAxisSeriesLength;
    oAttrTick = {
        x1: oAttrYAxis.x1,
        y1: oAttrYAxis.y1,
        x2: oAttrYAxis.x1 + yAxis.tickWidth,
        y2: oAttrYAxis.y1,
        stroke: yAxis.tickColor,
        'stroke-width': yAxis.tickHeight
    };
    var oAttrGridLine = {
        x: oAttrYAxis.x1,
        y: oAttrYAxis.y1,
        x1: oAttrYAxis.x1,
        y1: oAttrYAxis.y1,
        x2: chartConfigOptions.availWidth + oAttrYAxis.x1 - leftSpacing,
        y2: oAttrYAxis.y1,
        width: chartConfigOptions.availWidth - leftSpacing,
        height: intervalHeight,
        fill: 'transparent',
        stroke: yAxis.gridLineColor,
        'stroke-dasharray': MAQ.computeStrokeDashStyle(yAxis.gridLineDashStyle),
        'stroke-width': yAxis.gridLineWidth
    };
    var oGridLine;
    var sGridType = 'line';
    if (yAxis.alternateGridColor) {
        sGridType = 'rect';
        oAttrGridLine.stroke = 'transparent';
        oAttrGridLine['stroke-width'] = 0;
        oAttrGridLine.fill = yAxis.alternateGridColor;
    }
    if (yAxis.tickPosition === 'onaxis') {
        oAttrTick.x1 = oAttrTick.x1 - yAxis.tickWidth / 2;
    } else if (yAxis.tickPosition === 'outside') {
        oAttrTick.x1 = oAttrTick.x1 - yAxis.tickWidth;
    }
    oAttrTick.x2 = oAttrTick.x1 + yAxis.tickWidth;
    var oAttrLabel = {
        x: oAttrTick.x1 - yAxis.labelSpacing,
        y: oAttrTick.y1,
        text: '',
        dx: yAxisLabel.x,
        dy: yAxisLabel.y,
        'text-anchor': 'end',
        style: yAxis.labels.style
    };
    var oLabel;
    var oTick;
    switch (yAxis.labels.align) {
        case 'left':
            oAttrLabel.x -= leftSpacing - yAxis.labelSpacing;
            oAttrLabel['text-anchor'] = 'start';
            break;
        case 'center':
            oAttrLabel.x -= leftSpacing / 2;
            oAttrLabel['text-anchor'] = 'middle';
            break;
    }
    var bSkipPlot = false;
    if (yAxis.skipInterval < 0) {
        yAxis.skipInterval = 0;
    }
    var iSkipInterval = yAxis.skipInterval,
        oLabelDim;
    if (yAxisLabel.rotation) {
        oAttrLabel.transform = 'rotate( ' + yAxisLabel.rotation + ' ' + oAttrLabel.x + ',' + oAttrLabel.y + ')';
    }
    chartConfigOptions.availY += oAttrGridLine.y1;
    chartConfigOptions.availHeight = intervalHeight * yAxisSeriesLength;
    chartConfigOptions.plotIntervalHeight = intervalHeight;
    if ('funnel' === sChartType) {
        fTotalInterval = chartConfigOptions.availHeight / oSeries.length;
        fdelta = fTotalInterval * 0.2 / (oSeries.length - 1);
        fConnectorHeight = fdelta + fTotalInterval * 0.2;
        //funnelGap = 0.2% of TotalInterval + portion of the extra funnelGap as gaps are 1 less than length
        fFunnelGap = fTotalInterval * 0.05 * oSeries.length / (oSeries.length - 1);
        fdelta += fTotalInterval * 0.05 / (oSeries.length - 1);
        fTubeHeight = (chartConfigOptions.availHeight - fConnectorHeight * (oSeries.length - 1)) / oSeries.length - 2 * fFunnelGap;
        oAttrGridLine['stroke-width'] = fTubeHeight + 2 * fFunnelGap;
        var tempValue = oAttrGridLine.y1 + fTubeHeight / 2 + 2 * fFunnelGap;
        oAttrGridLine.y = tempValue;
        oAttrGridLine.y1 = tempValue;
        oAttrGridLine.y2 = tempValue;
        oAttrTick.y1 = tempValue;
        oAttrLabel.y = tempValue;
        oAttrTick.y2 = tempValue;
    }
    for (iCounter = yAxisSeriesLength; yAxisLimit <= iCounter; iCounter -= 1) {
        if (bSkipPlot) {
            iSkipInterval -= 1;
        } else {
            oGridLine = MAQ.createSVGElement(chartConfigOptions.svgNS, sGridType, oAttrGridLine);
            oTick = MAQ.createSVGElement(chartConfigOptions.svgNS, 'line', oAttrTick);
            if (sGridType === 'rect') {
                if (iCounter > 0) {
                    if (iCounter % 2 === 0) {
                        oGridAreaGrpELE.appendChild(oGridLine);
                    }
                }
            } else {
                oGridAreaGrpELE.appendChild(oGridLine);
            }
            oGrpYAxisLblNTick.appendChild(oTick);
            if (yAxisLabel.enabled) {
                oAttrLabel.text = yAxisSeries[iCounter];
                oAttrLabel.text = MAQ.applyFormatter(oAttrLabel.text, yAxisLabel.formatter);
                oLabel = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttrLabel);
                oGrpYAxisLblNTick.appendChild(oLabel);
                oLabelDim = MAQ.getObjectDimension(oLabel);
                MAQ.addAttr(oLabel, 'y', oAttrLabel.y + oLabelDim.height / 4);
            }
            bSkipPlot = true;
        }
        if (iSkipInterval === 0) {
            iSkipInterval = yAxis.skipInterval;
            if (iCounter + 1 > Math.floor(yAxis.skipInterval / 2)) {
                bSkipPlot = false;
            }
        }
        if ('funnel' === sChartType) {
            oAttrTick.y2 += fTubeHeight + 2 * fFunnelGap + fConnectorHeight;
        } else {
            oAttrTick.y2 += intervalHeight;
        }
        oAttrGridLine.y = oAttrTick.y2;
        oAttrGridLine.y1 = oAttrTick.y2;
        oAttrGridLine.y2 = oAttrTick.y2;
        oAttrTick.y1 = oAttrTick.y2;
        oAttrLabel.y = oAttrTick.y2;
    }
    /* Plot X-Axis, X-Axis-Ticks, and X-Axis-Labels */
    var oAttrXAxis = {
        x1: oAttrYAxis.x1,
        y1: oAttrYAxis.y2,
        x2: chartConfigOptions.availWidth + oAttrYAxis.x1 - leftSpacing,
        y2: oAttrYAxis.y2,
        stroke: xAxis.lineColor,
        'stroke-width': xAxis.lineWidth
    };
    oAttr = {
        class: 'MAQCharts-xAxis'
    };
    var oGrpXAxis = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    oChartContainerGroup.appendChild(oGrpXAxis);
    oAttr = {
        class: 'MAQCharts-xAxis-Grid-Labels-Ticks'
    };
    var oGrpXAxisLblNTick = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    oChartContainerGroup.appendChild(oGrpXAxisLblNTick);
    chartConfigOptions.xLabels = oGrpXAxisLblNTick;
    oAttr = {
        class: 'MAQCharts-xAxis-gridArea'
    };
    var oXAxisGridAreaGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    oGrpXAxisLblNTick.appendChild(oXAxisGridAreaGrpELE);
    var oXAxisLine = MAQ.createSVGElement(chartConfigOptions.svgNS, 'line', oAttrXAxis);
    oGrpXAxis.appendChild(oXAxisLine);
    iLength = xAxisSeriesLength;
    oAttrXAxis.x2 = xAxis.usageWidth / 100 * (oAttrXAxis.x2 - oAttrXAxis.x1 - xAxis.shiftStartBy);
    oAttrXAxis.x1 += xAxis.shiftStartBy;
    var oChartPlotOptions = chartConfigOptions.plotOptions[sChartType];
    //if fixedWidth is specified then set the interval width equal to it.
    var intervalWidth = chartConfigOptions.fixedWidth && oChartPlotOptions.fixedWidth + oChartPlotOptions.padding - oChartPlotOptions.groupPadding || oAttrXAxis.x2 / Math.max(iLength, 1);
    oAttrGridLine = {
        x: oAttrXAxis.x1,
        y: oAttrYAxis.y1,
        x1: oAttrXAxis.x1,
        y1: oAttrYAxis.y1,
        x2: oAttrXAxis.x1,
        y2: oAttrYAxis.y2,
        width: intervalWidth,
        height: chartConfigOptions.availHeight,
        fill: 'transparent',
        stroke: xAxis.gridLineColor,
        'stroke-dasharray': MAQ.computeStrokeDashStyle(xAxis.gridLineDashStyle),
        'stroke-width': xAxis.gridLineWidth
    };
    sGridType = 'line';
    if (xAxis.alternateGridColor) {
        sGridType = 'rect';
        oAttrGridLine.stroke = 'transparent';
        oAttrGridLine['stroke-width'] = 0;
        oAttrGridLine.fill = xAxis.alternateGridColor;
    }
    oAttrTick = {
        x1: oAttrXAxis.x1,
        y1: oAttrYAxis.y2,
        x2: oAttrXAxis.x1,
        y2: oAttrYAxis.y2 + xAxis.tickHeight,
        stroke: xAxis.tickColor,
        'stroke-width': xAxis.tickWidth
    };
    if (xAxis.tickPosition === 'onaxis') {
        oAttrTick.y1 = oAttrYAxis.y2 - xAxis.tickHeight / 2;
        oAttrTick.y2 = oAttrTick.y1 + xAxis.tickHeight;
    } else if (xAxis.tickPosition === 'inside') {
        oAttrTick.y1 = oAttrYAxis.y2 - xAxis.tickHeight;
        oAttrTick.y2 = oAttrYAxis.y2;
    }
    oAttrLabel = {
        x: oAttrTick.x1,
        y: oAttrTick.y2 + xAxis.labelSpacing,
        dx: xAxisLabel.x,
        dy: xAxisLabel.y,
        text: '',
        style: xAxisLabel.style
    };
    switch (xAxisLabel.align) {
        case 'right':
            oAttrLabel['text-anchor'] = 'end';
            break;
        case 'center':
            oAttrLabel['text-anchor'] = 'middle';
            break;
    }
    chartConfigOptions.availX += oAttrTick.x1;
    var drillIntervalWidth = 0;
    //if drill option is specified and a bar is currently in drilled down state
    //then set the drill interval width equal to drillFixedWidth if specified else set it to normal interval width
    if (chartConfigOptions.drillActive && 1 === chartConfigOptions.drillActive) {
        drillIntervalWidth = chartConfigOptions.plotOptions[sChartType].drillFixedWidth && chartConfigOptions.plotOptions[sChartType].drillFixedWidth + oChartPlotOptions.padding - oChartPlotOptions.groupPadding || intervalWidth;
        chartConfigOptions.availWidth = drillIntervalWidth * (chartConfigOptions.drillDataLength + 1) + intervalWidth * (Math.max(iLength, 1) - (chartConfigOptions.drillDataLength + 1) - 1);
    } else {
        //width edit
        if ('timeline' === chartConfigOptions.chart.type.toLowerCase()) {
            chartConfigOptions.availWidth = intervalWidth * Math.max(xAxisSeries.length - 1, 1);
        } else {
            chartConfigOptions.availWidth = intervalWidth * Math.max(iLength - 1, 1);
        }
    }
    chartConfigOptions.plotIntervalWidth = intervalWidth;
    oAttr = {
        x: 10,
        y: 10,
        text: 'M',
        style: xAxisLabel.style
    };
    var oText = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttr);
    chartConfigOptions.svgELE.appendChild(oText);
    var oDimAxis = MAQ.getObjectDimension(oText);
    chartConfigOptions.svgELE.removeChild(oText);
    bSkipPlot = false;
    if (xAxis.skipInterval < 0) {
        xAxis.skipInterval = 0;
    }
    iSkipInterval = xAxis.skipInterval;
    var iNumOfCharsAllowed = Math.ceil(chartConfigOptions.plotIntervalWidth * Math.max(iSkipInterval, 1) / oDimAxis.width);
    var sTempText = '',
        iPrevX,
        oDim,
        isDrillBar,
        oParam,
        oToolTip,
        iStartOffset;
    for (iCounter = 0; iCounter < xAxisSeries.length; iCounter += 1) {
        isDrillBar = false;
        //If the next bar is a drill bar
        if (chartConfigOptions.drillActive && 1 === chartConfigOptions.drillActive && iCounter + 1 > chartConfigOptions.drillIndex && iCounter <= chartConfigOptions.drillIndex + chartConfigOptions.drillDataLength) {
            isDrillBar = true;
        }
        if (bSkipPlot) {
            iSkipInterval -= 1;
        } else {
            oGridLine = MAQ.createSVGElement(chartConfigOptions.svgNS, sGridType, oAttrGridLine);
            oTick = MAQ.createSVGElement(chartConfigOptions.svgNS, 'line', oAttrTick);
            if (sGridType === 'rect') {
                if (iCounter % 2 === 0) {
                    oXAxisGridAreaGrpELE.appendChild(oGridLine);
                }
            } else {
                oXAxisGridAreaGrpELE.appendChild(oGridLine);
            }
            oGrpXAxisLblNTick.appendChild(oTick);
            if (xAxisLabel.enabled) {
                iPrevX = oAttrLabel.x;
                oAttrLabel.text = xAxisSeries[iCounter];
                oAttrLabel.text = MAQ.applyFormatter(oAttrLabel.text, xAxisLabel.formatter);
                /* Code for clipping the text to specified number of characters */
                sTempText = oAttrLabel.text;
                if (!xAxisLabel.formatter && sTempText.length > iNumOfCharsAllowed) {
                    oAttrLabel.text = oAttrLabel.text.substring(0, Math.max(iNumOfCharsAllowed - 3, 2)) + '...';
                }
                if (xAxisLabel.rotation) {
                    oAttrLabel.transform = 'rotate(' + xAxisLabel.rotation + ' ' + oAttrLabel.x + ',' + oAttrLabel.y + ')';
                }
                oLabel = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttrLabel);
                oGrpXAxisLblNTick.appendChild(oLabel);
                oDim = MAQ.getObjectDimension(oLabel);
                MAQ.addAttr(oLabel, 'y', oAttrLabel.y + oDim.height / 2);
                if (xAxisLabel.staggerLines && !xAxisLabel.rotation) {
                    if (iCounter % 2 !== 0) {
                        MAQ.addAttr(oLabel, 'y', oAttrLabel.y + oDim.height * 2);
                    }
                }
                oParam = {
                    value: sTempText,
                    config: chartConfigOptions,
                    type: 'axis'
                };
                oToolTip = chartConfigOptions.tooltipDiv;
                MAQ.addEventListener(oLabel, 'mouseover', showToolTip, oParam);
                MAQ.addEventListener(oLabel, 'mouseout', hideToolTip, oToolTip);
            }
            bSkipPlot = true;
        }
        if (iSkipInterval === 0) {
            iSkipInterval = xAxis.skipInterval;
            if (xAxisSeries.length - iCounter - 1 > Math.floor(xAxis.skipInterval / 2)) {
                bSkipPlot = false;
            }
        }
        if (iCounter === xAxisSeries.length - 2 && oDim && oAttrLabel.x + intervalWidth - iPrevX > oDim.width) {
            bSkipPlot = false;
        }
        if (isDrillBar) {
            //iStartOffset holds the width/2 value of the Bar just before the first drill bar.
            iStartOffset = 0;
            //if the iCounter equals to first or the last drill bar then set the value of iStartOffset to maintain centering of labels incase of unequal interval width for normal bars and drilled bars
            if (iCounter === chartConfigOptions.drillIndex || iCounter === chartConfigOptions.drillIndex + chartConfigOptions.drillDataLength) {
                iStartOffset = intervalWidth / 2 - drillIntervalWidth / 2;
            }
            oAttrGridLine.width = drillIntervalWidth + iStartOffset;
            oAttrTick.x1 += drillIntervalWidth + iStartOffset;
        } else {
            oAttrGridLine.width = intervalWidth;
            oAttrTick.x1 += intervalWidth;
        }
        oAttrGridLine.x = oAttrTick.x1;
        oAttrGridLine.x1 = oAttrTick.x1;
        oAttrGridLine.x2 = oAttrTick.x1;
        oAttrLabel.x = oAttrTick.x1;
        oAttrTick.x2 = oAttrTick.x1;
    }
};
/*
MAQ.drawSecondaryYAxis: Renders both the axes along with secondary Y axis
@param {chartConfigOptions} user configuration parameters
*/
MAQ.drawSecondaryYAxis = function(chartConfigOptions) {
    'use strict';
    var iCounter = 0,
        iLength = 0,
        bottomSpacing = 0,
        leftSpacing = 0,
        sChartType = chartConfigOptions.chart.type,
        xAxis = chartConfigOptions.xAxis,
        yAxis = chartConfigOptions.yAxis.dualyAxis,
        xAxisLabel = xAxis.labels,
        yAxisLabel = yAxis.axisLeft.labels,
        xAxisSeries = xAxisLabel.series,
        yAxisSeries = yAxisLabel.series,
        xAxisSeriesLength = 0,
        yAxisSeriesLength = 0,
        yAxisLimit = 0,
        sStr = '',
        oAttr = {
            class: 'MAQCharts-chartArea',
            transform: 'translate(' + chartConfigOptions.availX + ',' + chartConfigOptions.availY + ')'
        },
        oChartContainerGroup = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    chartConfigOptions.svgELE.appendChild(oChartContainerGroup);
    var oDataInfo = null;
    /* Compute Space for X-Axis Labels */
    if (sChartType === 'bar') {
        xAxisSeries = yAxisSeries.slice(0);
    }
    /*Condition change*/
    if (xAxisSeries.length <= 0) {
        iLength = chartConfigOptions.series[0].data.length;
        for (iCounter = 0; iCounter < iLength; iCounter += 1) {
            xAxisSeries[iCounter] = iCounter + 1;
        }
    }
    /* Compute Space for Y-Axis Labels */
    iLength = yAxis.numberOfGridLines;
    var oNormalizedData1 = chartConfigOptions.plotOptions[sChartType].normalizedData[1];
    if (iLength !== (oNormalizedData1.max - oNormalizedData1.min) / oNormalizedData1.interval) {
        iLength += 1;
    }
    var iStart = oNormalizedData1.min,
        iInterval = oNormalizedData1.interval,
        yAxisSeries1 = [];
    for (iCounter = 0; iCounter <= iLength; iCounter += 1) {
        yAxisSeries1[iCounter] = iStart;
        iStart += iInterval;
    }
    oDataInfo = MAQ.getMinMax(yAxisSeries1, '', '');
    var rightSpacing = MAQ.getAxisSpacing(chartConfigOptions, chartConfigOptions.yAxis.dualyAxis.axisRight, oDataInfo.max, false);
    //chartConfigOptions.availWidth = chartConfigOptions.availWidth - rightSpacing;
    /* Compute Space for Y-Axis Labels */
    var oNormalizedData = chartConfigOptions.plotOptions[sChartType].normalizedData[0];
    iStart = oNormalizedData.min;
    iInterval = oNormalizedData.interval;
    for (iCounter = 0; iCounter <= iLength; iCounter += 1) {
        yAxisSeries[iCounter] = iStart;
        iStart += iInterval;
    }
    xAxisSeriesLength = xAxisSeries.length;
    yAxisSeriesLength = iLength;
    oDataInfo = MAQ.getMinMax(xAxisSeries, '', '');
    bottomSpacing = MAQ.getAxisSpacing(chartConfigOptions, xAxis, oDataInfo.max, true);
    oDataInfo = MAQ.getMinMax(yAxisSeries, '', '');
    leftSpacing = MAQ.getAxisSpacing(chartConfigOptions, chartConfigOptions.yAxis.dualyAxis.axisLeft, oDataInfo.max, false);
    /* Plot Y-Axis, Y-Axis-Ticks, Y-Axis-GridLines and Y-Axis-Labels */
    oAttr = {
        class: 'MAQCharts-yAxis-gridArea'
    };
    var oGridAreaGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    oAttr = {
        class: 'MAQCharts-yAxis'
    };
    var oGrpYAxis = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    oChartContainerGroup.appendChild(oGrpYAxis);
    oAttr = {
        class: 'MAQCharts-yAxis-Grid-Labels-Ticks'
    };
    var oGrpYAxisLblNTick = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    oChartContainerGroup.appendChild(oGrpYAxisLblNTick);
    chartConfigOptions.yLabels = oGrpYAxisLblNTick;
    oGrpYAxisLblNTick.appendChild(oGridAreaGrpELE);
    var oAttrYAxis = {
        x1: 0 + leftSpacing,
        y1: 0,
        x2: 0 + leftSpacing,
        y2: chartConfigOptions.availHeight - bottomSpacing,
        stroke: yAxis.axisLeft.lineColor,
        'stroke-width': yAxis.axisLeft.lineWidth
    };
    oAttrYAxis.y2 += oAttrYAxis.y1;
    var oYAxisLine = MAQ.createSVGElement(chartConfigOptions.svgNS, 'line', oAttrYAxis);
    oGrpYAxis.appendChild(oYAxisLine);
    if (yAxis.shiftStartBy > 0) {
        oAttrYAxis.y1 += yAxis.shiftStartBy;
    }
    var intervalHeight = (oAttrYAxis.y2 - oAttrYAxis.y1) / yAxisSeriesLength;
    var oAttrTick = {
        x1: oAttrYAxis.x1,
        y1: oAttrYAxis.y1,
        x2: oAttrYAxis.x1 + yAxis.axisLeft.tickWidth,
        y2: oAttrYAxis.y1,
        stroke: yAxis.axisLeft.tickColor,
        'stroke-width': yAxis.axisLeft.tickHeight
    };
    var oTick;
    var oAttrGridLine = {
        x: oAttrYAxis.x1,
        y: oAttrYAxis.y1,
        x1: oAttrYAxis.x1,
        y1: oAttrYAxis.y1,
        x2: chartConfigOptions.availWidth - rightSpacing + oAttrYAxis.x1 - leftSpacing,
        y2: oAttrYAxis.y1,
        width: chartConfigOptions.availWidth - rightSpacing - leftSpacing,
        height: intervalHeight,
        fill: 'transparent',
        stroke: yAxis.gridLineColor,
        'stroke-dasharray': MAQ.computeStrokeDashStyle(yAxis.gridLineDashStyle),
        'stroke-width': yAxis.gridLineWidth
    };
    var oGridLine, sGridType = 'line';
    if (yAxis.alternateGridColor) {
        sGridType = 'rect';
        oAttrGridLine.stroke = 'transparent';
        oAttrGridLine['stroke-width'] = 0;
        oAttrGridLine.fill = yAxis.alternateGridColor;
    }
    if (yAxis.axisLeft.tickPosition === 'onaxis') {
        oAttrTick.x1 = oAttrTick.x1 - yAxis.axisLeft.tickWidth / 2;
    } else if (yAxis.axisLeft.tickPosition === 'outside') {
        oAttrTick.x1 = oAttrTick.x1 - yAxis.axisLeft.tickWidth;
    }
    oAttrTick.x2 = oAttrTick.x1 + yAxis.axisLeft.tickWidth;
    var oAttrLabel = {
        x: oAttrTick.x1 - yAxis.axisLeft.labelSpacing,
        y: oAttrTick.y1,
        text: '',
        dx: yAxisLabel.x,
        dy: yAxisLabel.y,
        'text-anchor': 'end',
        style: yAxisLabel.style
    };
    var oLabel, oLabelDim, decimalLength;
    switch (yAxisLabel.align) {
        case 'left':
            oAttrLabel.x -= leftSpacing - yAxis.axisLeft.labelSpacing;
            oAttrLabel['text-anchor'] = 'start';
            break;
        case 'center':
            oAttrLabel.x -= leftSpacing / 2;
            oAttrLabel['text-anchor'] = 'middle';
            break;
    }
    if (yAxisLabel.rotation) {
        oAttrLabel.transform = 'rotate( ' + yAxisLabel.rotation + ' ' + oAttrLabel.x + ',' + oAttrLabel.y + ')';
    }
    chartConfigOptions.availY += oAttrGridLine.y1;
    chartConfigOptions.availHeight = intervalHeight * yAxisSeriesLength;
    chartConfigOptions.plotIntervalHeight = intervalHeight;
    for (iCounter = yAxisSeriesLength; yAxisLimit <= iCounter; iCounter -= 1) {
        oGridLine = MAQ.createSVGElement(chartConfigOptions.svgNS, sGridType, oAttrGridLine);
        oTick = MAQ.createSVGElement(chartConfigOptions.svgNS, 'line', oAttrTick);
        if (sGridType === 'rect') {
            if (iCounter > 0) {
                if (iCounter % 2 === 0) {
                    oGridAreaGrpELE.appendChild(oGridLine);
                }
            }
        } else {
            oGridAreaGrpELE.appendChild(oGridLine);
        }
        oGrpYAxisLblNTick.appendChild(oTick);
        if (yAxisLabel.enabled) {
            oAttrLabel.text = yAxisSeries[iCounter];
            oAttrLabel.text = MAQ.applyFormatter(oAttrLabel.text, yAxisLabel.formatter);
            if (yAxisLabel.formatter) {
                oAttrLabel.text = MAQ.applyFormatter(oAttrLabel.text, yAxisLabel.formatter);
            } else {
                sStr = oAttrLabel.text.toString();
                if (-1 !== sStr.indexOf('.')) {
                    decimalLength = sStr.substring(sStr.indexOf('.') + 1).length;
                    if (2 < decimalLength) {
                        sStr = oAttrLabel.text * 100 / 100;
                        sStr = sStr.toString();
                        oAttrLabel.text = Number(sStr.match(/^-?\d+(?:\.\d{0,2})?/));
                    }
                }
            }
            oLabel = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttrLabel);
            oGrpYAxisLblNTick.appendChild(oLabel);
            oLabelDim = MAQ.getObjectDimension(oLabel);
            MAQ.addAttr(oLabel, 'y', oAttrLabel.y + oLabelDim.height / 4);
        }
        oAttrTick.y2 += intervalHeight;
        oAttrGridLine.y = oAttrTick.y2;
        oAttrGridLine.y1 = oAttrTick.y2;
        oAttrGridLine.y2 = oAttrTick.y2;
        oAttrTick.y1 = oAttrTick.y2;
        oAttrLabel.y = oAttrTick.y2;
    }
    /* Plot secondary Y-axis */
    yAxisLabel = yAxis.axisRight.labels;
    oGrpYAxisLblNTick = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    oChartContainerGroup.appendChild(oGrpYAxisLblNTick);
    chartConfigOptions.yLabels = oGrpYAxisLblNTick;
    oGrpYAxisLblNTick.appendChild(oGridAreaGrpELE);
    oAttrYAxis = {
        x1: 0 + chartConfigOptions.availWidth - rightSpacing,
        y1: 0,
        x2: 0 + chartConfigOptions.availWidth - rightSpacing,
        y2: chartConfigOptions.availHeight,
        stroke: yAxis.axisRight.lineColor,
        'stroke-width': yAxis.axisRight.lineWidth
    };
    oAttrYAxis.y2 += oAttrYAxis.y1;
    oYAxisLine = MAQ.createSVGElement(chartConfigOptions.svgNS, 'line', oAttrYAxis);
    oGrpYAxis.appendChild(oYAxisLine);
    if (yAxis.shiftStartBy > 0) {
        oAttrYAxis.y1 += yAxis.shiftStartBy;
    }
    intervalHeight = (oAttrYAxis.y2 - oAttrYAxis.y1) / yAxisSeriesLength;
    oAttrTick = {
        x1: oAttrYAxis.x1,
        y1: oAttrYAxis.y1,
        x2: oAttrYAxis.x1 + yAxis.axisRight.tickWidth,
        y2: oAttrYAxis.y1,
        stroke: yAxis.axisRight.tickColor,
        'stroke-width': yAxis.axisRight.tickHeight
    };
    if (yAxis.axisRight.tickPosition === 'onaxis') {
        oAttrTick.x1 = oAttrTick.x1 - yAxis.axisRight.tickWidth / 2;
    } else if (yAxis.tickPosition === 'outside') {
        oAttrTick.x1 = oAttrTick.x1 - yAxis.axisRight.tickWidth;
    }
    oAttrTick.x2 = oAttrTick.x1 + yAxis.axisRight.tickWidth;
    oAttrLabel = {
        x: oAttrTick.x2 + yAxis.axisRight.labelSpacing,
        y: oAttrTick.y1,
        text: '',
        dx: yAxisLabel.x,
        dy: yAxisLabel.y,
        'text-anchor': 'start',
        style: yAxisLabel.style
    };
    switch (yAxisLabel.align) {
        case 'left':
            oAttrLabel.x -= leftSpacing - yAxis.axisRight.labelSpacing;
            oAttrLabel['text-anchor'] = 'start';
            break;
        case 'center':
            oAttrLabel.x -= leftSpacing / 2;
            oAttrLabel['text-anchor'] = 'middle';
            break;
    }
    if (yAxisLabel.rotation) {
        oAttrLabel.transform = 'rotate( ' + yAxisLabel.rotation + ' ' + oAttrLabel.x + ',' + oAttrLabel.y + ')';
    }
    chartConfigOptions.availHeight = intervalHeight * yAxisSeriesLength;
    chartConfigOptions.plotIntervalHeight = intervalHeight;
    for (iCounter = yAxisSeriesLength; yAxisLimit <= iCounter; iCounter -= 1) {
        oGridLine = MAQ.createSVGElement(chartConfigOptions.svgNS, sGridType, oAttrGridLine);
        oTick = MAQ.createSVGElement(chartConfigOptions.svgNS, 'line', oAttrTick);
        oGrpYAxisLblNTick.appendChild(oTick);
        if (yAxisLabel.enabled) {
            oAttrLabel.text = yAxisSeries1[iCounter];
            if (yAxisLabel.formatter) {
                oAttrLabel.text = MAQ.applyFormatter(oAttrLabel.text, yAxisLabel.formatter);
            } else {
                sStr = oAttrLabel.text.toString();
                if (-1 !== sStr.indexOf('.')) {
                    decimalLength = sStr.substring(sStr.indexOf('.') + 1).length;
                    if (2 < decimalLength) {
                        sStr = oAttrLabel.text * 100 / 100;
                        sStr = sStr.toString();
                        oAttrLabel.text = Number(sStr.match(/^-?\d+(?:\.\d{0,2})?/));
                    }
                }
            }
            oLabel = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttrLabel);
            oGrpYAxisLblNTick.appendChild(oLabel);
            oLabelDim = MAQ.getObjectDimension(oLabel);
            MAQ.addAttr(oLabel, 'y', oAttrLabel.y + oLabelDim.height / 4);
        }
        oAttrTick.y2 += intervalHeight;
        oAttrGridLine.y = oAttrTick.y2;
        oAttrGridLine.y1 = oAttrTick.y2;
        oAttrGridLine.y2 = oAttrTick.y2;
        oAttrTick.y1 = oAttrTick.y2;
        oAttrLabel.y = oAttrTick.y2;
    }
    /* Plot X-Axis, X-Axis-Ticks, and X-Axis-Labels */
    var oAttrXAxis = {
        x1: leftSpacing,
        y1: oAttrYAxis.y2,
        x2: chartConfigOptions.availWidth - rightSpacing,
        y2: oAttrYAxis.y2,
        stroke: xAxis.lineColor,
        'stroke-width': xAxis.lineWidth
    };
    oAttr = {
        class: 'MAQCharts-xAxis'
    };
    var oGrpXAxis = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    oChartContainerGroup.appendChild(oGrpXAxis);
    oAttr = {
        class: 'MAQCharts-xAxis-Grid-Labels-Ticks'
    };
    var oGrpXAxisLblNTick = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    oChartContainerGroup.appendChild(oGrpXAxisLblNTick);
    chartConfigOptions.xLabels = oGrpXAxisLblNTick;
    oAttr = {
        class: 'MAQCharts-inner-xAxis-Grid-Labels-Ticks'
    };
    var oGrpInnerXAxisLblNTick = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    oChartContainerGroup.appendChild(oGrpInnerXAxisLblNTick);
    chartConfigOptions.xInnerLabels = oGrpInnerXAxisLblNTick;
    var oXAxisGridAreaGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    oGrpXAxisLblNTick.appendChild(oXAxisGridAreaGrpELE);
    var oXAxisLine = MAQ.createSVGElement(chartConfigOptions.svgNS, 'line', oAttrXAxis);
    oGrpXAxis.appendChild(oXAxisLine);
    iLength = xAxisSeriesLength;
    oAttrXAxis.x2 = xAxis.usageWidth / 100 * (oAttrXAxis.x2 - oAttrXAxis.x1 - xAxis.shiftStartBy - rightSpacing - leftSpacing);
    oAttrXAxis.x1 += xAxis.shiftStartBy;
    var intervalWidth = (oAttrXAxis.x2 + leftSpacing) / iLength;
    oAttrGridLine = {
        x: oAttrXAxis.x1,
        y: oAttrYAxis.y1,
        x1: oAttrXAxis.x1,
        y1: oAttrYAxis.y1,
        x2: oAttrXAxis.x1,
        y2: oAttrYAxis.y2,
        width: intervalWidth,
        height: chartConfigOptions.availHeight,
        fill: 'transparent',
        stroke: xAxis.gridLineColor,
        'stroke-dasharray': MAQ.computeStrokeDashStyle(xAxis.gridLineDashStyle),
        'stroke-width': xAxis.gridLineWidth
    };
    sGridType = 'line';
    if (xAxis.alternateGridColor) {
        sGridType = 'rect';
        oAttrGridLine.stroke = 'transparent';
        oAttrGridLine['stroke-width'] = 0;
        oAttrGridLine.fill = xAxis.alternateGridColor;
    }
    oAttrTick = {
        x1: oAttrXAxis.x1,
        y1: oAttrYAxis.y2,
        x2: oAttrXAxis.x1,
        y2: oAttrYAxis.y2 + xAxis.tickHeight,
        stroke: xAxis.tickColor,
        'stroke-width': xAxis.tickWidth
    };
    if (xAxis.tickPosition === 'onaxis') {
        oAttrTick.y1 = oAttrYAxis.y2 - xAxis.tickHeight / 2;
        oAttrTick.y2 = oAttrTick.y1 + xAxis.tickHeight;
    } else if (xAxis.tickPosition === 'inside') {
        oAttrTick.y1 = oAttrYAxis.y2 - xAxis.tickHeight;
        oAttrTick.y2 = oAttrYAxis.y2;
    }
    oAttrLabel = {
        x: oAttrTick.x1,
        y: oAttrTick.y2 + xAxis.labelSpacing,
        dx: xAxisLabel.x,
        dy: xAxisLabel.y,
        text: '',
        style: xAxisLabel.style
    };
    var oAttrInnerLabel = {
        x: oAttrTick.x1,
        y: oAttrTick.y2 + xAxis.labelSpacing,
        dx: xAxisLabel.innerX,
        dy: xAxisLabel.innerY,
        'text-anchor': 'middle',
        text: '',
        style: xAxisLabel.innerStyle
    };
    switch (xAxisLabel.align) {
        case 'right':
            oAttrLabel['text-anchor'] = 'end';
            break;
        case 'center':
            oAttrLabel['text-anchor'] = 'middle';
            break;
    }
    chartConfigOptions.availX += oAttrTick.x1;
    chartConfigOptions.availWidth = intervalWidth * (iLength - 1);
    chartConfigOptions.plotIntervalWidth = intervalWidth;
    oAttr = {
        x: 10,
        y: 10,
        text: 'M',
        style: xAxisLabel.style
    };
    var oText = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttr);
    chartConfigOptions.svgELE.appendChild(oText);
    var oDimAxis = MAQ.getObjectDimension(oText);
    chartConfigOptions.svgELE.removeChild(oText);
    var iNumOfCharsAllowed = Math.ceil(chartConfigOptions.plotIntervalWidth / oDimAxis.width);
    var bSkipPlot = false;
    if (xAxis.skipInterval < 0) {
        xAxis.skipInterval = 0;
    }
    var iSkipInterval = xAxis.skipInterval,
        sTempText = '',
        iPadding = chartConfigOptions.plotOptions.combolinecolumn.column.padding,
        iGrpPadding = chartConfigOptions.plotOptions.combolinecolumn.column.groupPadding,
        iInnerSeriesLen,
        bSetTooltip,
        oParam,
        oDim,
        oToolTip,
        jCount;
    for (iCounter = 0; iCounter < xAxisSeries.length; iCounter += 1) {
        if (bSkipPlot) {
            iSkipInterval -= 1;
        } else {
            iInnerSeriesLen = 0;
            bSetTooltip = false;
            jCount = 0;
            if (chartConfigOptions.plotOptions.combolinecolumn.column.multiStacked) {
                iInnerSeriesLen = xAxisLabel.innerSeries.length;
                for (jCount = 0; jCount < iInnerSeriesLen; jCount += 1) {
                    oTick = MAQ.createSVGElement(chartConfigOptions.svgNS, 'line', oAttrTick);
                    oGrpInnerXAxisLblNTick.appendChild(oTick);
                    bSetTooltip = false;
                    oAttrInnerLabel.text = xAxisLabel.innerSeries[jCount];
                    oAttrInnerLabel.text = MAQ.applyFormatter(oAttrInnerLabel.text, xAxisLabel.formatter);
                    /* Code for clipping the text to specified number of characters */
                    sTempText = oAttrInnerLabel.text;
                    if (!xAxisLabel.formatter && !xAxisLabel.staggerLines && sTempText.length > iNumOfCharsAllowed) {
                        oAttrInnerLabel.text = oAttrInnerLabel.text.substring(0, iNumOfCharsAllowed) + '...';
                        bSetTooltip = true;
                    }
                    if (xAxisLabel.innerRotation) {
                        oAttrInnerLabel.transform = 'rotate(' + xAxisLabel.innerRotation + ' ' + oAttrInnerLabel.x + ',' + oAttrInnerLabel.y + ')';
                    }
                    oLabel = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttrInnerLabel);
                    oGrpInnerXAxisLblNTick.appendChild(oLabel);
                    oDim = MAQ.getObjectDimension(oLabel);
                    MAQ.addAttr(oLabel, 'y', oAttrInnerLabel.y + oDim.height / 2);
                    if (xAxisLabel.staggerLines && !xAxisLabel.innerRotation) {
                        if (jCount % 2 !== 0) {
                            MAQ.addAttr(oLabel, 'y', oAttrInnerLabel.y + oDim.height * 2);
                        }
                    }
                    if (bSetTooltip) {
                        oParam = {
                            value: sTempText,
                            config: chartConfigOptions,
                            type: 'axis'
                        };
                        oToolTip = chartConfigOptions.tooltipDiv;
                        MAQ.addEventListener(oLabel, 'mouseover', showToolTip, oParam);
                        MAQ.addEventListener(oLabel, 'mouseout', showToolTip, oToolTip);
                    }
                    oAttrTick.x1 += (intervalWidth - iPadding + iGrpPadding) / iInnerSeriesLen;
                    oAttrInnerLabel.x = oAttrTick.x1;
                    oAttrTick.x2 = oAttrTick.x1;
                }
                bSkipPlot = true;
                oAttrTick.x1 += iPadding - iGrpPadding;
                oAttrInnerLabel.x = oAttrTick.x1;
                oAttrTick.x2 = oAttrTick.x1;
            } else {
                oGridLine = MAQ.createSVGElement(chartConfigOptions.svgNS, sGridType, oAttrGridLine);
                oTick = MAQ.createSVGElement(chartConfigOptions.svgNS, 'line', oAttrTick);
                if (sGridType === 'rect') {
                    if (iCounter % 2 === 0) {
                        oXAxisGridAreaGrpELE.appendChild(oGridLine);
                    }
                } else {
                    oXAxisGridAreaGrpELE.appendChild(oGridLine);
                }
                oGrpXAxisLblNTick.appendChild(oTick);
            }
            if (xAxisLabel.enabled) {
                bSetTooltip = false;
                oAttrLabel.text = xAxisSeries[iCounter];
                oAttrLabel.text = MAQ.applyFormatter(oAttrLabel.text, xAxisLabel.formatter);
                /* Code for clipping the text to specified number of characters */
                sTempText = oAttrLabel.text;
                if (!xAxisLabel.formatter && !xAxisLabel.staggerLines && sTempText.length > iNumOfCharsAllowed) {
                    oAttrLabel.text = oAttrLabel.text.substring(0, iNumOfCharsAllowed) + '...';
                    bSetTooltip = true;
                }
                if (xAxisLabel.rotation) {
                    oAttrLabel.transform = 'rotate(' + xAxisLabel.rotation + ' ' + oAttrLabel.x + ',' + oAttrLabel.y + ')';
                }
                oLabel = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttrLabel);
                oGrpXAxisLblNTick.appendChild(oLabel);
                oDim = MAQ.getObjectDimension(oLabel);
                MAQ.addAttr(oLabel, 'y', oAttrLabel.y + oDim.height / 2);
                if (xAxisLabel.staggerLines && !xAxisLabel.rotation) {
                    if (iCounter % 2 !== 0) {
                        MAQ.addAttr(oLabel, 'y', oAttrLabel.y + oDim.height * 2);
                    }
                }
                if (bSetTooltip) {
                    oParam = {
                        value: sTempText,
                        config: chartConfigOptions,
                        type: 'axis'
                    };
                    oToolTip = chartConfigOptions.tooltipDiv;
                    MAQ.addEventListener(oLabel, 'mouseover', showToolTip, oParam);
                    MAQ.addEventListener(oLabel, 'mouseout', showToolTip, oToolTip);
                }
            }
            bSkipPlot = true;
        }
        if (iSkipInterval === 0) {
            iSkipInterval = xAxis.skipInterval;
            if (xAxisSeries.length - iCounter - 1 > Math.floor(xAxis.skipInterval / 2)) {
                bSkipPlot = false;
            }
        }
        if (iCounter === xAxisSeries.length - 2) {
            bSkipPlot = false;
        }
        if (!chartConfigOptions.plotOptions.combolinecolumn.column.multiStacked) {
            oAttrTick.x1 += intervalWidth;
        }
        oAttrGridLine.x = oAttrTick.x1;
        oAttrGridLine.x1 = oAttrTick.x1;
        oAttrGridLine.x2 = oAttrTick.x1;
        oAttrLabel.x = oAttrTick.x1;
        oAttrTick.x2 = oAttrTick.x1;
    }
};
/*
MAQ.createLineChart: Renders line chart
@param {chartConfigOptions} user configuration parameters
*/
MAQ.createLineChart = function(chartConfigOptions) {
    'use strict';
    MAQ.drawLegend(chartConfigOptions);
    MAQ.drawXAxisTitle(chartConfigOptions);
    MAQ.drawYAxisTitle(chartConfigOptions);
    MAQ.applyMargin(chartConfigOptions, chartConfigOptions.chart.margin);
    var oDataInfo = {
            min: 0,
            max: 1
        },
        oSeries = chartConfigOptions.series,
        clipPathNode = '',
        clipPathID = '',
        iSeriesLength = oSeries.length,
        iSeriesCounter = 0,
        iCounter = 0,
        iLength = 0,
        oGrpELE,
        oNormalizedData,
        oMarkerEle,
        oTooltipEle,
        animationConfigurations = getAnimationConfigurations(chartConfigOptions);
    oSeries.label = chartConfigOptions.xAxis.labels.series;
    for (iSeriesCounter = 0; iSeriesCounter < iSeriesLength; iSeriesCounter += 1) {
        if (isSeriesEnabled(oSeries, iSeriesCounter)) {
            oDataInfo = MAQ.getMinMax(oSeries[iSeriesCounter].data, oDataInfo.min, oDataInfo.max);
        }
    }
    if (oDataInfo.min || oDataInfo.max) {
        if ((chartConfigOptions.yAxis.minVal || 0 === chartConfigOptions.yAxis.minVal) && chartConfigOptions.yAxis.maxVal) {
            oNormalizedData = {
                min: chartConfigOptions.yAxis.minVal,
                max: chartConfigOptions.yAxis.maxVal
            };
            oNormalizedData.interval = (oNormalizedData.max - oNormalizedData.min) / chartConfigOptions.yAxis.numberOfGridLines;
        } else {
            oNormalizedData = MAQ.getNormalized_Min_Max_Interval(oDataInfo.min, oDataInfo.max, chartConfigOptions.yAxis.numberOfGridLines);
        }
        oNormalizedData.sum = oNormalizedData.max + Math.abs(oNormalizedData.min);
        chartConfigOptions.plotOptions.line.normalizedData = oNormalizedData;
        MAQ.drawAxis(chartConfigOptions);
        if (chartConfigOptions.animation.enabled) {
            clipPathNode = document.querySelectorAll('#' + chartConfigOptions.chart.renderTo + 'clippath');
            if (clipPathNode.length > 0) {
                clipPathID = String(chartConfigOptions.chart.renderTo + 'clippath' + clipPathNode.length);
            } else {
                clipPathID = String(chartConfigOptions.chart.renderTo + 'clippath');
            }
            var oClipAttr = {
                id: clipPathID
            };
            oGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'clipPath', oClipAttr);
            var oClipRectAttr = {
                id: clipPathID + 'Rect',
                x: animationConfigurations.x - chartConfigOptions.plotOptions.line.marker.width,
                y: animationConfigurations.y,
                width: animationConfigurations.width,
                height: animationConfigurations.height
            };
            oGrpELE.appendChild(MAQ.createSVGElement(chartConfigOptions.svgNS, 'rect', oClipRectAttr));
            chartConfigOptions.svgELE.appendChild(oGrpELE);
        }
        var oAttr = {
            class: 'MAQCharts-plotArea',
            transform: 'translate(' + chartConfigOptions.availX + ',' + chartConfigOptions.availY + ')',
            opacity: 1,
            width: 10,
            'clip-path': chartConfigOptions.animation.enabled ? 'url(#' + clipPathID + ')' : ''
        };
        oGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
        chartConfigOptions.svgELE.appendChild(oGrpELE);
        //store a reference to the MAQCharts-PlotArea SVG group
        chartConfigOptions.plotGroup = oGrpELE;
        var iHeightFactor = chartConfigOptions.availHeight / (Math.abs(oNormalizedData.min) + oNormalizedData.max),
            iZeroAxis = oNormalizedData.max / oNormalizedData.sum * chartConfigOptions.availHeight,
            oLinePlotOptions = chartConfigOptions.plotOptions.line,
            oTooltips = chartConfigOptions.tooltip,
            bStaticTooltip = chartConfigOptions.legend.hover.staticTooltip && chartConfigOptions.legend.hover.enabled,
            oMarker = oLinePlotOptions.marker,
            bShowMarker = oMarker.enabled;
        //array to hold the marker elements
        oMarker.markers = [];
        //array to hold the tooltip elements
        oTooltips.tooltips = [];
        //array to hold the line elements
        oLinePlotOptions.lines = [];
        var bStepLine = oLinePlotOptions.stepLine,
            oParam = {};
        var oGrpLineChart, oGrpStaticTooltips, oGrpLineMarkers, oPathAttr, oPath, oDataArray, iXcord, iYcord, oXcord, oYcord, bPathMoveFlag, height;
        chartConfigOptions.groupObjectArray = [];
        for (iSeriesCounter = 0; iSeriesCounter < iSeriesLength; iSeriesCounter += 1) {
            oAttr = {
                class: 'MAQCharts-plotArea-lineChart-' + (iSeriesCounter + 1)
            };
            oGrpLineChart = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
            oGrpELE.appendChild(oGrpLineChart);
            oLinePlotOptions.lines.push(oGrpLineChart);
            //create static tooltip group
            oGrpStaticTooltips = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', {
                class: 'MAQCharts-plotArea-tooltips',
                id: 'MAQCharts-plotArea-tooltips-' + (iSeriesCounter + 1),
                display: 'none'
            });
            oTooltips.tooltips.push(oGrpStaticTooltips);
            //create markers group
            oAttr = {
                class: 'MAQCharts-plotArea-markers-' + (iSeriesCounter + 1)
            };
            oGrpLineMarkers = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
            oMarker.markers.push(oGrpLineMarkers);
            //add hover styles for marker with class name MAQCharts-marker-hover
            //add this class to the respective markers when hovered
            if (bShowMarker && oMarker.hover.enabled) {
                MAQ.styles.addRule('#' + chartConfigOptions.chart.renderTo + ' .' + oAttr.class + ' .MAQCharts-marker-hover', MAQ.styles.jsonToRule(oMarker.hover.style));
            }
            chartConfigOptions.groupObjectArray[iSeriesCounter] = oGrpLineChart;
            oPathAttr = {
                d: '',
                fill: 'transparent',
                'z-index': 5,
                'pointer-events': 'visibleStroke',
                stroke: oLinePlotOptions.color[iSeriesCounter],
                'stroke-width': oLinePlotOptions.lineWidth,
                'stroke-dasharray': MAQ.computeStrokeDashStyle(oLinePlotOptions.lineDashStyle)
            };
            oPath = MAQ.createSVGElement(chartConfigOptions.svgNS, 'path', oPathAttr);
            oGrpLineChart.appendChild(oPath);
            oDataArray = oSeries[iSeriesCounter];
            iLength = oDataArray.data.length;
            iXcord = 0;
            iYcord = 0;
            oXcord = [];
            oYcord = [];
            bPathMoveFlag = false;
            if (isSeriesEnabled(oSeries, iSeriesCounter)) {
                for (iCounter = 0; iCounter < iLength; iCounter += 1) {
                    height = iHeightFactor * Math.abs(oDataArray.data[iCounter]);
                    iYcord = iZeroAxis - height;
                    if (oDataArray.data[iCounter] < 0) {
                        iYcord = iYcord + 2 * height;
                    }
                    if (oDataArray.data[iCounter] !== null || oLinePlotOptions.nullValues !== 'ignore') {
                        if (bPathMoveFlag) {
                            if (bStepLine) {
                                oPathAttr.d += ' H ' + iXcord + ' V ' + iYcord;
                            } else {
                                oPathAttr.d += ' L ' + iXcord + ',' + iYcord;
                            }
                        } else {
                            oPathAttr.d = 'M ' + iXcord + ',' + iYcord;
                            bPathMoveFlag = true;
                        }
                    }
                    //draw markers
                    if (bShowMarker) {
                        oMarkerEle = MAQ.createMarker(oLinePlotOptions, {
                            x: iXcord,
                            y: iYcord,
                            fill: oLinePlotOptions.color[iSeriesCounter],
                            stroke: oLinePlotOptions.color[iSeriesCounter]
                        }, chartConfigOptions.svgNS);
                        oGrpLineMarkers.appendChild(oMarkerEle);
                        if (!(oDataArray.data[iCounter] !== null || oLinePlotOptions.nullValues !== 'ignore')) {
                            MAQ.addAttr(oMarkerEle, 'display', 'none');
                        }
                        oParam = {
                            seriesIndex: iSeriesCounter,
                            isPosavail: true,
                            position: iCounter,
                            config: chartConfigOptions
                        };
                        if (chartConfigOptions.tooltip.enabled) {
                            oParam.toolTip = chartConfigOptions.tooltipDiv;
                            MAQ.addEventListener(oMarkerEle, 'mouseover', showToolTip, oParam);
                            MAQ.addEventListener(oMarkerEle, 'mouseout', hideToolTip, oParam);
                        }
                        if (chartConfigOptions.onClick.enabled) {
                            MAQ.addEventListener(oMarkerEle, 'click', clickEventListener, oParam);
                        }
                    }
                    //draw static tooltips
                    if (bStaticTooltip) {
                        oTooltipEle = MAQ.createStaticTooltips(chartConfigOptions, iCounter, {
                            x: iXcord,
                            y: iYcord,
                            fill: oLinePlotOptions.color[iSeriesCounter],
                            stroke: oLinePlotOptions.color[iSeriesCounter]
                        }, chartConfigOptions.svgNS);
                        oGrpStaticTooltips.appendChild(oTooltipEle);
                        if (!(oDataArray.data[iCounter] !== null || oLinePlotOptions.nullValues !== 'ignore')) {
                            MAQ.addAttr(oTooltipEle, 'display', 'none');
                        }
                    }
                    oXcord[iCounter] = iXcord + chartConfigOptions.availX;
                    oYcord[iCounter] = iYcord + chartConfigOptions.availY;
                    chartConfigOptions.availXLift = chartConfigOptions.availX;
                    chartConfigOptions.availYLift = chartConfigOptions.availY;
                    iXcord += chartConfigOptions.plotIntervalWidth;
                }
            }
            oDataArray.xPos = oXcord.slice(0);
            oDataArray.yPos = oYcord.slice(0);
            MAQ.addAttr(oPath, 'd', oPathAttr.d);
            oParam = {
                seriesIndex: iSeriesCounter,
                isPosavail: false,
                config: chartConfigOptions
            };
            if (chartConfigOptions.tooltip.enabled) {
                oParam.toolTip = chartConfigOptions.tooltipDiv;
                MAQ.addEventListener(oPath, 'mousemove', showToolTip, oParam);
                MAQ.addEventListener(oPath, 'mouseout', hideToolTip, oParam);
            }
            if (chartConfigOptions.onClick.enabled) {
                MAQ.addEventListener(oPath, 'click', clickEventListener, oParam);
            }
        }
        //add the markers and static tooltips at the end so they are visible on top of overlapping lines
        for (iSeriesCounter = 0; iSeriesCounter < iSeriesLength; iSeriesCounter += 1) {
            oGrpELE.appendChild(oMarker.markers[iSeriesCounter]);
            oGrpELE.appendChild(oTooltips.tooltips[iSeriesCounter]);
        }
        if (chartConfigOptions.animation.enabled) {
            MAQ.animateClipElement(clipPathID + 'Rect', animationConfigurations.propertyToAnimate, animationConfigurations.targetValue, 1000);
        }
    }
};
/*
MAQ.createLiftChart: Renders lift chart
@param {chartConfigOptions} user configuration parameters
*/
MAQ.createLiftChart = function(chartConfigOptions) {
    'use strict';
    chartConfigOptions.isLiftChart = true;
    chartConfigOptions.chart.type = 'line';
    chartConfigOptions.availWidth = chartConfigOptions.availWidth - 10;
    var originalWidth = chartConfigOptions.availWidth;
    MAQ.createLineChart(chartConfigOptions);
    chartConfigOptions.availWidth = originalWidth - chartConfigOptions.availX - chartConfigOptions.chart.margin[1];
    chartConfigOptions.chart.type = 'lift';
    var oSVGELE = chartConfigOptions.svgELE;
    chartConfigOptions.originalSVGELE = oSVGELE;
    /* ------------------------ NAVIGATOR AREA START ------------------------- */
    var oGrpNavigatorAttr = {
            class: 'MAQCharts-TimeLineNavigator'
        },
        oGrpNavigator = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oGrpNavigatorAttr);
    chartConfigOptions.svgELE.appendChild(oGrpNavigator);
    var fNavigatorX = chartConfigOptions.availX,
        fNavigatorY = chartConfigOptions.availY,
        fNavigatorWidth = Math.floor(chartConfigOptions.availWidth),
        fNavigatorHeight = chartConfigOptions.availHeight,
        oGrpRangeSelectorAttr = {
            class: 'MAQCharts-RangeSelector',
            transform: 'translate(' + fNavigatorX + ',' + fNavigatorY + ')'
        },
        oGrpRangeSelector = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oGrpRangeSelectorAttr);
    oGrpNavigator.appendChild(oGrpRangeSelector);
    fNavigatorX = 0;
    fNavigatorY = 0;
    var oRectAttr = {
        x: 0,
        y: fNavigatorY,
        width: 150,
        height: fNavigatorHeight,
        'pointer-events': 'visibleFill',
        cursor: 'move',
        fill: chartConfigOptions.plotOptions.lift.dragWindowFill,
        opacity: chartConfigOptions.plotOptions.lift.dragWindowOpacity
    };
    var oLineLeftAttr = {
        x1: oRectAttr.x,
        y1: oRectAttr.y,
        x2: oRectAttr.x,
        y2: oRectAttr.height,
        'pointer-events': 'all',
        stroke: chartConfigOptions.plotOptions.lift.dragLineColor,
        'stroke-width': chartConfigOptions.plotOptions.lift.dragLineWidth
    };
    var oLineRightAttr = {
        x1: oRectAttr.x + oRectAttr.width,
        y1: oRectAttr.y,
        x2: oRectAttr.x + oRectAttr.width,
        y2: oRectAttr.height,
        'pointer-events': 'all',
        stroke: chartConfigOptions.plotOptions.lift.dragLineColor,
        'stroke-width': chartConfigOptions.plotOptions.lift.dragLineWidth
    };
    var oLineTopAttr = {
        x1: oRectAttr.x,
        y1: oRectAttr.height,
        x2: oRectAttr.x + oRectAttr.width,
        y2: oRectAttr.height,
        stroke: 'black',
        'stroke-width': 4,
        'stroke-dasharray': chartConfigOptions.plotOptions.lift.dragLineStyle
    };
    var oLineBottomAttr = {
        x1: oRectAttr.x,
        y1: oRectAttr.y,
        x2: oRectAttr.x + oRectAttr.width,
        y2: oRectAttr.y,
        stroke: 'black',
        'stroke-width': 4,
        'stroke-dasharray': chartConfigOptions.plotOptions.lift.dragLineStyle
    };
    var oExpandedLeftAttr = {
        r: 10,
        fill: chartConfigOptions.plotOptions.lift.dragCircleFill,
        cursor: 'e-resize'
    };
    oExpandedLeftAttr.cx = oRectAttr.x;
    oExpandedLeftAttr.cy = fNavigatorY - oExpandedLeftAttr.r;
    var oExpandedLeftBottomAttr = {
        r: 10,
        fill: chartConfigOptions.plotOptions.lift.dragCircleFill,
        cursor: 'e-resize'
    };
    oExpandedLeftBottomAttr.cx = oRectAttr.x;
    oExpandedLeftBottomAttr.cy = fNavigatorY + oRectAttr.height + oExpandedLeftBottomAttr.r;
    var oExpandedRightAttr = {
        r: 10,
        fill: chartConfigOptions.plotOptions.lift.dragCircleFill,
        cursor: 'e-resize'
    };
    oExpandedRightAttr.cx = oRectAttr.x + oRectAttr.width;
    oExpandedRightAttr.cy = fNavigatorY - oExpandedRightAttr.r;
    var oExpandedRightBottomAttr = {
        r: 10,
        fill: chartConfigOptions.plotOptions.lift.dragCircleFill,
        cursor: 'e-resize'
    };
    oExpandedRightBottomAttr.cx = oRectAttr.x + oRectAttr.width;
    oExpandedRightBottomAttr.cy = fNavigatorY + oRectAttr.height + oExpandedRightBottomAttr.r;
    var oGizmoArrow = [],
        iCounter;
    for (iCounter = 0; iCounter < 4; iCounter += 1) {
        oGizmoArrow[iCounter] = {};
        oGizmoArrow[iCounter].fill = 'white';
        oGizmoArrow[iCounter]['pointer-events'] = 'none';
        switch (iCounter) {
            case 0:
                oGizmoArrow[iCounter].d = MAQ.getTriangleCoords(oExpandedLeftAttr.cx, oExpandedLeftAttr.cy, oExpandedLeftAttr.r);
                break;
            case 1:
                oGizmoArrow[iCounter].d = MAQ.getTriangleCoords(oExpandedLeftBottomAttr.cx, oExpandedLeftBottomAttr.cy, oExpandedLeftBottomAttr.r);
                break;
            case 2:
                oGizmoArrow[iCounter].d = MAQ.getTriangleCoords(oExpandedRightAttr.cx, oExpandedRightAttr.cy, -oExpandedRightAttr.r);
                break;
            case 3:
                oGizmoArrow[iCounter].d = MAQ.getTriangleCoords(oExpandedRightBottomAttr.cx, oExpandedRightBottomAttr.cy, -oExpandedRightBottomAttr.r);
                break;
        }
    }
    var oDimmerAttr = {
        d: '',
        fill: chartConfigOptions.plotOptions.lift.dragAreaFill,
        stroke: chartConfigOptions.plotOptions.lift.dragAreaFill,
        opacity: chartConfigOptions.plotOptions.lift.dragAreaOpacity
    };
    oDimmerAttr.d = ' M ' + fNavigatorX + ',' + (fNavigatorHeight + fNavigatorY) + ' L ' + fNavigatorX + ',' + fNavigatorY + ' L ' + oRectAttr.x + ',' + oRectAttr.y + ' L ' + oRectAttr.x + ',' + (oRectAttr.y + oRectAttr.height) + ' L ' + (oRectAttr.x + oRectAttr.width) + ',' + (oRectAttr.y + oRectAttr.height) + ' L ' + (oRectAttr.x + oRectAttr.width) + ',' + oRectAttr.y + ' L ' + (fNavigatorX + fNavigatorWidth) + ',' + oRectAttr.y + ' L ' + (fNavigatorX + fNavigatorWidth) + ',' + (fNavigatorHeight + fNavigatorY) + ' Z';
    var oRect = MAQ.createSVGElement(chartConfigOptions.svgNS, 'rect', oRectAttr),
        oLeftLine = MAQ.createSVGElement(chartConfigOptions.svgNS, 'line', oLineLeftAttr),
        oRightLine = MAQ.createSVGElement(chartConfigOptions.svgNS, 'line', oLineRightAttr),
        oTopLine = MAQ.createSVGElement(chartConfigOptions.svgNS, 'line', oLineTopAttr),
        oBottomLine = MAQ.createSVGElement(chartConfigOptions.svgNS, 'line', oLineBottomAttr),
        oExpanderLeft = MAQ.createSVGElement(chartConfigOptions.svgNS, 'circle', oExpandedLeftAttr),
        oExpanderRight = MAQ.createSVGElement(chartConfigOptions.svgNS, 'circle', oExpandedRightAttr),
        oExpanderLeftBottom = MAQ.createSVGElement(chartConfigOptions.svgNS, 'circle', oExpandedLeftBottomAttr),
        oExpanderRightBottom = MAQ.createSVGElement(chartConfigOptions.svgNS, 'circle', oExpandedRightBottomAttr),
        oLeftTopTri = MAQ.createSVGElement(chartConfigOptions.svgNS, 'path', oGizmoArrow[0]),
        oLeftBottomTri = MAQ.createSVGElement(chartConfigOptions.svgNS, 'path', oGizmoArrow[1]),
        oRightTopTri = MAQ.createSVGElement(chartConfigOptions.svgNS, 'path', oGizmoArrow[2]),
        oRightBottomTri = MAQ.createSVGElement(chartConfigOptions.svgNS, 'path', oGizmoArrow[3]),
        oDimmerPath = MAQ.createSVGElement(chartConfigOptions.svgNS, 'path', oDimmerAttr);
    oGrpRangeSelector.appendChild(oDimmerPath);
    oGrpRangeSelector.appendChild(oRect);
    oGrpRangeSelector.appendChild(oLeftLine);
    oGrpRangeSelector.appendChild(oRightLine);
    oGrpRangeSelector.appendChild(oTopLine);
    oGrpRangeSelector.appendChild(oBottomLine);
    oGrpRangeSelector.appendChild(oExpanderLeft);
    oGrpRangeSelector.appendChild(oExpanderRight);
    oGrpRangeSelector.appendChild(oExpanderLeftBottom);
    oGrpRangeSelector.appendChild(oExpanderRightBottom);
    oGrpRangeSelector.appendChild(oLeftTopTri);
    oGrpRangeSelector.appendChild(oLeftBottomTri);
    oGrpRangeSelector.appendChild(oRightTopTri);
    oGrpRangeSelector.appendChild(oRightBottomTri);
    MAQ.addAttr(oExpanderLeft, 'desc', 'left');
    MAQ.addAttr(oExpanderRight, 'desc', 'right');
    MAQ.addAttr(oExpanderLeftBottom, 'desc', 'left');
    MAQ.addAttr(oExpanderRightBottom, 'desc', 'right');
    /*INTERSECTION CIRCLES START*/
    var oIntersectionPointsAttr = MAQ.getIntersectionPoints(chartConfigOptions, oRectAttr.x + oRectAttr.width),
        oIntersectionMarkersAttr = [],
        oIntersectionCircles = [],
        oCircleTextsAttr = [],
        oCircleTexts = [];
    for (iCounter = 0; iCounter < chartConfigOptions.series.length; iCounter += 1) {
        oIntersectionMarkersAttr[iCounter] = {
            r: chartConfigOptions.plotOptions.lift.intersectionMarker.radius,
            'stroke-width': chartConfigOptions.plotOptions.lift.intersectionMarker.strokeWidth,
            stroke: chartConfigOptions.plotOptions.lift.intersectionMarker.strokeColor,
            cx: oIntersectionPointsAttr.circleX[iCounter],
            cy: oIntersectionPointsAttr.circleY[iCounter],
            fill: chartConfigOptions.plotOptions.line.color[iCounter % chartConfigOptions.plotOptions.line.color.length]
        };
        oCircleTextsAttr[iCounter] = {
            x: oIntersectionPointsAttr.circleX[iCounter],
            y: oIntersectionPointsAttr.circleY[iCounter],
            dx: chartConfigOptions.plotOptions.lift.intersectionMarker.dx,
            dy: chartConfigOptions.plotOptions.lift.intersectionMarker.dy,
            text: oIntersectionPointsAttr.values[iCounter] + '%',
            style: chartConfigOptions.plotOptions.lift.intersectionMarker.fontStyle,
            'text-anchor': 'middle'
        };
        if (!isNaN(oIntersectionPointsAttr.circleX[iCounter]) && !isNaN(oIntersectionPointsAttr.circleY[iCounter])) {
            oIntersectionCircles[iCounter] = MAQ.createSVGElement(chartConfigOptions.svgNS, 'circle', oIntersectionMarkersAttr[iCounter]);
            oCircleTexts[iCounter] = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oCircleTextsAttr[iCounter]);
            oGrpRangeSelector.appendChild(oIntersectionCircles[iCounter]);
            oGrpRangeSelector.appendChild(oCircleTexts[iCounter]);
        }
    }
    /*INTERSECTION CIRCLES END*/
    var oParam = {
        x: fNavigatorX,
        y: fNavigatorY,
        width: fNavigatorWidth,
        height: fNavigatorHeight,
        navigator: oRect,
        dimmer: oDimmerPath,
        intersectionCircles: oIntersectionCircles,
        circleTexts: oCircleTexts,
        lineLeft: oLeftLine,
        lineRight: oRightLine,
        lineTop: oTopLine,
        lineBottom: oBottomLine,
        leftTopTri: oLeftTopTri,
        leftBottomTri: oLeftBottomTri,
        rightTopTri: oRightTopTri,
        rightBottomTri: oRightBottomTri,
        expanderLeft: oExpanderLeft,
        expanderRight: oExpanderRight,
        expanderLeftBottom: oExpanderLeftBottom,
        expanderRightBottom: oExpanderRightBottom,
        expanderWidth: oExpandedRightAttr.r,
        panel: oGrpRangeSelector,
        config: chartConfigOptions,
        maxX: fNavigatorX + fNavigatorWidth
    };
    //mouse down events
    MAQ.addEventListener(oRect, 'mousedown', navigatorMouseDown, oParam);
    MAQ.addEventListener(oExpanderLeft, 'mousedown', stretcherMouseDown, oParam);
    MAQ.addEventListener(oExpanderLeftBottom, 'mousedown', stretcherMouseDown, oParam);
    MAQ.addEventListener(oExpanderRight, 'mousedown', stretcherMouseDown, oParam);
    MAQ.addEventListener(oExpanderRightBottom, 'mousedown', stretcherMouseDown, oParam);
    //mouse up event
    MAQ.addEventListener(oGrpNavigator, 'mouseup', stretcherMouseUp, oParam);
    MAQ.addEventListener(oGrpNavigator, 'mouseout', stretcherMouseUp, oParam);
    MAQ.addEventListener(oGrpNavigator, 'mouseup', navigatorMouseUp, oParam);
    MAQ.addEventListener(oGrpNavigator, 'mouseout', navigatorMouseUp, oParam); /* ------------------------ NAVIGATOR AREA END ------------------------- */
};
/*
MAQ.getAnimationConfigurations: Fetch the configuration for animation
@param {chartConfigOptions} user configuration parameters
*/
function getAnimationConfigurations(chartConfigOptions) {
    'use strict';
    var animationConfig = {
        x: 0,
        y: 0,
        width: 0,
        height: chartConfigOptions.availHeight,
        propertyToAnimate: 'width',
        targetValue: chartConfigOptions.availWidth
    };
    switch (chartConfigOptions.animation.type) {
        case 1:
            animationConfig.x = 0;
            animationConfig.y = 0;
            animationConfig.width = 0;
            animationConfig.height = chartConfigOptions.availHeight;
            animationConfig.propertyToAnimate = 'width';
            animationConfig.targetValue = chartConfigOptions.availWidth;
            break;
        case 2:
            animationConfig.x = 0;
            animationConfig.y = chartConfigOptions.availHeight;
            animationConfig.width = chartConfigOptions.availWidth;
            animationConfig.height = chartConfigOptions.availHeight;
            animationConfig.propertyToAnimate = 'y';
            animationConfig.targetValue = 0;
            break;
    }
    return animationConfig;
}
/*
MAQ.createAreaChart: Renders area chart
@param {chartConfigOptions} user configuration parameters
*/
MAQ.createAreaChart = function(chartConfigOptions) {
    'use strict';
    MAQ.drawLegend(chartConfigOptions);
    MAQ.drawXAxisTitle(chartConfigOptions);
    MAQ.drawYAxisTitle(chartConfigOptions);
    MAQ.applyMargin(chartConfigOptions, chartConfigOptions.chart.margin);
    var oDataInfo = {
            min: 0,
            max: 1
        },
        oSeries = chartConfigOptions.series,
        clipPathNode = '',
        clipPathID = '';
    oSeries.label = chartConfigOptions.xAxis.labels.series;
    var iSeriesLength = oSeries.length,
        iSeriesCounter = 0,
        iCounter = 0,
        iLength = 0,
        oGrpELE,
        oNormalizedData;
    for (iSeriesCounter = 0; iSeriesCounter < iSeriesLength; iSeriesCounter += 1) {
        if (isSeriesEnabled(oSeries, iSeriesCounter)) {
            oDataInfo = MAQ.getMinMax(oSeries[iSeriesCounter].data, oDataInfo.min, oDataInfo.max);
        }
    }
    var animationConfigurations = getAnimationConfigurations(chartConfigOptions);
    if (oDataInfo.min || oDataInfo.max) {
        if ((chartConfigOptions.yAxis.minVal || 0 === chartConfigOptions.yAxis.minVal) && chartConfigOptions.yAxis.maxVal) {
            oNormalizedData = {
                min: chartConfigOptions.yAxis.minVal,
                max: chartConfigOptions.yAxis.maxVal
            };
            oNormalizedData.interval = (oNormalizedData.max - oNormalizedData.min) / chartConfigOptions.yAxis.numberOfGridLines;
        } else {
            oNormalizedData = MAQ.getNormalized_Min_Max_Interval(oDataInfo.min, oDataInfo.max, chartConfigOptions.yAxis.numberOfGridLines);
        }
        oNormalizedData.sum = oNormalizedData.max + Math.abs(oNormalizedData.min);
        chartConfigOptions.plotOptions.area.normalizedData = oNormalizedData;
        MAQ.drawAxis(chartConfigOptions);
        if (chartConfigOptions.animation.enabled) {
            clipPathNode = document.querySelectorAll('#' + chartConfigOptions.chart.renderTo + 'clippath');
            if (clipPathNode.length > 0) {
                clipPathID = chartConfigOptions.chart.renderTo + 'clippath' + clipPathNode.length;
            } else {
                clipPathID = chartConfigOptions.chart.renderTo + 'clippath';
            }
            var oClipAttr = {
                id: clipPathID
            };
            oGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'clipPath', oClipAttr);
            var oClipRectAttr = {
                id: clipPathID + 'Rect',
                x: animationConfigurations.x,
                y: animationConfigurations.y,
                width: animationConfigurations.width,
                height: animationConfigurations.height
            };
            oGrpELE.appendChild(MAQ.createSVGElement(chartConfigOptions.svgNS, 'rect', oClipRectAttr));
            chartConfigOptions.svgELE.appendChild(oGrpELE);
        }
        var oAttr = {
            class: 'MAQCharts-plotArea',
            transform: 'translate(' + chartConfigOptions.availX + ',' + chartConfigOptions.availY + ')',
            opacity: 1,
            width: 200,
            'clip-path': chartConfigOptions.animation.enabled ? 'url(#' + clipPathID + ')' : ''
        };
        oGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
        chartConfigOptions.svgELE.appendChild(oGrpELE);
        var iHeightFactor = chartConfigOptions.availHeight / (Math.abs(oNormalizedData.min) + oNormalizedData.max);
        var iZeroAxis = oNormalizedData.max / oNormalizedData.sum * chartConfigOptions.availHeight;
        var oAreaPlotOptions = chartConfigOptions.plotOptions.area;
        var oMarker = oAreaPlotOptions.marker,
            oMarkerEle;
        var bShowMarker = oMarker.enabled;
        //array to hold the marker elements
        oMarker.markers = [];
        //array to hold the area plots
        oAreaPlotOptions.areas = [];
        var bStepLine = oAreaPlotOptions.stepLine;
        var oGrpAreaChart, oGrpAreaMarkers, sColor, sPatID, oPathAttr, oPath, oDataArray, iXcord, iYcord, oXcord, oYcord, height, oParam;
        chartConfigOptions.groupObjectArray = [];
        for (iSeriesCounter = 0; iSeriesCounter < iSeriesLength; iSeriesCounter += 1) {
            oGrpAreaChart = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', {
                class: 'MAQCharts-plotArea-areaChart-' + (iSeriesCounter + 1)
            });
            oGrpELE.appendChild(oGrpAreaChart);
            oAreaPlotOptions.areas.push(oGrpAreaChart);
            //create markers group
            oAttr = {
                class: 'MAQCharts-plotArea-markers-' + (iSeriesCounter + 1)
            };
            oGrpAreaMarkers = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
            oMarker.markers.push(oGrpAreaMarkers);
            //add hover styles for marker with class name MAQCharts-marker-hover
            //add this class to the respective markers when hovered
            if (bShowMarker && oMarker.hover.enabled) {
                MAQ.styles.addRule('#' + chartConfigOptions.chart.renderTo + ' .' + oAttr.class + ' .MAQCharts-marker-hover', MAQ.styles.jsonToRule(oMarker.hover.style));
            }
            chartConfigOptions.groupObjectArray[iSeriesCounter] = oGrpAreaChart;
            sColor = oAreaPlotOptions.color[iSeriesCounter];
            if (undefined !== chartConfigOptions.plotOptions.pattern[iSeriesCounter] && '' !== chartConfigOptions.plotOptions.pattern[iSeriesCounter]) {
                sPatID = MAQ.CreatePattern(chartConfigOptions, iSeriesCounter);
                if ('COLOR' === sPatID) {
                    sColor = chartConfigOptions.plotOptions.pattern[iSeriesCounter];
                } else if ('' !== sPatID) {
                    sColor = 'url(#' + sPatID + ')';
                } else {
                    sColor = 'transparent';
                }
            }
            oPathAttr = {
                d: '',
                fill: sColor,
                'z-index': 5,
                opacity: oAreaPlotOptions.opacity,
                stroke: oAreaPlotOptions.strokes[iSeriesCounter] || oAreaPlotOptions.strokes[iSeriesCounter % oAreaPlotOptions.strokes.length] || oAreaPlotOptions.color[iSeriesCounter],
                'stroke-width': oAreaPlotOptions.lineWidth,
                'stroke-dasharray': MAQ.computeStrokeDashStyle(oAreaPlotOptions.lineDashStyle)
            };
            oPath = MAQ.createSVGElement(chartConfigOptions.svgNS, 'path', oPathAttr);
            oGrpAreaChart.appendChild(oPath);
            oDataArray = oSeries[iSeriesCounter];
            iLength = oDataArray.data.length;
            iXcord = 0;
            iYcord = 0;
            oXcord = [];
            oYcord = [];
            oPathAttr.d = 'M 0,' + iZeroAxis;
            if (isSeriesEnabled(oSeries, iSeriesCounter)) {
                for (iCounter = 0; iCounter < iLength; iCounter += 1) {
                    height = iHeightFactor * Math.abs(oDataArray.data[iCounter]);
                    iYcord = iZeroAxis - height;
                    if (oDataArray.data[iCounter] < 0) {
                        iYcord = iYcord + 2 * height;
                    }
                    if (bStepLine) {
                        oPathAttr.d += ' H ' + iXcord + ' V ' + iYcord;
                    } else {
                        oPathAttr.d += ' L ' + iXcord + ',' + iYcord;
                    }
                    if (bShowMarker) {
                        oMarkerEle = MAQ.createMarker(oAreaPlotOptions, {
                            x: iXcord,
                            y: iYcord,
                            fill: oAreaPlotOptions.color[iSeriesCounter],
                            stroke: oAreaPlotOptions.color[iSeriesCounter]
                        }, chartConfigOptions.svgNS);
                        oMarker.markers[iSeriesCounter].appendChild(oMarkerEle);
                    }
                    oXcord[iCounter] = iXcord + chartConfigOptions.availX;
                    oYcord[iCounter] = iYcord + chartConfigOptions.availY;
                    iXcord += chartConfigOptions.plotIntervalWidth;
                }
            }
            iXcord -= chartConfigOptions.plotIntervalWidth;
            oPathAttr.d += 'L ' + iXcord + ', ' + iZeroAxis;
            oDataArray.xPos = oXcord.slice(0);
            oDataArray.yPos = oYcord.slice(0);
            oParam = {
                seriesIndex: iSeriesCounter,
                isPosavail: false,
                config: chartConfigOptions
            };
            if (chartConfigOptions.tooltip.enabled) {
                oParam.toolTip = chartConfigOptions.tooltipDiv;
                MAQ.addEventListener(oGrpAreaChart, 'mousemove', showToolTip, oParam);
                MAQ.addEventListener(oGrpAreaChart, 'mouseout', hideToolTip, oParam);
            }
            // Check if the series is enabled, then only plot it
            if (isSeriesEnabled(oSeries, iSeriesCounter)) {
                MAQ.addAttr(oPath, 'd', oPathAttr.d);
            }
        }
        //append the marker group objects at the end, so they are visible on the top
        for (iSeriesCounter = 0; iSeriesCounter < iSeriesLength; iSeriesCounter += 1) {
            oGrpELE.appendChild(oMarker.markers[iSeriesCounter]);
        }
        if (chartConfigOptions.animation.enabled) {
            MAQ.animateClipElement(clipPathID + 'Rect', animationConfigurations.propertyToAnimate, animationConfigurations.targetValue, 800);
        }
    }
};


MAQ.createTimeLine = function(chartConfigOptions) {
    'use strict';
    chartConfigOptions.availHeightAfterTitledrawn = chartConfigOptions.availHeight;
    chartConfigOptions.availYAfterTitleDrawn = chartConfigOptions.availY;
    var oSVGELE = chartConfigOptions.svgELE;

    var oGrpNavigatorAttr = {
        class: 'MAQCharts-TimeLineNavigator',
        transform: 'translate(' + chartConfigOptions.availX + ',' + chartConfigOptions.height * (1 - chartConfigOptions.timeline.heightRatio) + ')'
    };
    var oGrpNavigator = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oGrpNavigatorAttr);
    chartConfigOptions.svgELE.appendChild(oGrpNavigator);

    var oGrpDrillBarAttr = {
        class: 'MAQCharts-TimeLineDrill',
        id: 'MAQCharts-TimeLineDrill-' + chartConfigOptions.chart.renderTo,
        transform: 'translate(' + 10 + ',' + 0 + ')'
    };
    var oGrpDrillBar = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oGrpDrillBarAttr);
    oGrpNavigator.appendChild(oGrpDrillBar);

    chartConfigOptions.fNavigatorHeight = chartConfigOptions.availHeight * chartConfigOptions.timeline.heightRatio - chartConfigOptions.availHeight * chartConfigOptions.timeline.heightRatio * chartConfigOptions.timeline.sliderHeightRatio;
    chartConfigOptions.sliderHeight = chartConfigOptions.availHeight * chartConfigOptions.timeline.heightRatio - chartConfigOptions.availHeight * chartConfigOptions.timeline.heightRatio * (1 - chartConfigOptions.timeline.sliderHeightRatio);
    //-30 so that the slider can reach the end of the timeline
    chartConfigOptions.fNavigatorWidth = chartConfigOptions.width - 30;
    createRangeSlider(chartConfigOptions, chartConfigOptions.timeline.series, 'MAQCharts-TimeLineDrill-' + chartConfigOptions.chart.renderTo, 'year');

    var fNavigatorX = chartConfigOptions.availX,
        fNavigatorY = chartConfigOptions.availY,
        fNavigatorWidth = Math.round(chartConfigOptions.availWidth - 30),
        fNavigatorHeight = chartConfigOptions.fNavigatorHeight;
    chartConfigOptions.availY = fNavigatorHeight;
    var oGrpRangeSelectorAttr = {
        class: 'MAQCharts-RangeSelector',
        transform: 'translate(' + 10 + ',' + 0 + ')'
    };
    var oGrpRangeSelector = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oGrpRangeSelectorAttr);
    oGrpNavigator.appendChild(oGrpRangeSelector);

    if (chartConfigOptions.timeline.dragStart < 0 || chartConfigOptions.timeline.dragStart > chartConfigOptions.timeline.series.length - 1) {
        chartConfigOptions.timeline.dragStart = 0;
    }
    if (chartConfigOptions.timeline.dragEnd < 0 || chartConfigOptions.timeline.dragEnd > chartConfigOptions.timeline.series.length) {
        chartConfigOptions.timeline.dragEnd = chartConfigOptions.timeline.series.length;
    }

    if (!chartConfigOptions.originalSeries) {
        chartConfigOptions.originalSeries = [];
        var iIterator;
        for (iIterator = 0; iIterator < chartConfigOptions.series.length; iIterator += 1) {
            chartConfigOptions.originalSeries[iIterator] = chartConfigOptions.series[iIterator];
            chartConfigOptions.originalSeries[iIterator] = {};
            chartConfigOptions.originalSeries[iIterator].drillData = [];

            if ('pie' === chartConfigOptions.chart.type || 'donut' === chartConfigOptions.chart.type || 'timeline' === chartConfigOptions.chart.type || 'true' === chartConfigOptions.isTimeLineChart) {
                chartConfigOptions.originalSeries[iIterator].data = chartConfigOptions.series[iIterator].data.slice(0);
            } else {
                chartConfigOptions.originalSeries[iIterator].data = [];
                Object.keys(chartConfigOptions.series[iIterator].data).forEach(function(key) {
                    chartConfigOptions.originalSeries[iIterator].data[key] = chartConfigOptions.series[iIterator].data[key].slice(0);
                    if (chartConfigOptions.plotOptions.column.drill) {
                        chartConfigOptions.originalSeries[iIterator].drillData[key] = {};
                        chartConfigOptions.originalSeries[iIterator].drillData[key].labels = chartConfigOptions.series[iIterator].drillData[key].labels;
                        chartConfigOptions.originalSeries[iIterator].drillData[key].data = [];
                        Object.keys(chartConfigOptions.series[iIterator].drillData[key].data).forEach(function(drillDataKey) {
                            chartConfigOptions.originalSeries[iIterator].drillData[key].data[drillDataKey] = chartConfigOptions.series[iIterator].drillData[key].data[drillDataKey].slice(0);
                        });
                    }
                });
            }
        }
    }

    var rangeEnd = 0,
        rangeStart = 0;
    chartConfigOptions.timeline.rangeStart = 0;
    if ('pie' === chartConfigOptions.chart.type.toLowerCase() || 'donut' === chartConfigOptions.chart.type.toLowerCase() || 'timeline' === chartConfigOptions.chart.type.toLowerCase() || true === chartConfigOptions.isTimeLineChart) {
        rangeEnd = chartConfigOptions.originalSeries[0].data.length - 1;
    } else {
        Object.keys(chartConfigOptions.originalSeries[0].data).forEach(function(key) {
            if (rangeEnd < chartConfigOptions.originalSeries[0].data[key].length) {
                rangeEnd = chartConfigOptions.originalSeries[0].data[key].length - 1;
            }
        });
    }

    chartConfigOptions.timeline.rangeEnd = rangeEnd;
    var fNavigatorShiftRatio = (rangeEnd - rangeStart) / fNavigatorWidth;
    chartConfigOptions.timeline.shiftRatio = fNavigatorShiftRatio;
    var dragStart = Math.ceil(fNavigatorWidth * chartConfigOptions.timeline.dragStart / chartConfigOptions.timeline.series.length);
    var dragEnd = Math.ceil(fNavigatorWidth * chartConfigOptions.timeline.dragEnd / chartConfigOptions.timeline.series.length);
    if (dragStart + chartConfigOptions.timeline.dragWidth > fNavigatorWidth) {
        chartConfigOptions.timeline.dragWidth = fNavigatorWidth - dragStart;
    }
    fNavigatorX = 0;
    fNavigatorY = 0;
    var oRectAttr = {
        id: 'MAQCharts-NavWindow-' + chartConfigOptions.chart.renderTo,
        x: dragStart,
        y: fNavigatorY,
        width: dragEnd - dragStart,
        height: fNavigatorHeight,
        'pointer-events': 'visibleFill',
        cursor: 'move',
        fill: 'transparent'
    };

    if ('CHART' !== chartConfigOptions.timeline.rangeDisplay.toUpperCase()) {
        oRectAttr['pointer-events'] = 'none';
    }

    var isRectangle = 'RECTANGLE' === chartConfigOptions.timeline.gizmo.shape.toUpperCase();
    var oExpandedLeftAttr = {
        id: 'MAQCharts-ExpanderLeft-' + chartConfigOptions.chart.renderTo,
        height: fNavigatorHeight / 2,
        width: isRectangle ? 10 : 20,
        fill: chartConfigOptions.timeline.gizmo.fill,
        cursor: 'e-resize',
        opacity: isRectangle ? 1 : 0
    };
    oExpandedLeftAttr.x = (oRectAttr.x - oExpandedLeftAttr.width) + oExpandedLeftAttr.width / 2;
    oExpandedLeftAttr.y = (fNavigatorY + oRectAttr.height / 2 - oExpandedLeftAttr.height / 2);
    var oExpandedRightAttr = {
        id: 'MAQCharts-ExpanderRight-' + chartConfigOptions.chart.renderTo,
        height: fNavigatorHeight / 2,
        width: oExpandedLeftAttr.width,
        fill: oExpandedLeftAttr.fill,
        cursor: 'e-resize',
        opacity: oExpandedLeftAttr.opacity
    };
    oExpandedRightAttr.x = (oRectAttr.x + oRectAttr.width) - oExpandedRightAttr.width / 2;
    oExpandedRightAttr.y = fNavigatorY + oRectAttr.height / 2 - oExpandedRightAttr.height / 2;

    var oClipLeftAttr = {
        id: 'MAQCharts-ClipLeft-' + chartConfigOptions.chart.renderTo,
        height: Math.min(20, fNavigatorHeight),
        width: 15,
        stroke: chartConfigOptions.timeline.gizmo.stroke,
        'stroke-width': 1,
        fill: chartConfigOptions.timeline.gizmo.fill,
        'pointer-events': 'none',
        opacity: isRectangle ? 0 : 1
    };
    oClipLeftAttr.d = MAQ.getTriangleCoords(oRectAttr.x, fNavigatorY + oRectAttr.height / 2, -oClipLeftAttr.height);
    var oClipRightAttr = {
        id: 'MAQCharts-ClipRight-' + chartConfigOptions.chart.renderTo,
        height: Math.min(20, fNavigatorHeight),
        width: 15,
        stroke: chartConfigOptions.timeline.gizmo.stroke,
        'stroke-width': 1,
        fill: chartConfigOptions.timeline.gizmo.fill,
        'pointer-events': 'none',
        opacity: isRectangle ? 0 : 1
    };
    oClipRightAttr.d = MAQ.getTriangleCoords(oRectAttr.x + oRectAttr.width, fNavigatorY + oRectAttr.height / 2, oClipRightAttr.height);
    var oDimmerAttr = {
        id: 'MAQCharts-Dimmer-' + chartConfigOptions.chart.renderTo,
        d: '',
        fill: chartConfigOptions.timeline.dimmer.fill,
        stroke: chartConfigOptions.timeline.dimmer.stroke,
        opacity: chartConfigOptions.timeline.dimmer.opacity
    };
    oDimmerAttr.d = ' M ' + fNavigatorX + ',' + (fNavigatorHeight + fNavigatorY) + ' L ' + fNavigatorX + ',' + fNavigatorY + ' L ' + oRectAttr.x + ',' + oRectAttr.y + ' L ' + oRectAttr.x + ',' + (oRectAttr.y + oRectAttr.height) + ' L ' + (oRectAttr.x + oRectAttr.width) + ',' + (oRectAttr.y + oRectAttr.height) + ' L ' + (oRectAttr.x + oRectAttr.width) + ',' + oRectAttr.y + ' L ' + (fNavigatorX + fNavigatorWidth) + ',' + oRectAttr.y + ' L ' + (fNavigatorX + fNavigatorWidth) + ',' + (fNavigatorHeight + fNavigatorY) + ' Z';

    var timelineBorderAttr = {
        id: 'MAQCharts-timelineBorder-' + chartConfigOptions.chart.renderTo,
        d: '',
        stroke: 'black',
        fill: 'none'
    };
    timelineBorderAttr.d = ' M ' + fNavigatorX + ',' + fNavigatorY + ' L ' + oRectAttr.x + ',' + oRectAttr.y + ' L ' + oRectAttr.x + ',' + (oRectAttr.y + oRectAttr.height) + ' L ' + (oRectAttr.x + oRectAttr.width) + ',' + (oRectAttr.y + oRectAttr.height) + ' L ' + (oRectAttr.x + oRectAttr.width) + ',' + oRectAttr.y + ' L ' + (fNavigatorX + fNavigatorWidth) + ',' + oRectAttr.y;

    var timelineBorder = MAQ.createSVGElement(chartConfigOptions.svgNS, 'path', timelineBorderAttr),
        oRect = MAQ.createSVGElement(chartConfigOptions.svgNS, 'rect', oRectAttr),
        oExpanderLeft = MAQ.createSVGElement(chartConfigOptions.svgNS, 'rect', oExpandedLeftAttr),
        oExpanderRight = MAQ.createSVGElement(chartConfigOptions.svgNS, 'rect', oExpandedRightAttr),
        oClipLeft = MAQ.createSVGElement(chartConfigOptions.svgNS, 'path', oClipLeftAttr),
        oClipRight = MAQ.createSVGElement(chartConfigOptions.svgNS, 'path', oClipRightAttr),
        oDimmerPath = MAQ.createSVGElement(chartConfigOptions.svgNS, 'path', oDimmerAttr);

    oGrpRangeSelector.appendChild(timelineBorder);
    oGrpRangeSelector.appendChild(oDimmerPath);
    oGrpRangeSelector.appendChild(oRect);
    oGrpRangeSelector.appendChild(oExpanderLeft);
    oGrpRangeSelector.appendChild(oExpanderRight);
    oGrpRangeSelector.appendChild(oClipLeft);
    oGrpRangeSelector.appendChild(oClipRight);
    MAQ.addAttr(oExpanderLeft, 'desc', 'left');
    MAQ.addAttr(oExpanderRight, 'desc', 'right');

    var oGrpSliderAttr = {
        class: 'MAQCharts-Slider',
        transform: 'translate(' + 10 + ',' + (chartConfigOptions.availY) + ')'
    };
    var oSliderAttr = {
        id: 'MAQCharts-SliderWindow-' + chartConfigOptions.chart.renderTo,
        x: 0,
        y: 0,
        width: chartConfigOptions.width - 30,
        height: chartConfigOptions.sliderHeight,
        'pointer-events': 'visibleFill',
        cursor: 'move',
        fill: chartConfigOptions.timeline.sliderContainer.fill,
        stroke: chartConfigOptions.timeline.sliderContainer.stroke
    };
    var oInlineSliderRectAttr = {
        id: 'MAQCharts-InlineSlider-' + chartConfigOptions.chart.renderTo,
        x: dragStart,
        y: 0,
        width: dragEnd - dragStart,
        height: chartConfigOptions.sliderHeight,
        'pointer-events': 'visibleFill',
        cursor: 'move',
        fill: chartConfigOptions.timeline.slider.fill,
        stroke: chartConfigOptions.timeline.slider.stroke
    };

    var oGrpSlider = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oGrpSliderAttr),
        oSlider = MAQ.createSVGElement(chartConfigOptions.svgNS, 'rect', oSliderAttr),
        oInlineSliderRect = MAQ.createSVGElement(chartConfigOptions.svgNS, 'rect', oInlineSliderRectAttr);

    oGrpNavigator.appendChild(oGrpSlider);
    oGrpSlider.appendChild(oSlider);
    oGrpSlider.appendChild(oInlineSliderRect);
    MAQ.addAttr(oInlineSliderRect, 'desc', 'slider');

    var oParam = {
        x: fNavigatorX,
        y: fNavigatorY,
        width: fNavigatorWidth,
        height: fNavigatorHeight,
        navigator: oRect,
        dimmer: oDimmerPath,
        expanderLeft: oExpanderLeft,
        expanderRight: oExpanderRight,
        clipLeft: oClipLeft,
        clipRight: oClipRight,
        inlineSliderRect: oInlineSliderRect,
        expanderWidth: oExpandedRightAttr.width,
        panel: oGrpRangeSelector,
        slider: oSlider,
        rangeSlider: oGrpSlider,
        config: chartConfigOptions,
        maxX: fNavigatorX + fNavigatorWidth,
        timelineBorder: timelineBorder
    };

    chartConfigOptions.svgELE = oSVGELE;

    MAQ.addEventListener(oRect, 'mousedown', navigatorMouseDown, oParam);
    MAQ.addEventListener(oExpanderLeft, 'mousedown', stretcherMouseDown, oParam);
    MAQ.addEventListener(oExpanderRight, 'mousedown', stretcherMouseDown, oParam);
    MAQ.addEventListener(oGrpNavigator, 'mouseup', stretcherMouseUp, oParam);
    MAQ.addEventListener(oGrpNavigator, 'mouseup', navigatorMouseUp, oParam);
    MAQ.addEventListener(oGrpSlider, 'mousedown', stretcherMouseDown, oParam);
    MAQ.addEventListener(oGrpSlider, 'mouseup', stretcherMouseUp, oParam);

    chartConfigOptions.originalSVGELE = oSVGELE;
    chartConfigOptions.availHeight = chartConfigOptions.availHeight * (1 - chartConfigOptions.timeline.heightRatio) - chartConfigOptions.timeline.timelinePadding;
    chartConfigOptions.timeline.originalSeries = chartConfigOptions.timeline.series.slice(0);
    if (chartConfigOptions.timeline.reset) {
        chartConfigOptions.timeline.resetTimeline = function() {
            resetTimeline(chartConfigOptions);
        };
        chartConfigOptions.timeline.reset(chartConfigOptions.timeline.resetTimeline);
    }

    MAQ.updateTimeLineDisplayArea(chartConfigOptions, rangeStart + fNavigatorShiftRatio * oRectAttr.x, rangeStart + fNavigatorShiftRatio * (oRectAttr.x + oRectAttr.width));
};


MAQ.updateTimeLineDisplayArea = function(chartConfigOptions, iStartIndex, iEndIndex) {
    'use strict';
    if (chartConfigOptions.isTimeLineChart) {
        chartConfigOptions.chart.type = 'timeline';
        chartConfigOptions.xAxis.labels.series = [];
    }
    //if the start and end id are same then simply return
    if (iStartIndex === chartConfigOptions.timeline.startId && iEndIndex === chartConfigOptions.timeline.endId) {
        return;
    }

    chartConfigOptions.timeline.startId = iStartIndex;
    chartConfigOptions.timeline.endId = iEndIndex;
    var iIterator, eachData, sumData, originalDataArray;
    for (iIterator = 0; iIterator < chartConfigOptions.series.length; iIterator += 1) {
        if ('timeline' === chartConfigOptions.chart.type.toLowerCase() || true === chartConfigOptions.isTimeLineChart) {
            chartConfigOptions.series[iIterator].data = chartConfigOptions.originalSeries[iIterator].data.slice(Math.round(iStartIndex), Math.round(iEndIndex) + 1);
        } else {
            if ('pie' === chartConfigOptions.chart.type.toLowerCase() || 'donut' === chartConfigOptions.chart.type.toLowerCase()) {
                sumData = 0;
                originalDataArray = chartConfigOptions.originalSeries[iIterator].data.slice(Math.round(iStartIndex), Math.round(iEndIndex) + 1);
                for (eachData = 0; eachData < originalDataArray.length; eachData += 1) {
                    sumData = sumData + originalDataArray[eachData];
                }
                chartConfigOptions.series[iIterator].data = sumData;
            } else {
                Object.keys(chartConfigOptions.originalSeries[iIterator].data).forEach(function(key) {
                    sumData = 0;
                    originalDataArray = chartConfigOptions.originalSeries[iIterator].data[key].slice(Math.round(iStartIndex), Math.round(iEndIndex) + 1);
                    for (eachData = 0; eachData < originalDataArray.length; eachData += 1) {
                        sumData = sumData + originalDataArray[eachData];
                    }
                    chartConfigOptions.series[iIterator].data[key] = sumData;

                    if (chartConfigOptions.plotOptions.column.drill) {
                        Object.keys(chartConfigOptions.series[iIterator].drillData[key].data).forEach(function(drillDataKey) {
                            sumData = 0;
                            originalDataArray = chartConfigOptions.originalSeries[iIterator].drillData[key].data[drillDataKey].slice(Math.round(iStartIndex), Math.round(iEndIndex) + 1);
                            for (eachData = 0; eachData < originalDataArray.length; eachData += 1) {
                                sumData = sumData + originalDataArray[eachData];
                            }
                            chartConfigOptions.series[iIterator].drillData[key].data[drillDataKey] = sumData;
                        });
                    }
                });
            }
        }
    }

    chartConfigOptions.timeline.series = chartConfigOptions.timeline.originalSeries.slice(0);
    chartConfigOptions.timeline.series = chartConfigOptions.timeline.series.slice(Math.round(iStartIndex), Math.round(iEndIndex) + 1);

    /* ------------------------ DISPLAY AREA START ------------------------- */
    var oGrpDisplayArea = chartConfigOptions.timeline.displayArea;
    if (oGrpDisplayArea) {
        MAQ.removeAllChildren(oGrpDisplayArea);
    } else {
        var oGrpDisplayChartAttr = {
            class: 'MAQCharts-TimeLineDisplayArea'
        };
        oGrpDisplayArea = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oGrpDisplayChartAttr);
        chartConfigOptions.svgELE.appendChild(oGrpDisplayArea);
        chartConfigOptions.timeline.displayArea = oGrpDisplayArea;
    }

    chartConfigOptions.tooltip.enabled = true;
    chartConfigOptions.availY = chartConfigOptions.availYAfterTitleDrawn;
    chartConfigOptions.svgELE = oGrpDisplayArea;

    switch (chartConfigOptions.chart.type.toLowerCase()) {
        case 'line':
            MAQ.createLineChart(chartConfigOptions);
            break;
        case 'area':
            MAQ.createAreaChart(chartConfigOptions);
            break;
        case 'column':
            MAQ.createColumnChart(chartConfigOptions);
            break;
        case 'bar':
            MAQ.createBarChart(chartConfigOptions);
            break;
        case 'pie':
            MAQ.createPieChart(chartConfigOptions);
            break;
        case 'donut':
            MAQ.createPieChart(chartConfigOptions);
            break;
        case 'funnel':
            MAQ.createFunnelChart(chartConfigOptions);
            break;
        case 'horizontalfunnel':
            MAQ.createHorizontalFunnelChart(chartConfigOptions);
            break;
        case 'stock':
            MAQ.createStockChart(chartConfigOptions);
            break;
        case 'bowtie':
            chartConfigOptions.plotOptions.bowtie.branch.left.currentLevel = 0;
            chartConfigOptions.plotOptions.bowtie.branch.right.currentLevel = 0;
            chartConfigOptions.plotOptions.bowtie.branch.currentLevel = 0;
            MAQ.createBowTieChart(chartConfigOptions);
            break;
        case 'bubble':
            MAQ.createBubbleChart(chartConfigOptions);
            break;
        case 'spiderweb':
            MAQ.createSpiderWebChart(chartConfigOptions);
            break;
        case 'timeline':
            MAQ.createTimelineChart(chartConfigOptions);
            break;
        case 'combolinecolumn':
            MAQ.createComboLineColumnChart(chartConfigOptions);
            break;
        case 'halfbowtie':
            this.chartOptions.plotOptions.halfbowtie.branch.currentLevel = 0;
            MAQ.createHalfBowTieChart(chartConfigOptions);
            break;
        case 'lift':
            MAQ.createLiftChart(chartConfigOptions);
            break;
        case 'gauge':
            MAQ.createGaugeChart(chartConfigOptions);
            break;
    }
    /* ------------------------ DISPLAY AREA END ------------------------- */
    chartConfigOptions.availHeight = chartConfigOptions.availHeightAfterTitledrawn;
    restoreOriginalValues(chartConfigOptions);

    /*invoke the callback function*/
    if (typeof chartConfigOptions.timeline.onChange === 'function') {
        chartConfigOptions.timeline.onChange(chartConfigOptions, Math.round(iStartIndex), Math.round(iEndIndex));
    } else if (typeof chartConfigOptions.events.onTimelineUpdate === 'function') {
        chartConfigOptions.events.onTimelineUpdate(chartConfigOptions, Math.round(iStartIndex), Math.round(iEndIndex));
    }
};

/*
MAQ.createColumnChart: Renders column chart
@param {chartConfigOptions} user configuration parameters
*/
MAQ.createColumnChart = function(chartConfigOptions) {
    'use strict';
    MAQ.drawLegend(chartConfigOptions);
    MAQ.drawXAxisTitle(chartConfigOptions);
    MAQ.drawYAxisTitle(chartConfigOptions);
    MAQ.applyMargin(chartConfigOptions, chartConfigOptions.chart.margin);
    var oDataInfo = {
            min: 0,
            max: 1
        },
        oColumnPlotOptions = chartConfigOptions.plotOptions.column,
        oSeries = chartConfigOptions.series;
    oSeries.label = chartConfigOptions.xAxis.labels.series;
    var iSeriesCounter = 0;
    var iSeriesLength = oSeries.length;
    var iCounter = 0;
    var iLength = oSeries[0].data.length;
    var oGrpELE, oNYCord, oYCord;
    if (false === oColumnPlotOptions.stacked) {
        for (iSeriesCounter = 0; iSeriesCounter < iSeriesLength; iSeriesCounter += 1) {
            if (isSeriesEnabled(oSeries, iSeriesCounter)) {
                oDataInfo = MAQ.getMinMax(oSeries[iSeriesCounter].data, oDataInfo.min, oDataInfo.max);
            }
        }
    } else {
        var oMin = oSeries[0].data.map(function(x) {
            return x - x;
        });
        var oMax = oMin.slice(0);
        oYCord = oMin.slice(0);
        oNYCord = oMin.slice(0);
        var bSeriesEnable = false,
            i, j, iCount;
        for (i = 0; i < iLength; i += 1) {
            for (j = 0; j < iSeriesLength; j += 1) {
                if (isSeriesEnabled(oSeries, j)) {
                    if (oSeries[j].data[i] < 0) {
                        oMin[i] += oSeries[j].data[i];
                    }
                    if (oSeries[j].data[i] >= 0) {
                        oMax[i] += oSeries[j].data[i];
                    }
                    bSeriesEnable = true;
                }
            }
        }
        if (bSeriesEnable) {
            var oConcatArr = oMax.concat(oMin);
            oDataInfo.min = Math.min.apply(null, oConcatArr);
            oDataInfo.max = Math.max.apply(null, oConcatArr);
            oDataInfo.total = 0;
            for (iCount = 0; iCount < oConcatArr.length; iCount += 1) {
                oDataInfo.total += oConcatArr[iCount];
            }
        }
    }
    var animationConfigurations = getAnimationConfigurations(chartConfigOptions);
    if (chartConfigOptions.animation.enabled) {
        var oClipAttr = {
            id: chartConfigOptions.chart.renderTo + 'clippath'
        };
        oGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'clipPath', oClipAttr);
        var oClipRectAttr = {
            id: chartConfigOptions.chart.renderTo + 'clippathRect',
            x: animationConfigurations.x,
            y: animationConfigurations.y,
            width: animationConfigurations.width,
            height: animationConfigurations.height
        };
        oGrpELE.appendChild(MAQ.createSVGElement(chartConfigOptions.svgNS, 'rect', oClipRectAttr));
        chartConfigOptions.svgELE.appendChild(oGrpELE);
    }
    var oNormalizedData;
    if (oDataInfo.min || oDataInfo.max) {
        if ((chartConfigOptions.yAxis.minVal || 0 === chartConfigOptions.yAxis.minVal) && chartConfigOptions.yAxis.maxVal) {
            oNormalizedData = {
                min: chartConfigOptions.yAxis.minVal,
                max: chartConfigOptions.yAxis.maxVal
            };
            oNormalizedData.interval = (oNormalizedData.max - oNormalizedData.min) / chartConfigOptions.yAxis.numberOfGridLines;
        } else {
            oNormalizedData = MAQ.getNormalized_Min_Max_Interval(oDataInfo.min, oDataInfo.max, chartConfigOptions.yAxis.numberOfGridLines);
        }
        oNormalizedData.sum = oNormalizedData.max + Math.abs(oNormalizedData.min);
        chartConfigOptions.plotOptions.column.normalizedData = oNormalizedData;
        // new fixedwidth
        chartConfigOptions.fixedWidth = chartConfigOptions.plotOptions.column.fixedWidth || false;
        MAQ.drawAxis(chartConfigOptions);
        var oAttr = {
            class: 'MAQCharts-plotArea',
            transform: 'translate(' + chartConfigOptions.availX + ',' + chartConfigOptions.availY + ')',
            opacity: 1,
            'clip-path': 'url(#' + chartConfigOptions.chart.renderTo + 'clippath)'
        };
        oGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
        chartConfigOptions.svgELE.appendChild(oGrpELE);
        var iHeightFactor = chartConfigOptions.availHeight / (Math.abs(oNormalizedData.min) + oNormalizedData.max);
        var iZeroAxis = oNormalizedData.max / oNormalizedData.sum * chartConfigOptions.availHeight;
        var oBarWidth = chartConfigOptions.plotIntervalWidth - oColumnPlotOptions.padding;
        var fGrpPadding = oColumnPlotOptions.groupPadding;
        if (fGrpPadding < 0) {
            fGrpPadding = 0;
        }
        if (fGrpPadding > 100) {
            fGrpPadding = 100;
        }
        fGrpPadding = fGrpPadding / 100 * oBarWidth;
        if (!oColumnPlotOptions.stacked) {
            oBarWidth = oBarWidth - fGrpPadding * (iSeriesLength - 1);
        }
        MAQ.addAttr(chartConfigOptions.xLabels, 'transform', 'translate(' + (oBarWidth / 2 + fGrpPadding) + ', 0)');
        if (!oColumnPlotOptions.stacked) {
            //new fixedwidth
            oBarWidth = oColumnPlotOptions.fixedWidth || oBarWidth / iSeriesLength;
        }
        var oRectAttr = {
            x: 0,
            y: 0,
            rx: oColumnPlotOptions.borderRadius,
            ry: oColumnPlotOptions.borderRadius,
            width: oBarWidth,
            height: 0,
            fill: '',
            'z-index': 5,
            opacity: oColumnPlotOptions.opacity,
            stroke: oColumnPlotOptions.borderColor,
            'stroke-width': oColumnPlotOptions.borderWidth,
            'stroke-dasharray': MAQ.computeStrokeDashStyle(oColumnPlotOptions.borderDashStyle)
        };
        var oValueBoxAttr = {
            x: 0,
            y: 0,
            text: null,
            'text-anchor': 'middle',
            style: oColumnPlotOptions.valueBox.style
        };
        /*UNTESTED*/
        var oBgRectAttr = {
                x: 0,
                y: 0,
                rx: oColumnPlotOptions.borderRadius,
                ry: oColumnPlotOptions.borderRadius,
                width: chartConfigOptions.plotIntervalWidth - oColumnPlotOptions.padding + 1,
                height: chartConfigOptions.availHeight,
                fill: oColumnPlotOptions.background.color,
                'z-index': 5,
                opacity: oColumnPlotOptions.opacity
            },
            oGrpColumnChart,
            oDataArray,
            iXcord,
            iYcord,
            oRectangle,
            isDrillBar,
            height,
            sColor,
            oRect,
            oLineAttr,
            oDrillLine,
            oToolTip,
            oParam,
            oValueBox,
            sPatID;
        oColumnPlotOptions.columns = [];
        for (iSeriesCounter = 0; iSeriesCounter < iSeriesLength; iSeriesCounter += 1) {
            if (isSeriesEnabled(oSeries, iSeriesCounter)) {
                oAttr = {
                    class: 'MAQCharts-plotArea-columnChart-' + (iSeriesCounter + 1)
                };
                oGrpColumnChart = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
                oGrpELE.appendChild(oGrpColumnChart);
                oColumnPlotOptions.columns.push(oGrpColumnChart);
                oRectAttr.fill = oColumnPlotOptions.color[iSeriesCounter];
                oDataArray = oSeries[iSeriesCounter];
                iLength = oDataArray.data.length;
                iXcord = 0;
                iYcord = 0;
                for (iCounter = 0; iCounter < iLength; iCounter += 1) {
                    isDrillBar = false;
                    if (1 === chartConfigOptions.drillActive && iCounter > chartConfigOptions.drillIndex && iCounter <= chartConfigOptions.drillIndex + chartConfigOptions.drillDataLength) {
                        isDrillBar = true;
                    }
                    //add background rect svg
                    /*UNTESTED*/
                    if (oColumnPlotOptions.background.enabled && iSeriesLength - 1 === iSeriesCounter) {
                        oBgRectAttr.x = iXcord;
                        oRectangle = MAQ.createSVGElement(chartConfigOptions.svgNS, 'rect', oBgRectAttr);
                        oGrpColumnChart.appendChild(oRectangle);
                    }
                    /*UNTESTED*/
                    //new drill fixedwidth
                    if (isDrillBar) {
                        oRectAttr.width = oColumnPlotOptions.drillFixedWidth || oBarWidth;
                        oRectAttr.cursor = '';
                    } else {
                        oRectAttr.width = oBarWidth;
                        if (true === chartConfigOptions.plotOptions.column.drill) {
                            oRectAttr.cursor = 'pointer';
                        }
                    }
                    if (oColumnPlotOptions.similarColor === true) {
                        oRectAttr.fill = oColumnPlotOptions.color[iCounter];
                    }
                    height = iHeightFactor * Math.abs(oDataArray.data[iCounter]);
                    iYcord = iZeroAxis - height;
                    if (oDataArray.data[iCounter] < 0) {
                        iYcord = iZeroAxis;
                    }
                    if (!oColumnPlotOptions.stacked) {
                        oRectAttr.x = iXcord + (oBarWidth + fGrpPadding) * iSeriesCounter;
                        oRectAttr.y = iYcord;
                    } else {
                        oRectAttr.x = iXcord;
                        if (oDataArray.data[iCounter] < 0) {
                            oRectAttr.y = iYcord + oNYCord[iCounter];
                            oNYCord[iCounter] += height;
                        } else {
                            oRectAttr.y = iYcord - oYCord[iCounter];
                            oYCord[iCounter] += height;
                        }
                    }
                    oRectAttr.height = height;
                    sColor = oColumnPlotOptions.color[iCounter];
                    if (undefined !== chartConfigOptions.plotOptions.pattern[iSeriesCounter] && '' !== chartConfigOptions.plotOptions.pattern[iSeriesCounter]) {
                        sPatID = MAQ.CreatePattern(chartConfigOptions, iSeriesCounter);
                        if ('' !== sPatID) {
                            sColor = 'url(#' + sPatID + ')';
                        } else {
                            sColor = 'transparent';
                        }
                    }
                    if (iSeriesLength === 1 && oColumnPlotOptions.multiColored === true) {
                        oRectAttr.fill = sColor;
                    }
                    oRect = MAQ.createSVGElement(chartConfigOptions.svgNS, 'rect', oRectAttr);
                    oGrpColumnChart.appendChild(oRect);
                    if (1 === chartConfigOptions.drillActive && (iCounter === chartConfigOptions.drillIndex + 1 || iCounter === chartConfigOptions.drillIndex + chartConfigOptions.drillDataLength + 1)) {
                        oLineAttr = {
                            x1: oRectAttr.x - oColumnPlotOptions.padding / 2,
                            y1: oRectAttr.y + oRectAttr.height,
                            x2: oRectAttr.x - oColumnPlotOptions.padding / 2,
                            y2: oRectAttr.y + oRectAttr.height - chartConfigOptions.availHeight,
                            stroke: chartConfigOptions.plotOptions.column.drillSeparatorColor,
                            'stroke-dasharray': chartConfigOptions.plotOptions.column.drillSeparatorStyle,
                            'stroke-width': chartConfigOptions.plotOptions.column.drillSeparatorWidth
                        };
                        oDrillLine = MAQ.createSVGElement(chartConfigOptions.svgNS, 'line', oLineAttr);
                        oGrpColumnChart.appendChild(oDrillLine);
                    }
                    if (oColumnPlotOptions.valueBox.enabled) {
                        oValueBoxAttr.x = oRectAttr.x + oRectAttr.width / 2;
                        if (oColumnPlotOptions.valueBox.position === 'middle') {
                            oValueBoxAttr.y = oRectAttr.y + oRectAttr.height / 2;
                        } else {
                            if (oRectAttr.y < 15) {
                                oValueBoxAttr.y = 15;
                            } else if (oDataArray.data[iCounter] < 0) {
                                if (chartConfigOptions.availHeight - (oRectAttr.y + oRectAttr.height) < 15) {
                                    oValueBoxAttr.y = oRectAttr.y + oRectAttr.height - 5;
                                } else {
                                    oValueBoxAttr.y = oRectAttr.y + oRectAttr.height + 15;
                                }
                            } else {
                                oValueBoxAttr.y = oRectAttr.y - 5;
                            }
                        }
                        oValueBoxAttr.y = oRectAttr.y - oColumnPlotOptions.valueBox.marginBottom;
                        oValueBoxAttr.text = Math.round(oDataArray.data[iCounter] * 10) / 10;
                        oValueBox = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oValueBoxAttr);
                        oGrpColumnChart.appendChild(oValueBox);
                    }
                    oParam = {
                        seriesIndex: iSeriesCounter,
                        isPosavail: true,
                        position: iCounter,
                        config: chartConfigOptions
                    };
                    if (chartConfigOptions.tooltip.enabled) {
                        oToolTip = chartConfigOptions.tooltipDiv;
                        MAQ.addEventListener(oRect, 'mousemove', showToolTip, oParam);
                        MAQ.addEventListener(oRect, 'mouseout', hideToolTip, oToolTip);
                    }
                    if (chartConfigOptions.onClick.enabled) {
                        if (undefined === chartConfigOptions.drillActive || 0 === chartConfigOptions.drillActive || 1 === chartConfigOptions.drillActive && (iCounter <= chartConfigOptions.drillIndex || iCounter > chartConfigOptions.drillIndex + chartConfigOptions.drillDataLength)) {
                            MAQ.addEventListener(oRect, 'click', 'clickEventListener', oParam);
                        }
                    }
                    if (isDrillBar) {
                        iXcord += oColumnPlotOptions.drillFixedWidth && oColumnPlotOptions.drillFixedWidth + oColumnPlotOptions.padding - oColumnPlotOptions.groupPadding || chartConfigOptions.plotIntervalWidth;
                    } else {
                        iXcord += oColumnPlotOptions.fixedWidth && oColumnPlotOptions.fixedWidth + oColumnPlotOptions.padding - oColumnPlotOptions.groupPadding || chartConfigOptions.plotIntervalWidth;
                    }
                }
                //add hover styles
                if (oColumnPlotOptions.hover.enabled) {
                    MAQ.styles.addRule('#' + chartConfigOptions.chart.renderTo + ' .' + oAttr.class + '>rect:hover', MAQ.styles.jsonToRule(oColumnPlotOptions.hover.style));
                }
            }
        }
        if (chartConfigOptions.animation.enabled) {
            MAQ.animateClipElement(chartConfigOptions.chart.renderTo + 'clippathRect', animationConfigurations.propertyToAnimate, animationConfigurations.targetValue, 800);
        }
    } else if (!oDataInfo.min || !oDataInfo.max) {
        //unverified
        if ((chartConfigOptions.yAxis.minVal || 0 === chartConfigOptions.yAxis.minVal) && chartConfigOptions.yAxis.maxVal) {
            oNormalizedData = {
                min: chartConfigOptions.yAxis.minVal,
                max: chartConfigOptions.yAxis.maxVal
            };
            oNormalizedData.interval = (oNormalizedData.max - oNormalizedData.min) / chartConfigOptions.yAxis.numberOfGridLines;
        } else {
            oNormalizedData = MAQ.getNormalized_Min_Max_Interval(oDataInfo.min, oDataInfo.max, chartConfigOptions.yAxis.numberOfGridLines);
        }
        // The below 3 lines are to avoid NaN scenario in the above function
        oNormalizedData.min = 0;
        oNormalizedData.max = chartConfigOptions.yAxis.numberOfGridLines;
        oNormalizedData.interval = 1;
        oNormalizedData.sum = oNormalizedData.max + Math.abs(oNormalizedData.min);
        chartConfigOptions.plotOptions.column.normalizedData = oNormalizedData;
        MAQ.drawAxis(chartConfigOptions);
    }
};
/*
MAQ.createBarChart: Renders bar chart
@param {chartConfigOptions} user configuration parameters
*/
MAQ.createBarChart = function(chartConfigOptions) {
    'use strict';
    MAQ.drawLegend(chartConfigOptions);
    MAQ.drawXAxisTitle(chartConfigOptions);
    MAQ.drawYAxisTitle(chartConfigOptions);
    MAQ.applyMargin(chartConfigOptions, chartConfigOptions.chart.margin);
    var oDataInfo = {
        min: 0,
        max: 1
    };
    var oColumnPlotOptions = chartConfigOptions.plotOptions.bar;
    var oSeries = chartConfigOptions.series;
    var iSeriesCounter = 0;
    var iSeriesLength = oSeries.length;
    var iCounter = 0;
    var iLength = oSeries[0].data.length;
    var oGrpELE, oNYCord, oYCord, oMin, oMax, bSeriesEnable, i, j;
    if (oColumnPlotOptions.stacked === false) {
        for (iSeriesCounter = 0; iSeriesCounter < iSeriesLength; iSeriesCounter += 1) {
            if (isSeriesEnabled(oSeries, iSeriesCounter)) {
                oDataInfo = MAQ.getMinMax(oSeries[iSeriesCounter].data, oDataInfo.min, oDataInfo.max);
            }
        }
    } else {
        oMin = oSeries[0].data.map(function(x) {
            return x - x;
        });
        oMax = oMin.slice(0);
        oYCord = oMin.slice(0);
        oNYCord = oMin.slice(0);
        bSeriesEnable = false;
        for (i = 0; i < iLength; i += 1) {
            for (j = 0; j < iSeriesLength; j += 1) {
                if (isSeriesEnabled(oSeries, j)) {
                    if (oSeries[j].data[i] < 0) {
                        oMin[i] += oSeries[j].data[i];
                    }
                    if (oSeries[j].data[i] >= 0) {
                        oMax[i] += oSeries[j].data[i];
                    }
                    bSeriesEnable = true;
                }
            }
        }
        if (bSeriesEnable) {
            var oConcatArr = oMax.concat(oMin),
                iCount;
            oDataInfo.min = Math.min.apply(null, oConcatArr);
            oDataInfo.max = Math.max.apply(null, oConcatArr);
            oDataInfo.total = 0;
            for (iCount = 0; iCount < oConcatArr.length; iCount += 1) {
                oDataInfo.total += oConcatArr[iCount];
            }
        }
    }
    var animationConfigurations = getAnimationConfigurations(chartConfigOptions);
    var oNormalizedData;
    if (oDataInfo.min || oDataInfo.max) {
        if ((chartConfigOptions.yAxis.minVal || 0 === chartConfigOptions.yAxis.minVal) && chartConfigOptions.yAxis.maxVal) {
            oNormalizedData = {
                min: chartConfigOptions.yAxis.minVal,
                max: chartConfigOptions.yAxis.maxVal
            };
            oNormalizedData.interval = (oNormalizedData.max - oNormalizedData.min) / chartConfigOptions.yAxis.numberOfGridLines;
        } else {
            oNormalizedData = MAQ.getNormalized_Min_Max_Interval(oDataInfo.min, oDataInfo.max, chartConfigOptions.yAxis.numberOfGridLines);
        }
        oNormalizedData.sum = oNormalizedData.max + Math.abs(oNormalizedData.min);
        chartConfigOptions.plotOptions.bar.normalizedData = oNormalizedData;
        chartConfigOptions.fixedWidth = chartConfigOptions.plotOptions.column.fixedWidth || false;
        MAQ.drawAxis(chartConfigOptions);
        oSeries.label = chartConfigOptions.yAxis.labels.series;
        oSeries.label.reverse();
        chartConfigOptions.availWidth += chartConfigOptions.plotIntervalWidth;
        if (chartConfigOptions.animation.enabled) {
            var oClipAttr = {
                id: chartConfigOptions.chart.renderTo + 'clippath'
            };
            oGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'clipPath', oClipAttr);
            var oClipRectAttr = {
                id: chartConfigOptions.chart.renderTo + 'clippathRect',
                x: animationConfigurations.x,
                y: animationConfigurations.y,
                width: animationConfigurations.width,
                height: animationConfigurations.height
            };
            oGrpELE.appendChild(MAQ.createSVGElement(chartConfigOptions.svgNS, 'rect', oClipRectAttr));
            chartConfigOptions.svgELE.appendChild(oGrpELE);
        }
        var oAttr = {
            class: 'MAQCharts-plotArea',
            transform: 'translate(' + chartConfigOptions.availX + ',' + chartConfigOptions.availY + ')',
            opacity: 1,
            width: 200,
            'clip-path': chartConfigOptions.animation.enabled ? 'url(#' + chartConfigOptions.chart.renderTo + 'clippath)' : ''
        };
        oGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
        chartConfigOptions.svgELE.appendChild(oGrpELE);
        var iWidthFactor = chartConfigOptions.availWidth / (Math.abs(oNormalizedData.min) + oNormalizedData.max);
        var iZeroAxis = oNormalizedData.min / oNormalizedData.sum * chartConfigOptions.availWidth;
        iZeroAxis = Math.abs(iZeroAxis);
        var oBarWidth = chartConfigOptions.plotIntervalHeight - oColumnPlotOptions.padding;
        var fGrpPadding = oColumnPlotOptions.groupPadding;
        if (fGrpPadding < 0) {
            fGrpPadding = 0;
        }
        if (fGrpPadding > 100) {
            fGrpPadding = 100;
        }
        fGrpPadding = fGrpPadding / 100 * oBarWidth;
        if (!oColumnPlotOptions.stacked) {
            oBarWidth = oBarWidth - fGrpPadding * (iSeriesLength - 1);
        }
        MAQ.addAttr(chartConfigOptions.yLabels, 'transform', 'translate(0 , ' + (oBarWidth / 2 + fGrpPadding) + ')');
        if (!oColumnPlotOptions.stacked) {
            oBarWidth = oColumnPlotOptions.fixedWidth || oBarWidth / iSeriesLength;
        }
        var oRectAttr = {
                x: 0,
                y: 0,
                rx: oColumnPlotOptions.borderRadius,
                ry: oColumnPlotOptions.borderRadius,
                width: 0,
                height: oBarWidth,
                'z-index': 5,
                fill: '',
                opacity: oColumnPlotOptions.opacity,
                stroke: oColumnPlotOptions.borderColor,
                'stroke-width': oColumnPlotOptions.borderWidth,
                'stroke-dasharray': MAQ.computeStrokeDashStyle(oColumnPlotOptions.borderDashStyle)
            },
            oGrpColumnChart, oDataArray, iXcord, iYcord, width, sColor, oRect, getRectDimension, oValueBoxAttr, oValueBox, oParam, oToolTip, sPatID, getValueBoxDimensions;
        oColumnPlotOptions.bars = [];
        for (iSeriesCounter = 0; iSeriesCounter < iSeriesLength; iSeriesCounter += 1) {
            oAttr = {
                class: 'MAQCharts-plotArea-barChart-' + (iSeriesCounter + 1)
            };
            oGrpColumnChart = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
            oGrpELE.appendChild(oGrpColumnChart);
            oColumnPlotOptions.bars.push(oGrpColumnChart);
            oRectAttr.fill = oColumnPlotOptions.color[iSeriesCounter];
            oDataArray = oSeries[iSeriesCounter];
            iLength = oDataArray.data.length;
            iXcord = 0;
            iYcord = 0;
            for (iCounter = 0; iCounter < iLength; iCounter += 1) {
                if (isSeriesEnabled(oSeries, iSeriesCounter)) {
                    width = iWidthFactor * Math.abs(oDataArray.data[iCounter]);
                    iXcord = iZeroAxis - width;
                    if (oDataArray.data[iCounter] < 0) {
                        oRectAttr.transform = 'translate(' + -width + ', 0)';
                    } else {
                        oRectAttr.transform = '';
                    }
                    if (!oColumnPlotOptions.stacked) {
                        oRectAttr.y = iYcord + (oBarWidth + fGrpPadding) * iSeriesCounter;
                        oRectAttr.x = iXcord;
                    } else {
                        oRectAttr.y = iYcord;
                        if (oDataArray.data[iCounter] < 0) {
                            oRectAttr.x = iXcord - oNYCord[iCounter];
                            oNYCord[iCounter] += width;
                        } else {
                            oRectAttr.x = iXcord + oYCord[iCounter];
                            oYCord[iCounter] += width;
                        }
                    }
                    oRectAttr.x += width;
                    oRectAttr.x = Math.abs(oRectAttr.x);
                    oRectAttr.width = width;
                    sColor = oColumnPlotOptions.color[iCounter];
                    if (undefined !== chartConfigOptions.plotOptions.pattern[iSeriesCounter] && '' !== chartConfigOptions.plotOptions.pattern[iSeriesCounter]) {
                        sPatID = MAQ.CreatePattern(chartConfigOptions, iSeriesCounter);
                        if ('' !== sPatID) {
                            sColor = 'url(#' + sPatID + ')';
                        } else {
                            sColor = 'transparent';
                        }
                    }
                    if (iSeriesLength === 1 && oColumnPlotOptions.multiColored === true) {
                        oRectAttr.fill = sColor;
                    }
                    oRect = MAQ.createSVGElement(chartConfigOptions.svgNS, 'rect', oRectAttr);
                    oGrpColumnChart.appendChild(oRect);
                    getRectDimension = MAQ.getObjectDimension(oRect);
                    oValueBoxAttr = {
                        x: 0,
                        y: 0,
                        text: null,
                        'text-anchor': 'left',
                        style: oColumnPlotOptions.valueBox.style
                    };
                    if (oColumnPlotOptions.valueBox.enabled) {
                        oValueBoxAttr.y = oRectAttr.y + oBarWidth / 2 + parseInt(oColumnPlotOptions.valueBox.style.fontSize) / 2;
                        if (oColumnPlotOptions.valueBox.position === 'middle') {
                            oValueBoxAttr['text-anchor'] = 'middle';
                            oValueBoxAttr.x = oRectAttr.x + oRectAttr.width / 2;
                            if (oDataArray.data[iCounter] < 0) {
                                oValueBoxAttr.transform = 'translate(' + -width + ', 0)';
                            } else {
                                oValueBoxAttr.transform = '';
                            }
                        } else {
                            if (oRectAttr.width < 15) {
                                oValueBoxAttr.x = 15;
                            } else if (oDataArray.data[iCounter] > 0) {
                                if (chartConfigOptions.availWidth - oRectAttr.width < 15) {
                                    oValueBoxAttr.x = oRectAttr.x + oRectAttr.width - 5;
                                } else {
                                    oValueBoxAttr.x = oRectAttr.x + oRectAttr.width + 5;
                                }
                            } else {
                                oValueBoxAttr.x = oRectAttr.x - oRectAttr.width - 5;
                                oValueBoxAttr['text-anchor'] = 'right';
                            }
                        }
                        oValueBoxAttr.text = MAQ.applyFormatter(Math.round(oDataArray.data[iCounter] * Math.pow(10, 1)) / Math.pow(10, 1), oColumnPlotOptions.valueBox.formatter);
                        oValueBox = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oValueBoxAttr);
                        oGrpColumnChart.appendChild(oValueBox);
                        if (oColumnPlotOptions.valueBox.position === 'middle') {
                            getValueBoxDimensions = MAQ.getObjectDimension(oValueBox);
                            if (oColumnPlotOptions.stacked === false) {
                                if (getRectDimension.width < getValueBoxDimensions.width) {
                                    oGrpColumnChart.removeChild(oValueBox);
                                    if (oDataArray.data[iCounter] > 0) {
                                        oValueBoxAttr['text-anchor'] = 'left';
                                        if (chartConfigOptions.availWidth - oRectAttr.width < 15) {
                                            oValueBoxAttr.x = oRectAttr.x + oRectAttr.width - 5;
                                        } else {
                                            oValueBoxAttr.x = oRectAttr.x + oRectAttr.width + 5;
                                        }
                                    } else {
                                        oValueBoxAttr.x = oRectAttr.x - oRectAttr.width - 5;
                                        oValueBoxAttr['text-anchor'] = 'right';
                                    }
                                    oValueBox = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oValueBoxAttr);
                                    oGrpColumnChart.appendChild(oValueBox);
                                }
                            }
                        }
                    }
                    oParam = {
                        seriesIndex: iSeriesCounter,
                        isPosavail: true,
                        position: iCounter,
                        config: chartConfigOptions
                    };
                    if (chartConfigOptions.tooltip.enabled) {
                        oToolTip = chartConfigOptions.tooltipDiv;
                        MAQ.addEventListener(oRect, 'mousemove', showToolTip, oParam);
                        MAQ.addEventListener(oRect, 'mouseout', hideToolTip, oToolTip);
                    }
                    if (chartConfigOptions.onClick.enabled) {
                        MAQ.addEventListener(oRect, 'click', clickEventListener, oParam);
                    }
                    iYcord += oColumnPlotOptions.fixedWidth && oColumnPlotOptions.fixedWidth + oColumnPlotOptions.padding - oColumnPlotOptions.groupPadding || chartConfigOptions.plotIntervalHeight;
                }
            }
        }
        //add hover styles
        if (oColumnPlotOptions.hover.enabled) {
            MAQ.styles.addRule('.' + oAttr.class + '>rect:hover', MAQ.styles.jsonToRule(oColumnPlotOptions.hover.style));
        }
        MAQ.animateClipElement(chartConfigOptions.chart.renderTo + 'clippathRect', animationConfigurations.propertyToAnimate, animationConfigurations.targetValue, 800);
    } else if (!oDataInfo.min || !oDataInfo.max) {
        //unverified
        if ((chartConfigOptions.yAxis.minVal || 0 === chartConfigOptions.yAxis.minVal) && chartConfigOptions.yAxis.maxVal) {
            oNormalizedData = {
                min: chartConfigOptions.yAxis.minVal,
                max: chartConfigOptions.yAxis.maxVal
            };
            oNormalizedData.interval = (oNormalizedData.max - oNormalizedData.min) / chartConfigOptions.yAxis.numberOfGridLines;
        } else {
            oNormalizedData = MAQ.getNormalized_Min_Max_Interval(oDataInfo.min, oDataInfo.max, chartConfigOptions.yAxis.numberOfGridLines);
        }
        /* The below 3 lines are to avoid NaN scenario in the above function */
        oNormalizedData.min = 0;
        oNormalizedData.max = chartConfigOptions.yAxis.numberOfGridLines;
        oNormalizedData.interval = 1;
        oNormalizedData.sum = oNormalizedData.max + Math.abs(oNormalizedData.min);
        chartConfigOptions.plotOptions.bar.normalizedData = oNormalizedData;
        MAQ.drawAxis(chartConfigOptions);
        oSeries.label = chartConfigOptions.yAxis.labels.series;
        oSeries.label.reverse();
    }
};
/*
getAnimationConfigurationsForPie: creates the animation configutation object for pie and donut
*/
function getAnimationConfigurationsForPie(chartConfigOptions) {
    'use strict';
    var oClipCircleAttr;
    switch (chartConfigOptions.animation.type) {
        case 3:
            oClipCircleAttr = {
                id: chartConfigOptions.chart.renderTo + 'clippathRect',
                cx: 0,
                cy: 0,
                r: 0
            };
            break;
        default:
            oClipCircleAttr = {
                id: chartConfigOptions.chart.renderTo + 'clippathPath',
                d: 'M100 , 100',
                fill: 'none',
                'stroke-width': 2,
                stroke: 'blue'
            };
            break;
    }
    return oClipCircleAttr;
}
/*
MAQ.animatePieArc: creates the animation effect ony for pie and donut chart
creates the rounded moving affect
Parameters -->
sPropertyToAnimate: Contains the id of the child element of clip path
sAnimateValue: contains the radiouus of the circle
*/
MAQ.animatePieArc = function(sPropertyToAnimate, sAnimateValue, bIsClockwise, callback) {
    'use strict';
    var iCounter = 0,
        circle = document.getElementById(sPropertyToAnimate),
        iAngle = 0,
        iRadius = 10,
        iTime = 10;
    var process = setInterval(function() {
        //angle %= 360;
        var fRadians = iAngle / 180 * Math.PI,
            fXCordinate = -11 + Math.cos(fRadians) * iRadius,
            fYCordinate = 0 + Math.sin(fRadians) * iRadius,
            sPrevAttrD = circle.getAttribute('d'),
            sAttrD;
        if (0 === iCounter) {
            sAttrD = sPrevAttrD + ' M ' + fXCordinate + ' ' + fYCordinate;
        } else {
            sAttrD = sPrevAttrD + ' L ' + fXCordinate + ' ' + fYCordinate;
        }
        circle.setAttribute('d', sAttrD);
        iCounter += 1;
        if (bIsClockwise) {
            if (iCounter < 10) {
                iAngle += 0.2;
            } else {
                iAngle += 5;
            }
            //this condition clears the set interval process when the complete circle is created
            if (iAngle >= 365) {
                clearInterval(process);
                setTimeout(function() {
                    if (callback && 'function' === typeof callback) {
                        callback();
                    }
                }, iTime);
            }
        } else {
            if (iCounter < 10) {
                iAngle -= 0.2;
            } else {
                iAngle -= 5;
            }
            //this condition clears the set interval process when the complete circle is created
            if (iAngle <= -365) {
                clearInterval(process);
                setTimeout(function() {
                    if (callback && 'function' === typeof callback) {
                        callback();
                    }
                }, iTime);
            }
        }
        if (iRadius <= sAnimateValue) {
            iRadius = sAnimateValue;
        }
    }, iTime);
};
/*
MAQ.createPieChart: Renders pie chart
@param {chartConfigOptions} user configuration parameters
*/
MAQ.createPieChart = function(chartConfigOptions) {
    'use strict';
    chartConfigOptions.series = chartConfigOptions.series.filter(function(x) {
        return x.data >= 0;
    });
    var oSeries = chartConfigOptions.series,
        oDataInfo = {
            min: 0,
            max: 0
        },
        iCounter = 0,
        iLength = oSeries.length,
        iEnabledSeries = 0,
        flag = 0,
        posX = [],
        posY = [],
        oGrpELE,
        animationConfigurations,
        iTotal = 0;
    for (iCounter = 0; iCounter < iLength; iCounter += 1) {
        iTotal += oSeries[iCounter].data;
        if (0 === parseInt(oSeries[iCounter].data, 10)) {
            oSeries[iCounter].enabled = false;
        }
        if (isSeriesEnabled(oSeries, iCounter)) {
            if (0 !== oSeries[iCounter].data) {
                oDataInfo = MAQ.getMinMaxForPie(oSeries, oDataInfo.min, oDataInfo.max, 'data');
                iEnabledSeries += 1;
            }
        }
    }
    MAQ.drawLegend(chartConfigOptions);
    MAQ.applyMargin(chartConfigOptions, chartConfigOptions.chart.margin);
    if (chartConfigOptions.animation.enabled && iEnabledSeries !== 0) {
        var oClipAttr = {
            id: chartConfigOptions.chart.renderTo + 'clippath'
        };
        oGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'clipPath', oClipAttr);
        animationConfigurations = getAnimationConfigurationsForPie(chartConfigOptions);
        switch (chartConfigOptions.animation.type) {
            case 3:
                oGrpELE.appendChild(MAQ.createSVGElement(chartConfigOptions.svgNS, 'circle', animationConfigurations));
                break;
            default:
                oGrpELE.appendChild(MAQ.createSVGElement(chartConfigOptions.svgNS, 'path', animationConfigurations));
        }
        chartConfigOptions.svgELE.appendChild(oGrpELE);
    }
    var oAttr = {
        class: 'MAQCharts-plotArea',
        transform: 'translate(' + chartConfigOptions.availX + ',' + chartConfigOptions.availY + ')',
        opacity: 1,
        'clip-path': chartConfigOptions.animation.enabled ? 'url(#' + chartConfigOptions.chart.renderTo + 'clippath)' : ''
    };
    oGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    chartConfigOptions.svgELE.appendChild(oGrpELE);
    var fAvailHeight = chartConfigOptions.availHeight,
        fAvailWidth = chartConfigOptions.availWidth,
        fCenterX = fAvailWidth / 2,
        fCenterY = fAvailHeight / 2;
    var fRadius = Math.min(fAvailHeight, fAvailWidth) / 2;
    fRadius = chartConfigOptions.plotOptions.donut.outerRadius && parseInt(chartConfigOptions.plotOptions.donut.outerRadius) || fRadius * 0.7;
    MAQ.addAttr(oGrpELE, 'transform', 'translate(' + (chartConfigOptions.availX + fCenterX) + ', ' + (chartConfigOptions.availY + fCenterY) + ')');
    var oPiePlotOptions = 'pie' === chartConfigOptions.chart.type.toLowerCase() ? chartConfigOptions.plotOptions.pie : chartConfigOptions.plotOptions.donut;
    var fDegree = 0,
        startX = 0,
        startY = fRadius,
        newX = 0,
        newY = 0,
        reflectNewY = 0,
        reflectStartY = 0,
        largeFlag = 0,
        borderWidth = oPiePlotOptions.borderWidth,
        borderDashStyle = oPiePlotOptions.borderDashStyle;
    var xPos = 0,
        yPos = 0,
        idistanceFactor = chartConfigOptions.plotOptions.donut.dataLabels.lineLengthFactor || 5;
    if (oPiePlotOptions.emptyPie && iEnabledSeries === 0) {
        var oCircleAttr = {
            cx: 0,
            cy: 0,
            r: fRadius,
            fill: '#fff',
            'z-index': 10,
            stroke: 'black',
            'stroke-width': 1,
            opacity: 0.8
        };
        var oCircle = MAQ.createSVGElement(chartConfigOptions.svgNS, 'circle', oCircleAttr);
        oGrpELE.appendChild(oCircle);
    }
    if (oDataInfo.total > 0) {
        if (iEnabledSeries === 1) {
            borderWidth = 0;
            borderDashStyle = '';
        }
        var oPathAttr = {
            d: '',
            fill: '',
            'z-index': 5,
            opacity: oPiePlotOptions.opacity,
            stroke: oPiePlotOptions.borderColor,
            'stroke-width': borderWidth,
            'stroke-dasharray': MAQ.computeStrokeDashStyle(borderDashStyle)
        };
        /*private function to slice the pie on click*/
        var slice = function() {
            var pieId = parseInt(this.id.substring(3)),
                transformVal = this.parentNode.getAttribute('transform');
            if (pieId + 1 !== flag) {
                if (transformVal && !('translate(0)' === transformVal || 'translate(0,0)' === transformVal)) {
                    this.parentNode.setAttribute('transform', 'translate(0,0)');
                } else {
                    if (oPiePlotOptions.resetPreviousSliced) {
                        var pieBlocks = document.querySelectorAll('#' + chartConfigOptions.chart.renderTo + ' path[id^=\'pie\']');
                        var iCount = pieBlocks.length;
                        while (iCount) {
                            iCount -= 1;
                            pieBlocks[iCount].parentNode.setAttribute('transform', 'translate(0,0)');
                        }
                    }
                    this.parentNode.setAttribute('transform', 'translate(' + posX[pieId] + ',' + posY[pieId] + ')');
                }
            }
        };
        var numOfColors = oPiePlotOptions.color.length,
            oPieDataGroup,
            oPath,
            oPieLabelLineStyles,
            oPieLabelLine,
            oPieLabelStyles,
            oPieLabel,
            oTextNode,
            sValue,
            oLabelBox,
            oParam,
            oToolTip;
        oPiePlotOptions.degrees = [];
        oPiePlotOptions[chartConfigOptions.chart.type + 's'] = [];
        for (iCounter = 0; iCounter < iLength; iCounter += 1) {
            oPieDataGroup = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g');
            oGrpELE.appendChild(oPieDataGroup);
            oPiePlotOptions[chartConfigOptions.chart.type + 's'].push(oPieDataGroup);
            if (isSeriesEnabled(oSeries, iCounter)) {
                if (iEnabledSeries === 1) {
                    fDegree = 1.999999 * Math.PI;
                } else {
                    fDegree = 2 * Math.PI * (oSeries[iCounter].data / oDataInfo.total);
                }
                oPiePlotOptions.degrees.push(fDegree);
                if (fDegree > Math.PI) {
                    largeFlag = 1;
                }
                newX = startX * Math.cos(fDegree) - startY * Math.sin(fDegree);
                newY = startX * Math.sin(fDegree) + startY * Math.cos(fDegree);
                reflectNewY = -newY;
                reflectStartY = -startY;
                if (!Math.floor(parseFloat(reflectNewY))) {
                    reflectNewY = 0;
                }
                xPos = (startX * Math.cos(fDegree / 2) - startY * Math.sin(fDegree / 2)) / idistanceFactor;
                yPos = -(startX * Math.sin(fDegree / 2) + startY * Math.cos(fDegree / 2)) / idistanceFactor;
                posX.push(-xPos);
                posY.push(yPos);
                oPieDataGroup.setAttribute('id', 'gie' + iCounter);
                oPathAttr.id = 'pie' + iCounter;
                oPathAttr.d = 'M 0,0' + ' L ' + -newX + ',' + reflectNewY + ' A ' + fRadius + ',' + fRadius + ' 0 ' + largeFlag + ', 0 ' + -startX + ',' + reflectStartY + ' Z ';
                oPathAttr.fill = oPiePlotOptions.color[iCounter % numOfColors];
                oPath = MAQ.createSVGElement(chartConfigOptions.svgNS, 'path', oPathAttr);
                if (oPiePlotOptions.dataLabels.enabled) {
                    if (oSeries[iCounter].data !== 0) {
                        oPieLabelLineStyles = {
                            'stroke-width': oPiePlotOptions.dataLabels.lineWidth,
                            stroke: oPiePlotOptions.dataLabels.lineColor,
                            fill: 'none',
                            d: ''
                        };
                        oPieLabelLineStyles.d = 'M ' + -(xPos * idistanceFactor) + ',' + yPos * idistanceFactor + ' L ' + -(xPos * idistanceFactor + xPos) + ',' + (yPos * idistanceFactor + yPos) + ' L ' + -(xPos * idistanceFactor + xPos * 2) + ',' + (yPos * idistanceFactor + yPos);
                        oPieLabelLine = MAQ.createSVGElement(chartConfigOptions.svgNS, 'path', oPieLabelLineStyles);
                        oPieDataGroup.appendChild(oPieLabelLine);
                        oPieLabelStyles = {
                            x: -(xPos * idistanceFactor + xPos * 2),
                            y: yPos * idistanceFactor + yPos,
                            style: oPiePlotOptions.dataLabels.style
                        };
                        oPieLabel = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oPieLabelStyles);
                        if (oPiePlotOptions.dataLabels.formatter) {
                            sValue = MAQ.applyFormatter(oSeries[iCounter], oPiePlotOptions.dataLabels.formatter);
                            if (oPiePlotOptions.dataLabels.multiline) {
                                oPieLabel = MAQ.utils.getMultiLineSVGText(chartConfigOptions.svgNS, chartConfigOptions.svgELE, sValue, oPieLabelStyles, oPiePlotOptions.dataLabels.maxChars, Math.round(oSeries[iCounter].data * 10) / 10);
                            } else {
                                oTextNode = document.createTextNode(sValue);
                                oPieLabel.appendChild(oTextNode);
                            }
                        } else {
                            sValue = oSeries[iCounter].name + ': ' + Math.round(oSeries[iCounter].data * 10) / 10;
                            if (oPiePlotOptions.dataLabels.multiline) {
                                sValue = oSeries[iCounter].name;
                                oPieLabel = MAQ.utils.getMultiLineSVGText(chartConfigOptions.svgNS, chartConfigOptions.svgELE, sValue, oPieLabelStyles, oPiePlotOptions.dataLabels.maxChars, Math.round(oSeries[iCounter].data * 10) / 10);
                            } else {
                                oTextNode = document.createTextNode(sValue);
                                oPieLabel.appendChild(oTextNode);
                            }
                        }
                        oPieDataGroup.appendChild(oPieLabel);
                        oLabelBox = oPieLabel.getBBox();
                        if (xPos < 0) {
                            MAQ.addAttr(oPieLabel, 'dx', 3);
                        } else {
                            MAQ.addAttr(oPieLabel, 'dx', -oLabelBox.width - 3);
                        }
                        if (yPos < 0) {
                            MAQ.addAttr(oPieLabel, 'dy', 2);
                        } else {
                            MAQ.addAttr(oPieLabel, 'dy', oLabelBox.height / 2 - 2);
                        }
                    }
                }
                oPieDataGroup.appendChild(oPath);
                oParam = {
                    seriesIndex: iCounter,
                    isPosavail: true,
                    position: iCounter,
                    config: chartConfigOptions
                };
                if (chartConfigOptions.tooltip.enabled) {
                    oToolTip = chartConfigOptions.tooltipDiv;
                    MAQ.addEventListener(oPath, 'mousemove', showToolTip, oParam);
                    MAQ.addEventListener(oPath, 'mouseout', hideToolTip, oToolTip);
                }
                if (chartConfigOptions.onClick.enabled) {
                    MAQ.addEventListener(oPath, 'click', clickEventListener, oParam);
                }
                if ('pie' === chartConfigOptions.chart.type.toLowerCase() && oPiePlotOptions.sliceOnSelect) {
                    oPath.addEventListener('click', slice);
                }
                largeFlag = 0;
                startX = newX;
                startY = newY;
            } else {
                posX.push(-xPos);
                posY.push(yPos);
            }
            MAQ.animateClipElement(chartConfigOptions.chart.renderTo + 'clippathRect', 'r', fRadius + 100, 1000);
        }
        if ('donut' === chartConfigOptions.chart.type.toLowerCase()) {
            //add the donut center circle
            oAttr = {
                cx: 0,
                cy: 0,
                r: chartConfigOptions.plotOptions.donut.innerRadius || fRadius / 2,
                stroke: oPiePlotOptions.borderColor,
                'stroke-width': borderWidth,
                fill: oPiePlotOptions.borderColor
            };
            var oCircleEle = MAQ.createSVGElement(chartConfigOptions.svgNS, 'circle', oAttr);
            oGrpELE.appendChild(oCircleEle);
            var oShowTotalConfig = chartConfigOptions.plotOptions.donut.showTotal;
            //add the center text
            if (true === oShowTotalConfig.enabled) {
                // Title text attribute
                // if title is multiline then loop and add  multiple text objects
                var oTitleTextAttr = {
                    x: oShowTotalConfig.title.x,
                    y: oShowTotalConfig.title.y,
                    text: oShowTotalConfig.title.text,
                    style: oShowTotalConfig.title.style
                };
                var oTotalTextAttr = {
                    x: oShowTotalConfig.sumvalue.x,
                    y: oShowTotalConfig.spacing + oShowTotalConfig.sumvalue.y,
                    text: iTotal,
                    style: oShowTotalConfig.sumvalue.style,
                    class: 'MAQCharts-DonutTotal' //class specified to allow adding custom styles to child tspan using css
                };
                var sTotalValue = oTotalTextAttr.text;
                if ('function' === typeof oShowTotalConfig.formatter) {
                    sTotalValue = oShowTotalConfig.formatter(oTotalTextAttr.text);
                }
                //calculate the max no of characters using temporary A text that can fit in the inner circle
                var oDim = MAQ.utils.getTextDim('X', oTotalTextAttr.style, chartConfigOptions);
                var iAllowedWidth = oAttr.r * 2;
                var iMaxNoOfAllowedChar = iAllowedWidth / oDim.width;
                var oTotalValue, iIterator;
                //add ellipsis to title
                if (oTitleTextAttr.text.length > iMaxNoOfAllowedChar + 2) {
                    oTitleTextAttr.title = oTitleTextAttr.text;
                    oTitleTextAttr.text = oTitleTextAttr.text.substring(0, iMaxNoOfAllowedChar) + '...';
                }
                //if the total value is an array apply tsapn to allow separate styling of each text item in the array
                if ('[object Array]' === Object.prototype.toString.call(sTotalValue)) {
                    oTotalTextAttr.text = '';
                    oTotalValue = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oTotalTextAttr);
                    Object.keys(sTotalValue).forEach(function(iIterator) {
                        if (sTotalValue[iIterator].text) {
                            //if array of attributes is supplied apply those
                            oTotalValue.appendChild(MAQ.createSVGElement(chartConfigOptions.svgNS, 'tspan', sTotalValue[iIterator]));
                        } else {
                            //if only text is supplied
                            oTotalValue.appendChild(MAQ.createSVGElement(chartConfigOptions.svgNS, 'tspan', {
                                text: sTotalValue[iIterator]
                            }));
                        }
                    });
                } else {
                    if (sTotalValue.length > iMaxNoOfAllowedChar) {
                        oTotalTextAttr.title = sTotalValue;
                        sTotalValue = sTotalValue.substring(0, iMaxNoOfAllowedChar) + '...';
                        oTotalTextAttr.text = sTotalValue;
                    }
                    oTotalValue = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oTotalTextAttr);
                }
                oGrpELE.appendChild(MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oTitleTextAttr));
                oGrpELE.appendChild(oTotalValue);
            }
        }
        if (chartConfigOptions.animation.enabled) {
            switch (chartConfigOptions.animation.type) {
                case 3:
                    MAQ.animateClipElement(animationConfigurations.id, 'r', chartConfigOptions.width / 2, 1000);
                    break;
                case 2:
                    MAQ.animatePieArc(animationConfigurations.id, chartConfigOptions.width / 2, true, function() {
                        chartConfigOptions.events.onAnimationComplete && 'function' === typeof chartConfigOptions.events.onAnimationComplete && chartConfigOptions.events.onAnimationComplete(chartConfigOptions);
                    });
                    break;
                default:
                    MAQ.animatePieArc(animationConfigurations.id, chartConfigOptions.width / 2, false, function() {
                        chartConfigOptions.events.onAnimationComplete && 'function' === typeof chartConfigOptions.events.onAnimationComplete && chartConfigOptions.events.onAnimationComplete(chartConfigOptions);
                    });
                    break;
            }
        }
    }
};
MAQ.createGaugeChart = function(chartConfigOptions) {
    'use strict';
    MAQ.applyMargin(chartConfigOptions, chartConfigOptions.chart.margin);
    var iCounter = 0,
        iLength = 3,
        // Gauge with 3 Zones over 180 degrees
        posX = [],
        posY = [],
        fAvailHeight = chartConfigOptions.availHeight,
        fAvailWidth = chartConfigOptions.availWidth,
        fCenterX = fAvailWidth / 2,
        fCenterY = fAvailHeight - parseInt(chartConfigOptions.plotOptions.gauge.dataLabels.LabelStyle.fontSize) - 20,
        oGaugePlotOptions = chartConfigOptions.plotOptions.gauge,
        fRadius = oGaugePlotOptions.radius,
        // Radius value from JSON   // Gauge properties
        fInnerRadius = fRadius - oGaugePlotOptions.gaugeWidth,
        numOfColors = oGaugePlotOptions.color.length,
        borderWidth = oGaugePlotOptions.borderWidth,
        borderDashStyle = oGaugePlotOptions.borderDashStyle,
        fDegree = 0,
        arcDegree = 0,
        startX = fRadius,
        startY = 0,
        newX = 0,
        newY = 0,
        reflectNewY = 0,
        reflectStartY = 0,
        largeFlag = 0,
        xPos = 0,
        yPos = 0,
        idistanceFactor = 8,
        degreeSeries = [],
        oGaugeDataGroup,
        oPath,
        oParam,
        oToolTip,
        oAttr = {
            class: 'MAQCharts-plotArea',
            transform: 'translate(' + chartConfigOptions.availX + ',' + chartConfigOptions.availY + ')',
            opacity: 1,
            'clip-path': chartConfigOptions.animation.enabled ? 'url(#' + chartConfigOptions.chart.renderTo + 'clippath)' : ''
        },
        oPathAttr = {
            d: '',
            fill: '',
            'z-index': 5,
            opacity: oGaugePlotOptions.opacity,
            stroke: oGaugePlotOptions.borderColor,
            'stroke-width': borderWidth,
            'stroke-dasharray': MAQ.computeStrokeDashStyle(borderDashStyle)
        },
        oGaugeDataGroupStyles;
    oGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    chartConfigOptions.svgELE.appendChild(oGrpELE);
    MAQ.addAttr(oGrpELE, 'transform', 'translate(' + (chartConfigOptions.availX + fCenterX) + ', ' + (chartConfigOptions.availY + fCenterY) + ')');
    degreeSeries[0] = oGaugePlotOptions.zone1Angle;
    degreeSeries[1] = oGaugePlotOptions.zone2Angle;
    degreeSeries[2] = oGaugePlotOptions.gaugeAngle - (oGaugePlotOptions.zone1Angle + oGaugePlotOptions.zone2Angle);
    if (degreeSeries[2] < 0) {
        console.error('sum of zone angles cannot be greater than gauge angle');
    }
    if (oGaugePlotOptions.target < oGaugePlotOptions.minValue || oGaugePlotOptions.target > oGaugePlotOptions.maxValue) {
        console.error('target cannot be outside min and max value range');
    }
    oGaugePlotOptions.degrees = [];
    for (iCounter = 0; iCounter < iLength; iCounter += 1) {
        oGaugeDataGroupStyles = {};
        oGaugeDataGroup = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oGaugeDataGroupStyles);
        oGrpELE.appendChild(oGaugeDataGroup);
        fDegree = degreeSeries[iCounter] / 180 * Math.PI;
        oGaugePlotOptions.degrees.push(fDegree);
        if (fDegree > Math.PI) {
            largeFlag = 1;
        }
        newX = startX * Math.cos(fDegree) - startY * Math.sin(fDegree);
        newY = startX * Math.sin(fDegree) + startY * Math.cos(fDegree);
        reflectNewY = -newY;
        reflectStartY = -startY;
        if (!Math.floor(parseFloat(reflectNewY))) {
            reflectNewY = 0;
        }
        xPos = (startX * Math.cos(fDegree / 2) - startY * Math.sin(fDegree / 2)) / idistanceFactor;
        yPos = -(startX * Math.sin(fDegree / 2) + startY * Math.cos(fDegree / 2)) / idistanceFactor;
        posX.push(-xPos);
        posY.push(yPos);
        oPathAttr.id = 'gauge' + iCounter;
        oPathAttr.d = 'M 0,0' + ' L ' + -newX + ',' + reflectNewY + ' A ' + fRadius + ',' + fRadius + ' 0 ' + largeFlag + ', 0 ' + -startX + ',' + reflectStartY + ' Z ';
        oPathAttr.fill = oGaugePlotOptions.color[iCounter % numOfColors];
        oPath = MAQ.createSVGElement(chartConfigOptions.svgNS, 'path', oPathAttr);
        oGaugeDataGroup.appendChild(oPath);
        ////   Tooltip for Arc
        oParam = {
            seriesIndex: 0,
            isPosavail: true,
            position: iCounter + 2,
            config: chartConfigOptions
        };
        chartConfigOptions.series[iCounter + 2] = [];
        chartConfigOptions.series[iCounter + 2].name = 'Zone ' + iCounter;
        chartConfigOptions.series[iCounter + 2].minValue = oGaugePlotOptions.minValue + arcDegree / oGaugePlotOptions.gaugeAngle * (oGaugePlotOptions.maxValue - oGaugePlotOptions.minValue);
        arcDegree += degreeSeries[iCounter];
        chartConfigOptions.series[iCounter + 2].maxValue = oGaugePlotOptions.minValue + arcDegree / oGaugePlotOptions.gaugeAngle * (oGaugePlotOptions.maxValue - oGaugePlotOptions.minValue);
        if (chartConfigOptions.tooltip.enabled) {
            oToolTip = chartConfigOptions.tooltipDiv;
            MAQ.addEventListener(oPath, 'mousemove', showToolTip, oParam);
            MAQ.addEventListener(oPath, 'mouseout', hideToolTip, oToolTip);
        }
        largeFlag = 0;
        startX = newX;
        startY = newY;
        MAQ.animateClipElement('' + chartConfigOptions.chart.renderTo + 'clippathRect', 'r', fRadius + 100, 1000);
    }
    // Fill central void with white color
    var oPathVoidAttr = {
        d: '',
        fill: oGaugePlotOptions.dataLabels.LabelStyle.background,
        'z-index': 5,
        opacity: oGaugePlotOptions.opacity,
        stroke: oGaugePlotOptions.borderColor,
        'stroke-width': borderWidth,
        'stroke-dasharray': MAQ.computeStrokeDashStyle(borderDashStyle)
    };
    var VoidAngle = oGaugePlotOptions.gaugeAngle / 180 * Math.PI;
    oPathVoidAttr.id = 'GaugeVoid';
    oPathVoidAttr.d = 'M 0,1' + ' L ' + -(fInnerRadius * Math.cos(VoidAngle)) + ',' + -(fInnerRadius * Math.sin(VoidAngle) - 1) + ' A ' + fInnerRadius + ',' + fInnerRadius + ' 0 ' + largeFlag + ', 0 ' + -fInnerRadius + ',' + 1 + ' Z ';
    var oPathVoid = MAQ.createSVGElement(chartConfigOptions.svgNS, 'path', oPathVoidAttr);
    oGrpELE.appendChild(oPathVoid);
    //Gauge Needle
    var Needle = {
        d: '',
        fill: oGaugePlotOptions.dataLabels.ValueStyle.pointerColor,
        'z-index': 100,
        opacity: 1
    };
    var deviationAngle = Math.atan(oGaugePlotOptions.pointerWidth / (fInnerRadius * 2));
    var needleAngleA = oGaugePlotOptions.gaugeAngle * (oGaugePlotOptions.pointerValue - oGaugePlotOptions.minValue) / (oGaugePlotOptions.maxValue - oGaugePlotOptions.minValue),
        needleAngleB,
        needleAngleC;
    // variable to be added
    needleAngleA = needleAngleA / 180 * Math.PI;
    needleAngleB = needleAngleA - deviationAngle;
    needleAngleC = needleAngleA + deviationAngle;
    Needle.id = 'gaugeNeedle';
    Needle.d = 'M ' + -(fInnerRadius + oGaugePlotOptions.pointerHeight) * Math.cos(needleAngleA) + ',' + -(fInnerRadius + oGaugePlotOptions.pointerHeight) * Math.sin(needleAngleA) + ' L ' + -fInnerRadius * Math.cos(needleAngleB) + ',' + -fInnerRadius * Math.sin(needleAngleB) + ' L ' + -fInnerRadius * Math.cos(needleAngleC) + ',' + -fInnerRadius * Math.sin(needleAngleC) + ' Z ';
    var oNeedleEle = MAQ.createSVGElement(chartConfigOptions.svgNS, 'path', Needle);
    oGrpELE.appendChild(oNeedleEle);
    // Tooltip for Pointer
    chartConfigOptions.series[0] = [];
    chartConfigOptions.series[0].name = 'Actual Value';
    chartConfigOptions.series[0].value = oGaugePlotOptions.pointerValue;
    oParam = {
        seriesIndex: 0,
        isPosavail: true,
        position: 0,
        config: chartConfigOptions
    };
    if (chartConfigOptions.tooltip.enabled) {
        oToolTip = chartConfigOptions.tooltipDiv;
        MAQ.addEventListener(oNeedleEle, 'mousemove', showToolTip, oParam);
        MAQ.addEventListener(oNeedleEle, 'mouseout', hideToolTip, oToolTip);
    }
    /// target Line
    var targetAngle = oGaugePlotOptions.gaugeAngle * (oGaugePlotOptions.target - oGaugePlotOptions.minValue) / (oGaugePlotOptions.maxValue - oGaugePlotOptions.minValue);
    //  180 to be removed
    targetAngle = targetAngle / 180 * Math.PI;
    var targetLine = {
        x1: -fInnerRadius * Math.cos(targetAngle),
        y1: -fInnerRadius * Math.sin(targetAngle),
        x2: -fRadius * Math.cos(targetAngle),
        y2: -fRadius * Math.sin(targetAngle),
        stroke: oGaugePlotOptions.dataLabels.ValueStyle.targetLineColor,
        'z-index': 100,
        opacity: 1,
        'pointer-events': 'visible',
        //stroke: oGaugePlotOptions.borderColor,
        'stroke-width': 3,
        'stroke-dasharray': '3,3'
    };
    targetLine.id = 'gaugeTarget';
    var oTargetLineEle = MAQ.createSVGElement(chartConfigOptions.svgNS, 'line', targetLine);
    oGrpELE.appendChild(oTargetLineEle);
    // Tooltip for target Line
    oParam = {
        seriesIndex: 0,
        isPosavail: true,
        position: 1,
        config: chartConfigOptions
    };
    chartConfigOptions.series[1] = [];
    chartConfigOptions.series[1].name = 'Target Value';
    chartConfigOptions.series[1].value = oGaugePlotOptions.target;
    if (chartConfigOptions.tooltip.enabled) {
        oToolTip = chartConfigOptions.tooltipDiv;
        MAQ.addEventListener(oTargetLineEle, 'mousemove', showToolTip, oParam);
        MAQ.addEventListener(oTargetLineEle, 'mouseout', hideToolTip, oToolTip);
    }
    //  Gauge Legends
    if (oGaugePlotOptions.dataLabels.enabled) {
        fCenterX = fCenterX + chartConfigOptions.chart.margin[3];
        fCenterY = fCenterY + chartConfigOptions.availY;
        var oAttrActualTitle = {
            x: fCenterX,
            y: fCenterY,
            text: 'Actual',
            dx: 0,
            dy: -fInnerRadius / 2,
            'text-anchor': 'middle',
            fill: oGaugePlotOptions.dataLabels.LabelStyle.color,
            style: oGaugePlotOptions.dataLabels.LabelStyle
        };
        var oAttrActualValue = {
            x: fCenterX,
            y: fCenterY,
            text: MAQ.applyFormatter(oGaugePlotOptions.pointerValue, oGaugePlotOptions.dataLabels.ValueStyle.formatter),
            dx: 0,
            dy: 0,
            'text-anchor': 'middle',
            fill: oGaugePlotOptions.dataLabels.ActualValueStyle.color,
            style: oGaugePlotOptions.dataLabels.ActualValueStyle
        };
        var oAttrMinValue = {
            x: fCenterX - fRadius,
            y: fCenterY,
            text: MAQ.applyFormatter(oGaugePlotOptions.minValue, oGaugePlotOptions.dataLabels.ValueStyle.formatter),
            dx: oGaugePlotOptions.gaugeWidth / 2,
            dy: 0,
            'text-anchor': 'middle',
            fill: oGaugePlotOptions.dataLabels.LabelStyle.color,
            style: oGaugePlotOptions.dataLabels.LabelStyle
        };
        var oAttrMaxValue = {
            x: fCenterX + fRadius,
            y: fCenterY,
            text: MAQ.applyFormatter(oGaugePlotOptions.maxValue, oGaugePlotOptions.dataLabels.ValueStyle.formatter),
            dx: -oGaugePlotOptions.gaugeWidth / 2,
            dy: 0,
            'text-anchor': 'middle',
            fill: oGaugePlotOptions.dataLabels.LabelStyle.color,
            style: oGaugePlotOptions.dataLabels.LabelStyle
        };
        var oAttrTarget = {
            x: fCenterX - fRadius,
            y: fCenterY - fRadius - 30,
            text: 'Target',
            dx: 0,
            dy: 0,
            'text-anchor': 'start',
            fill: oGaugePlotOptions.dataLabels.LabelStyle.color,
            style: oGaugePlotOptions.dataLabels.LabelStyle
        };
        var oAttrTargetValue = {
            x: fCenterX - fRadius,
            y: fCenterY - fRadius - 30,
            text: MAQ.applyFormatter(oGaugePlotOptions.target, oGaugePlotOptions.dataLabels.ValueStyle.formatter),
            dx: 0,
            dy: 0,
            'text-anchor': 'start',
            fill: oGaugePlotOptions.dataLabels.ValueStyle.color,
            style: oGaugePlotOptions.dataLabels.ValueStyle
        };
        var oAttrVariance = {
            x: fCenterX + fRadius,
            y: fCenterY - fRadius - 30,
            text: oGaugePlotOptions.varianceText,
            dx: 0,
            dy: 0,
            'text-anchor': 'end',
            fill: oGaugePlotOptions.dataLabels.LabelStyle.color,
            style: oGaugePlotOptions.dataLabels.LabelStyle
        };
        var oAttrVarianceValue = {
            x: fCenterX + fRadius,
            y: fCenterY - fRadius - 30,
            text: oGaugePlotOptions.variance,
            dx: 0,
            dy: 0,
            'text-anchor': 'end',
            fill: oGaugePlotOptions.dataLabels.ValueStyle.color,
            style: oGaugePlotOptions.dataLabels.ValueStyle
        };
        var oActualTitleObj = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttrActualTitle);
        var oActualValueObj = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttrActualValue);
        var oMinValueObj = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttrMinValue);
        var oMaxValueObj = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttrMaxValue);
        var oTargetObj = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttrTarget);
        var oTargetValueObj = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttrTargetValue);
        var oVarianceObj = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttrVariance);
        var oVarianceValueObj = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttrVarianceValue);
        var oGrpELE = document.createElementNS(chartConfigOptions.svgNS, 'g');
        oGrpELE.setAttribute('class', 'MAQCharts-Legends');
        oGrpELE.appendChild(oActualTitleObj);
        oGrpELE.appendChild(oActualValueObj);
        oGrpELE.appendChild(oMinValueObj);
        oGrpELE.appendChild(oMaxValueObj);
        oGrpELE.appendChild(oTargetObj);
        oGrpELE.appendChild(oTargetValueObj);
        oGrpELE.appendChild(oVarianceObj);
        oGrpELE.appendChild(oVarianceValueObj);
        chartConfigOptions.svgELE.appendChild(oGrpELE);
        var oDim = MAQ.getObjectDimension(oMinValueObj);
        MAQ.addAttr(oMinValueObj, 'dy', Math.abs(oDim.height));
        oDim = MAQ.getObjectDimension(oMaxValueObj);
        MAQ.addAttr(oMaxValueObj, 'dy', Math.abs(oDim.height));
        oDim = MAQ.getObjectDimension(oVarianceValueObj);
        MAQ.addAttr(oVarianceObj, 'dy', -Math.abs(oDim.height));
        MAQ.addAttr(oTargetObj, 'dy', -Math.abs(oDim.height));
    }
};
/*
MAQ.createStockChart: Renders stock chart
@param {chartConfigOptions} user configuration parameters
*/
MAQ.createStockChart = function(chartConfigOptions) {
    'use strict';
    MAQ.drawXAxisTitle(chartConfigOptions);
    MAQ.drawYAxisTitle(chartConfigOptions);
    MAQ.applyMargin(chartConfigOptions, chartConfigOptions.chart.margin);
    var oSeries = chartConfigOptions.series[0];
    chartConfigOptions.series.label = chartConfigOptions.xAxis.labels.series;
    var oDataInfo = {},
        oNormalizedData;
    oDataInfo = MAQ.getMinMax(oSeries.low, 0, 0);
    oDataInfo = MAQ.getMinMax(oSeries.high, oDataInfo.min, oDataInfo.max);
    oDataInfo = MAQ.getMinMax(oSeries.open, oDataInfo.min, oDataInfo.max);
    oDataInfo = MAQ.getMinMax(oSeries.close, oDataInfo.min, oDataInfo.max);
    if (oDataInfo.min || oDataInfo.max) {
        if ((chartConfigOptions.yAxis.minVal || 0 === chartConfigOptions.yAxis.minVal) && chartConfigOptions.yAxis.maxVal) {
            oNormalizedData = {
                min: chartConfigOptions.yAxis.minVal,
                max: chartConfigOptions.yAxis.maxVal
            };
            oNormalizedData.interval = (oNormalizedData.max - oNormalizedData.min) / chartConfigOptions.yAxis.numberOfGridLines;
        } else {
            oNormalizedData = MAQ.getNormalized_Min_Max_Interval(oDataInfo.min, oDataInfo.max, chartConfigOptions.yAxis.numberOfGridLines);
        }
        oNormalizedData.sum = oNormalizedData.max + Math.abs(oNormalizedData.min);
        chartConfigOptions.plotOptions.stock.normalizedData = oNormalizedData;
        MAQ.drawAxis(chartConfigOptions);
        var oAttr = {
            class: 'MAQCharts-plotArea',
            transform: 'translate(' + chartConfigOptions.availX + ',' + chartConfigOptions.availY + ')',
            opacity: 0
        };
        var oGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
        chartConfigOptions.svgELE.appendChild(oGrpELE);
        var oStockPlotOptions = chartConfigOptions.plotOptions.stock,
            oBarWidth = chartConfigOptions.plotIntervalWidth - oStockPlotOptions.padding;
        MAQ.addAttr(chartConfigOptions.xLabels, 'transform', 'translate(' + oBarWidth / 2 + ', 0)');
        var oLineAttr = {
            x1: oBarWidth / 2,
            y1: 0,
            x2: oBarWidth / 2,
            y2: 0,
            stroke: oStockPlotOptions.lineColor,
            'stroke-width': oStockPlotOptions.lineWidth
        };
        var oMedianLineAttr = {
            x1: 0,
            y1: 0,
            x2: 0,
            y2: 0,
            stroke: oStockPlotOptions.lineColor,
            'stroke-width': oStockPlotOptions.lineWidth
        };
        var oRectAttr = {
            x: 0,
            y: 0,
            width: oBarWidth,
            height: 0,
            fill: '#0066CC',
            opacity: oStockPlotOptions.opacity,
            stroke: oStockPlotOptions.borderColor,
            'stroke-width': oStockPlotOptions.borderWidth,
            'stroke-dasharray': MAQ.computeStrokeDashStyle(oStockPlotOptions.borderDashStyle)
        };
        oAttr = {
            'pointer-events': 'visibleFill'
        };
        chartConfigOptions.svgELE.appendChild(oGrpELE);
        var iHeightFactor = chartConfigOptions.availHeight / (Math.abs(oNormalizedData.min) + oNormalizedData.max);
        var iZeroAxis = oNormalizedData.max / oNormalizedData.sum * chartConfigOptions.availHeight;
        var iCounter = 0;
        var iLength = oSeries.low.length;
        var iYcordOpen = 0;
        var iYcordClose = 0,
            oRect, oLine, oGrpDoji, oMedianLine, oParam, oToolTip;
        for (iCounter = 0; iCounter < iLength; iCounter += 1) {
            oLineAttr.y1 = iZeroAxis - iHeightFactor * Math.abs(oSeries.low[iCounter]);
            oLineAttr.y2 = iZeroAxis - iHeightFactor * Math.abs(oSeries.high[iCounter]);
            iYcordOpen = iZeroAxis - iHeightFactor * Math.abs(oSeries.open[iCounter]);
            iYcordClose = iZeroAxis - iHeightFactor * Math.abs(oSeries.close[iCounter]);
            if (iYcordOpen >= iYcordClose) {
                oRectAttr.y = iYcordClose;
                oRectAttr.height = iYcordOpen - iYcordClose;
            } else {
                oRectAttr.y = iYcordClose;
                oRectAttr.height = iYcordClose - iYcordOpen;
            }
            oRect = MAQ.createSVGElement(chartConfigOptions.svgNS, 'rect', oRectAttr);
            oLine = MAQ.createSVGElement(chartConfigOptions.svgNS, 'line', oLineAttr);
            oGrpDoji = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
            oGrpDoji.appendChild(oLine);
            oGrpDoji.appendChild(oRect);
            if (chartConfigOptions.median.enabled) {
                oMedianLineAttr.x1 = oRectAttr.x;
                oMedianLineAttr.x2 = oRectAttr.x + oRectAttr.width;
                oMedianLineAttr.y1 = iZeroAxis - iHeightFactor * Math.abs(oSeries.median[iCounter]);
                oMedianLineAttr.y2 = oMedianLineAttr.y1;
                oMedianLine = MAQ.createSVGElement(chartConfigOptions.svgNS, 'line', oMedianLineAttr);
                oGrpDoji.appendChild(oMedianLine);
            }
            oGrpELE.appendChild(oGrpDoji);
            oParam = {
                seriesIndex: 0,
                isPosavail: true,
                position: iCounter,
                config: chartConfigOptions
            };
            if (chartConfigOptions.tooltip.enabled) {
                oToolTip = chartConfigOptions.tooltipDiv;
                MAQ.addEventListener(oGrpDoji, 'mousemove', showToolTip, oParam);
                MAQ.addEventListener(oGrpDoji, 'mouseout', hideToolTip, oToolTip);
            }
            oRectAttr.x += chartConfigOptions.plotIntervalWidth;
            oLineAttr.x2 += chartConfigOptions.plotIntervalWidth;
            oLineAttr.x1 = oLineAttr.x2;
        }
        MAQ.animateElement(oGrpELE, 'opacity', 1, 1000);
    }
};
/*
MAQ.createFunnelChart: Renders funnel chart
@param {chartConfigOptions} user configuration parameters
*/
MAQ.createFunnelChart = function(chartConfigOptions) {
    'use strict';
    if (iglobalCounter === 0) {
        chartConfigOptions.series.reverse();
    }
    MAQ.applyMargin(chartConfigOptions, chartConfigOptions.chart.margin);
    MAQ.drawLegend(chartConfigOptions);
    MAQ.drawYAxisTitle(chartConfigOptions);
    MAQ.applyMargin(chartConfigOptions, chartConfigOptions.chart.margin);
    var oSeries = chartConfigOptions.series,
        iCounter = 0,
        oDataInfo = {
            min: 0,
            max: 0
        },
        oFunnelPlotOptions = chartConfigOptions.plotOptions.funnel,
        oPathAttr, oSecondaryLabelAttr, oSecondaryLabel, oDim, oMaxWidthSecLbl, oAttr, oGrpELE, path, oPath, oParam, oRect, oFunnelLabelStyles, oFunnelLabel, oToolTip, fConnectorHeight = 0,
        fTubeHeight = 0,
        fFunnelGap = 0,
        fdelta = 0,
        oNormalizedData, oSecondaryLabelGrp, oRectAttr;
    for (iCounter = 0; iCounter < oSeries.length; iCounter += 1) {
        oDataInfo = MAQ.getMinMax(oSeries, oDataInfo.min, oDataInfo.max, 'data');
    }
    if (oDataInfo.min || oDataInfo.max) {
        if ((chartConfigOptions.yAxis.minVal || 0 === chartConfigOptions.yAxis.minVal) && chartConfigOptions.yAxis.maxVal) {
            oNormalizedData = {
                min: chartConfigOptions.yAxis.minVal,
                max: chartConfigOptions.yAxis.maxVal
            };
            oNormalizedData.interval = (oNormalizedData.max - oNormalizedData.min) / chartConfigOptions.yAxis.numberOfGridLines;
        } else {
            oNormalizedData = MAQ.getNormalized_Min_Max_Interval(oDataInfo.min, oDataInfo.max, chartConfigOptions.yAxis.numberOfGridLines);
        }
        oNormalizedData.sum = oNormalizedData.max + Math.abs(oNormalizedData.min);
        chartConfigOptions.plotOptions.funnel.normalizedData = oNormalizedData;
        //configure yAxis for funnel chart
        chartConfigOptions.yAxis.numberOfGridLines = oSeries.length - 2;
        chartConfigOptions.yAxis.lineWidth = 0;
        chartConfigOptions.yAxis.tickHeight = 0;
        chartConfigOptions.yAxis.tickWidth = 0;
        if (1 === oFunnelPlotOptions.type) {
            oDim = MAQ.utils.getTextDim('%', oFunnelPlotOptions.secondaryLabels.style, chartConfigOptions);
            oMaxWidthSecLbl = 0;
            //find the length of longest value
            for (iCounter = 0; iCounter < oSeries.length; iCounter += 1) {
                oMaxWidthSecLbl = Math.max(oSeries[iCounter].secondaryData && oSeries[iCounter].secondaryData.length || 0, oMaxWidthSecLbl);
            }
            oMaxWidthSecLbl = oMaxWidthSecLbl * oDim.width * 1.2;
            // calculate extra space required for secondary y axis labels on the right
            chartConfigOptions.availWidth -= oMaxWidthSecLbl;
            MAQ.drawAxis(chartConfigOptions);
            if (oFunnelPlotOptions.secondaryLabels.enabled) {
                oAttr = {
                    class: 'MAQCharts-secondaryYAxis'
                };
                oSecondaryLabelGrp = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
            }
        }
        oAttr = {
            class: 'MAQCharts-plotArea',
            transform: 'translate(' + chartConfigOptions.availX + ',' + chartConfigOptions.availY + ')',
            opacity: 0
        };
        oGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
        chartConfigOptions.svgELE.appendChild(oGrpELE);
        var fTotalInterval = chartConfigOptions.availHeight / oSeries.length,
            fMultiplicationFactor = chartConfigOptions.availWidth / oDataInfo.max,
            fAvailableHeight = chartConfigOptions.availHeight,
            fAvailableWidth = chartConfigOptions.availWidth / 2,
            sBottomleft = fAvailableWidth + ' ' + fAvailableHeight,
            sBottomright = sBottomleft,
            oTextNode;
        fdelta = fTotalInterval * 0.2 / (oSeries.length - 1);
        fConnectorHeight = fdelta + fTotalInterval * 0.2;
        //funnelGap = 0.2% of TotalInterval + portion of the extra funnelGap as gaps are 1 less than length
        fFunnelGap = fTotalInterval * 0.05 * oSeries.length / (oSeries.length - 1);
        fdelta += fTotalInterval * 0.05 / (oSeries.length - 1);
        fTubeHeight = (chartConfigOptions.availHeight - fConnectorHeight * (oSeries.length - 1)) / oSeries.length - 2 * fFunnelGap;
        for (iCounter = 0; iCounter < oSeries.length; iCounter += 1) {
            oPathAttr = {
                d: '',
                fill: oFunnelPlotOptions.color[iCounter],
                'z-index': 5,
                opacity: oFunnelPlotOptions.opacity * 0.5,
                stroke: oFunnelPlotOptions.color[iCounter],
                'stroke-width': oFunnelPlotOptions.lineWidth,
                'stroke-dasharray': MAQ.computeStrokeDashStyle(oFunnelPlotOptions.lineDashStyle)
            };
            if (1 === oFunnelPlotOptions.type) {
                oRectAttr = {
                    x: fAvailableWidth - fMultiplicationFactor * oSeries[iCounter].data / 2,
                    y: fAvailableHeight - fTubeHeight,
                    width: fMultiplicationFactor * oSeries[iCounter].data,
                    height: fTubeHeight,
                    opacity: oFunnelPlotOptions.opacity,
                    stroke: oFunnelPlotOptions.color[iCounter],
                    'stroke-width': oFunnelPlotOptions.lineWidth,
                    'stroke-dasharray': MAQ.computeStrokeDashStyle(oFunnelPlotOptions.lineDashStyle),
                    fill: oFunnelPlotOptions.color[iCounter],
                    'z-index': 5
                };
                //draw the rectangle
                oRect = MAQ.createSVGElement(chartConfigOptions.svgNS, 'rect', oRectAttr);
                oGrpELE.appendChild(oRect);
                //draw the trapezium
                if (iCounter < oSeries.length - 1) {
                    path = 'M' + oRectAttr.x + ' ' + (oRectAttr.y - fFunnelGap) + ' L' + (oRectAttr.x + oRectAttr.width) + ' ' + (oRectAttr.y - fFunnelGap) + ' L' + (fAvailableWidth + fMultiplicationFactor * oSeries[iCounter + 1].data / 2) + ' ' + (oRectAttr.y - fConnectorHeight - fFunnelGap) + ' L' + (fAvailableWidth - fMultiplicationFactor * oSeries[iCounter + 1].data / 2) + ' ' + (oRectAttr.y - fConnectorHeight - fFunnelGap) + ' Z';
                }
                //draw the secondary data points
                if (oFunnelPlotOptions.secondaryLabels.enabled) {
                    oSecondaryLabelAttr = {
                        x: 2 * fAvailableWidth + 0.1 * oDim.width + oFunnelPlotOptions.secondaryLabels.dx,
                        y: oRectAttr.y - fConnectorHeight / 2 - fFunnelGap + oDim.height / 2 + oFunnelPlotOptions.secondaryLabels.dx,
                        'text-anchor': 'start',
                        style: oFunnelPlotOptions.secondaryLabels.style,
                        text: oSeries[iCounter].secondaryData || ''
                    };
                    oSecondaryLabel = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oSecondaryLabelAttr);
                    oSecondaryLabelGrp.appendChild(oSecondaryLabel);
                    oGrpELE.appendChild(oSecondaryLabelGrp);
                }
            } else {
                path = 'M' + fAvailableWidth + ' ' + (fAvailableHeight - fTotalInterval) + ' L' + (fAvailableWidth - fMultiplicationFactor * oSeries[iCounter].data / 2) + ' ' + (fAvailableHeight - fTotalInterval) + ' L' + sBottomleft + ' L' + sBottomright + ' L' + (fAvailableWidth + fMultiplicationFactor * oSeries[iCounter].data / 2) + ' ' + (fAvailableHeight - fTotalInterval) + ' Z';
                sBottomleft = fAvailableWidth - fMultiplicationFactor * oSeries[iCounter].data / 2 + ' ' + (fAvailableHeight - fTotalInterval);
                sBottomright = fAvailableWidth + fMultiplicationFactor * oSeries[iCounter].data / 2 + ' ' + (fAvailableHeight - fTotalInterval);
            }
            oPathAttr.d = path;
            oPath = MAQ.createSVGElement(chartConfigOptions.svgNS, 'path', oPathAttr);
            oGrpELE.appendChild(oPath);
            oParam = {
                seriesIndex: 0,
                isPosavail: true,
                position: iCounter,
                config: chartConfigOptions
            };
            if (oFunnelPlotOptions.dataLabels.enabled) {
                if (oSeries[iCounter].data !== 0) {
                    oFunnelLabelStyles = {
                        x: 0,
                        y: 0,
                        'text-anchor': 'middle',
                        style: oFunnelPlotOptions.dataLabels.style
                    };
                    if (oFunnelPlotOptions.dataLabels.formatter) {
                        oTextNode = document.createTextNode(MAQ.applyFormatter(oSeries[iCounter], oFunnelPlotOptions.dataLabels.formatter));
                    } else {
                        oTextNode = document.createTextNode(oSeries[iCounter].name + ': ' + Math.round(oSeries[iCounter].data * 10) / 10);
                    }
                    oFunnelLabelStyles.x = fAvailableWidth + oFunnelPlotOptions.dataLabels.dx;
                    oFunnelLabelStyles.y = (fAvailableHeight - fTotalInterval + fConnectorHeight + 2 * fFunnelGap + fAvailableHeight) / 2 + +oFunnelPlotOptions.dataLabels.dy;
                    oFunnelLabel = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oFunnelLabelStyles);
                    oFunnelLabel.appendChild(oTextNode);
                    oGrpELE.appendChild(oFunnelLabel);
                }
            }
            if (chartConfigOptions.tooltip.enabled) {
                oToolTip = chartConfigOptions.tooltipDiv;
                if (1 === oFunnelPlotOptions.type) {
                    MAQ.addEventListener(oRect, 'mousemove', showToolTip, oParam);
                    MAQ.addEventListener(oRect, 'mouseout', hideToolTip, oToolTip);
                } else {
                    MAQ.addEventListener(oPath, 'mousemove', showToolTip, oParam);
                    MAQ.addEventListener(oPath, 'mouseout', hideToolTip, oToolTip);
                }
            }
            fAvailableHeight = fAvailableHeight - fTotalInterval - fdelta;
        }
        if (chartConfigOptions.animation.enabled) {
            MAQ.animateElement(oGrpELE, 'opacity', 1, 2500);
        } else {
            oGrpELE.setAttribute('opacity', 1);
        }
    }
};

function createTextTagForControl(sNS, sClass, sStyle, fX, fY, sDrillUrl, sValue) {
    'use strict';
    var oTextAttr = {
        x: fX,
        y: fY,
        text: sValue,
        class: sClass,
        style: sStyle
    };
    if (sDrillUrl) {
        oTextAttr.drillurl = sDrillUrl;
    }
    return MAQ.createSVGElement(sNS, 'text', oTextAttr);
}

function createPathTagForControl(sNS, sStroke, sStrokeDashArray, sDValue, sStyle) {
    'use strict';
    var oPathAttr = {
        style: sStyle,
        'stroke-dasharray': sStrokeDashArray,
        stroke: sStroke,
        d: sDValue
    };
    return MAQ.createSVGElement(sNS, 'path', oPathAttr);
}

function createRectTagForControl(sNS, sStyle, fX, fY, fWidth, fHeight, sClass) {
    'use strict';
    var oRectAttr = {
        x: fX,
        y: fY,
        width: fWidth,
        height: fHeight,
        style: sStyle,
        class: sClass
    };
    return MAQ.createSVGElement(sNS, 'rect', oRectAttr);
}
/*
MAQ.createHorizontalFunnelChart: Renders horizontal funnel chart
@param {chartConfigOptions} user configuration parameters
*/
MAQ.createHorizontalFunnelChart = function(chartConfigOptions) {
    'use strict';
    MAQ.applyMargin(chartConfigOptions, chartConfigOptions.chart.margin);
    //////////////////////////////////////
    var sFontSize15 = {
        'font-family': 'Segoe UI',
        'font-size': '15px',
        fill: '#2a2a2a',
        stroke: 'none',
        'stroke-width': 0
    };
    var sFontSize12 = {
        'font-family': 'Segoe UI',
        'font-size': '12px',
        fill: '#2a2a2a',
        stroke: 'none',
        'stroke-width': 0
    };
    var sFontSize20 = {
        'font-family': 'Segoe UI',
        'font-size': '20px',
        fill: '#2a2a2a',
        stroke: 'none',
        'stroke-width': 0
    };
    var sDollar = '<span class=\'unit\'>$</span>';
    var isSafe = MAQ.utils.isSafe,
        formatters = MAQ.utils.formatters,
        oCurrentTileConfig = chartConfigOptions.plotOptions.horizontalFunnel,
        iMaxRectSize = oCurrentTileConfig.chart.RectangleSize ? oCurrentTileConfig.chart.RectangleSize : 111,
        iConnectorSize = oCurrentTileConfig.chart.ConnectorSize ? oCurrentTileConfig.chart.ConnectorSize : 21,
        iGapBetweenRects = oCurrentTileConfig.chart.GapBetweenConnector ? oCurrentTileConfig.chart.GapBetweenConnector : 10,
        iMaxHeight = oCurrentTileConfig.chart.MaxHeight ? oCurrentTileConfig.chart.MaxHeight : 133,
        iStartingXPosition = 0,
        iStartingYPosition = 0,
        aLegend = chartConfigOptions.series[0].labels,
        iBoxPosition = oCurrentTileConfig.StartingYPos,
        iLabelPosition = 18,
        iLegend1PositionY = iLabelPosition + 31,
        iLegend2PositionY = iLegend1PositionY + 17,
        iMax = -99,
        sDrillUrl = oCurrentTileConfig.DrillDown,
        sNS = chartConfigOptions.svgNS,
        iCount = 0,
        RowLabels = [];
    //store the data labels
    for (iCount = 0; iCount < chartConfigOptions.series.length; iCount += 1) {
        RowLabels.push(chartConfigOptions.series[iCount].name);
    }
    //get the max value across all the data points from current and previous value
    var oSeries = chartConfigOptions.series,
        oLabels = chartConfigOptions.series[0].labels;
    oSeries.forEach(function(oVal) {
        var iCurVal = parseFloat(oVal.data[0]),
            iPrevVal = parseFloat(oVal.data[1] || iCurVal);
        iCurVal = isNaN(iCurVal) ? 0 : iCurVal;
        iPrevVal = isNaN(iPrevVal) ? 0 : iPrevVal;
        if (iMax < iCurVal && iCurVal >= iPrevVal) {
            iMax = iCurVal;
        } else {
            if (iMax < iPrevVal && iPrevVal >= iCurVal) {
                iMax = iPrevVal;
            }
        }
    });
    iStartingYPosition = iLegend2PositionY;
    var iLegend3PositionY = iStartingYPosition + iMaxHeight + 21,
        iLegend4PositionY = iLegend3PositionY + 20;
    RowLabels.unshift('MEMBER_CAPTION');
    var iTotalBars = RowLabels.length,
        iTotalLabels = oLabels.length,
        jCount;
    for (iCount = 0; iCount < iTotalLabels; iCount += 1) {
        //draw the row label
        for (jCount = 0; jCount < iTotalBars; jCount += 1) {}
    }
    if (oCurrentTileConfig.legendVisibility) {
        iStartingXPosition = chartConfigOptions.container.clientWidth - ((iTotalBars - 2) * (iMaxRectSize + iConnectorSize + iGapBetweenRects * 2) + iMaxRectSize);
    }
    var iCurrentY = iStartingYPosition + iBoxPosition,
        iColorCount = 0,
        iPrevY = 0,
        iPrevHeight = 0,
        iCurrentHeight = iMaxHeight - 2 * iBoxPosition;
    var oAttr = {
        class: 'MAQCharts-plotArea',
        transform: 'translate(' + chartConfigOptions.availX + ',' + chartConfigOptions.availY + ')'
    };
    var oTextAttr = {
        x: 0,
        y: iLegend1PositionY,
        text: aLegend[0],
        style: sFontSize15
    };
    var oGrpELE = MAQ.createSVGElement(sNS, 'g', oAttr);
    if (oCurrentTileConfig.legendVisibility) {
        // Creating legend labels
        oGrpELE.appendChild(MAQ.createSVGElement(sNS, 'text', oTextAttr));
        oTextAttr.style = sFontSize12;
        oTextAttr.y = iLegend3PositionY;
        oTextAttr.text = aLegend[2];
        oGrpELE.appendChild(MAQ.createSVGElement(sNS, 'text', oTextAttr));
        oTextAttr.y = iLegend4PositionY;
        oTextAttr.text = aLegend[3];
        oGrpELE.appendChild(MAQ.createSVGElement(sNS, 'text', oTextAttr));
    }
    var sFormattedRev = '',
        sNonFormattedRev = '',
        sFormattedOppty = '',
        iTrend, fRev = 0,
        fPrevRev = 0,
        iDashedLinePosition, iFixedY = iCurrentY,
        iFixedHeight = iCurrentHeight,
        iDashedLineHeight,
        oModifiedTile1,
        oModifiedTile2,
        pContentToBeShifted,
        sTopString,
        i, x1, x2,
        sTrendText,
        sToolTip,
        sConnectorPath;
    fRev = parseFloat(oSeries[1].data[0]);
    fPrevRev = parseFloat(oSeries[1].data[1]);
    if (isNaN(fRev)) {
        fRev = 0;
    }
    if (isNaN(fPrevRev)) {
        fPrevRev = 0;
    }
    iCurrentHeight = iFixedHeight * fRev / iMax;
    iDashedLineHeight = iFixedHeight * fPrevRev / iMax;
    if (iCurrentHeight < 13) {
        iCurrentHeight = 13;
    }
    if (iDashedLineHeight < 13) {
        iDashedLineHeight = 13;
    }
    iCurrentY = iFixedY + (iFixedHeight - iCurrentHeight) / 2;
    iDashedLinePosition = iFixedY + (iFixedHeight - iDashedLineHeight) / 2;
    if (isSafe(aLegend[3]) && oCurrentTileConfig.legendVisibility) {
        oGrpELE.appendChild(createTextTagForControl(sNS, '', sFontSize12, 0, iDashedLinePosition + iDashedLineHeight - 5, null, aLegend[3]));
        oGrpELE.appendChild(createPathTagForControl(sNS, '#2a2a2a', '6,2', 'M 0 ' + (iDashedLinePosition + iDashedLineHeight) + ' h ' + iStartingXPosition, ''));
    }
    for (iCount = 0; iCount < iTotalBars - 1; iCount += 1) {
        sDrillUrl = RowLabels[iCount + 1];
        oModifiedTile1 = oSeries[iCount].data[0];
        oModifiedTile2 = oSeries[iCount].data[2];
        if (oModifiedTile1 !== '' && oModifiedTile1 !== 0) {
            sFormattedRev = formatters.revenueFormatter(oModifiedTile1, 1);
            sNonFormattedRev = '$' + formatters.insertCommas(oModifiedTile1);
        } else {
            sFormattedRev = oModifiedTile1 === 0 ? '$0' : 'NA';
            sFormattedRev = oModifiedTile1 === 0 ? '$0' : 'NA';
        }
        sFormattedOppty = oModifiedTile1 !== '' && oModifiedTile2 !== 0 ? formatters.insertCommas(oModifiedTile2) : oModifiedTile2 === 0 ? '0' : 'NA';
        pContentToBeShifted = RowLabels[iCount + 1].trim().split(' ');
        if (pContentToBeShifted.length === 1) {
            oGrpELE.appendChild(createTextTagForControl(sNS, '', sFontSize12, iStartingXPosition, iLabelPosition + 5, null, pContentToBeShifted));
        } else {
            sTopString = '';
            for (i = 0; i < pContentToBeShifted.length - 1; i += 1) {
                sTopString += pContentToBeShifted[i] + ' ';
            }
            oGrpELE.appendChild(createTextTagForControl(sNS, '', sFontSize12, iStartingXPosition, iLabelPosition + 5, null, sTopString));
            oGrpELE.appendChild(createTextTagForControl(sNS, '', sFontSize12, iStartingXPosition, iLabelPosition + 5 + 12, null, pContentToBeShifted[pContentToBeShifted.length - 1]));
        }
        oGrpELE.appendChild(createTextTagForControl(sNS, '', sFontSize20, iStartingXPosition, iLegend1PositionY + 10, null, sFormattedRev));
        oGrpELE.appendChild(createTextTagForControl(sNS, 'HyperLinkedText', sFontSize12, iStartingXPosition, iLegend3PositionY, sDrillUrl, sFormattedOppty));
        oGrpELE.appendChild(createRectTagForControl(sNS, {
            fill: '#f1f1f1',
            'stroke-width': 0
        }, iStartingXPosition, iStartingYPosition, iMaxRectSize, iMaxHeight, '', ''));
        if (sFormattedRev !== 'NA' && sFormattedRev !== '$0') {
            sToolTip = oCurrentTileConfig.legends[0] + ': ' + sNonFormattedRev.split('$').join(sDollar) + '<br/>' + oCurrentTileConfig.legends[1] + ': ' + sFormattedOppty;
            oGrpELE.appendChild(createRectTagForControl(sNS, {
                fill: '#' + oCurrentTileConfig.color[iColorCount],
                'stroke-width': 0
            }, iStartingXPosition, iCurrentY, iMaxRectSize, iCurrentHeight, 'BarMainPart', sToolTip)); // Adding background grey for each bars
        }
        iColorCount += 1;
        iPrevHeight = iCurrentHeight;
        iPrevY = iCurrentY;
        if (fPrevRev > fRev) {
            oGrpELE.appendChild(createPathTagForControl(sNS, '#2a2a2a', '6,2', 'M ' + iStartingXPosition.toFixed(4) + ' ' + iDashedLinePosition.toFixed(4) + ' h ' + iMaxRectSize, ''));
            oGrpELE.appendChild(createPathTagForControl(sNS, '#2a2a2a', '6,2', 'M ' + iStartingXPosition.toFixed(4) + ' ' + (iDashedLinePosition + iDashedLineHeight).toFixed(4) + ' h ' + iMaxRectSize, ''));
        } else {
            oGrpELE.appendChild(createPathTagForControl(sNS, '#fff', '6,2', 'M ' + iStartingXPosition.toFixed(4) + ' ' + iDashedLinePosition.toFixed(4) + ' h ' + iMaxRectSize, ''));
            oGrpELE.appendChild(createPathTagForControl(sNS, '#fff', '6,2', 'M ' + iStartingXPosition.toFixed(4) + ' ' + (iDashedLinePosition + iDashedLineHeight).toFixed(4) + ' h ' + iMaxRectSize, ''));
        }
        if (iCount + 1 < iTotalBars - 1) {
            fRev = parseFloat(oSeries[iCount + 1].data[0]);
            fPrevRev = parseFloat(oSeries[iCount + 1].data[1]);
            if (isNaN(fRev)) {
                fRev = 0;
            }
            if (isNaN(fPrevRev)) {
                fPrevRev = 0;
            }
            iCurrentHeight = iFixedHeight * fRev / iMax;
            if (iCurrentHeight < 13) {
                iCurrentHeight = 13;
            }
            if (iDashedLineHeight < 13) {
                iDashedLineHeight = 13;
            }
            iCurrentY = iFixedY + (iFixedHeight - iCurrentHeight) / 2;
            iDashedLineHeight = iFixedHeight * fPrevRev / iMax;
            iDashedLinePosition = iFixedY + (iFixedHeight - iDashedLineHeight) / 2;
        }
        iTrend = parseFloat(oSeries[iCount].data[3]);
        if (isNaN(iTrend)) {
            iTrend = '';
        }
        sTrendText = iTrend === '' ? 'NA' : iTrend === 0 ? '0%' : (iTrend < 0 ? '-' : '') + formatters.addPercent(iTrend < 0 ? -iTrend : iTrend);
        // iGap += 8;
        oGrpELE.appendChild(createTextTagForControl(sNS, '', sFontSize12, iStartingXPosition, iLegend4PositionY, null, sTrendText));
        if (oCurrentTileConfig.connector && iCount < iTotalBars - 1 && !isNaN(fRev)) {
            // Adding background grey for each bars
            oGrpELE.appendChild(createRectTagForControl(sNS, {
                fill: '#f1f1f1',
                'stroke-width': 0
            }, iStartingXPosition + iMaxRectSize + 10, iStartingYPosition, iConnectorSize, iMaxHeight, '', ''));
            x1 = iStartingXPosition + iMaxRectSize + 10;
            x2 = x1 + iConnectorSize;
            if (sFormattedRev !== 'NA' && sFormattedRev !== '$0') {
                sConnectorPath = 'M' + x1 + ' ' + iPrevY + ' ' + ' L' + x2 + ' ' + iCurrentY + ' L' + x2 + ' ' + (iCurrentY + iCurrentHeight) + ' L' + x1 + ' ' + (iPrevY + iPrevHeight);
                iColorCount += 1;
                oGrpELE.appendChild(createPathTagForControl(sNS, '#fff', '', sConnectorPath, {
                    fill: '#' + oCurrentTileConfig.color[iColorCount],
                    'stroke-width': 0
                }));
            }
            iStartingXPosition = iStartingXPosition + iConnectorSize;
        }
        iStartingXPosition += 2 * iGapBetweenRects + iMaxRectSize;
    }
    chartConfigOptions.svgELE.appendChild(oGrpELE);
};
/*
MAQ.createBubbleChart: Renders bubble chart
@param {chartConfigOptions} user configuration parameters
*/
MAQ.createBubbleChart = function(chartConfigOptions) {
    'use strict';
    MAQ.drawLegend(chartConfigOptions);
    MAQ.drawXAxisTitle(chartConfigOptions);
    MAQ.drawYAxisTitle(chartConfigOptions);
    MAQ.applyMargin(chartConfigOptions, chartConfigOptions.chart.margin);
    var oDataInfoX = {
            min: 0,
            max: 1
        },
        oNormalizedDataXAxis;
    var oDataInfoY = {
            min: 0,
            max: 1
        },
        oNormalizedDataYAxis;
    var oBubblePlotOptions = chartConfigOptions.plotOptions.bubble;
    var oSeries = chartConfigOptions.series;
    var iSeriesCounter = 0;
    var iSeriesLength = oSeries.length;
    var iCounter = 0;
    var iLength = 0;

    function getRadius() {
        return oBubblePlotOptions.radius;
    }
    for (iSeriesCounter = 0; iSeriesCounter < iSeriesLength; iSeriesCounter += 1) {
        if (isSeriesEnabled(oSeries, iSeriesCounter)) {
            oDataInfoX = MAQ.getMinMax(oSeries[iSeriesCounter].data.scaleX, oDataInfoX.min, oDataInfoX.max);
            oDataInfoY = MAQ.getMinMax(oSeries[iSeriesCounter].data.scaleY, oDataInfoY.min, oDataInfoY.max);
        }
        if (oBubblePlotOptions.consistentBubble === true) {
            oSeries[iSeriesCounter].data.radius = oSeries[iSeriesCounter].data.radius.map(getRadius);
        }
    }
    oBubblePlotOptions.bubbles = [];
    if (oDataInfoX.max && oDataInfoY.max) {
        if ((chartConfigOptions.yAxis.minVal || 0 === chartConfigOptions.yAxis.minVal) && chartConfigOptions.yAxis.maxVal) {
            oNormalizedDataYAxis = {
                min: chartConfigOptions.yAxis.minVal,
                max: chartConfigOptions.yAxis.maxVal
            };
            oNormalizedDataYAxis.interval = (oNormalizedDataYAxis.max - oNormalizedDataYAxis.min) / chartConfigOptions.yAxis.numberOfGridLines;
        } else {
            oNormalizedDataYAxis = MAQ.getNormalized_Min_Max_Interval(oDataInfoY.min, oDataInfoY.max, chartConfigOptions.yAxis.numberOfGridLines);
        }
        oNormalizedDataXAxis = MAQ.getNormalized_Min_Max_Interval(oDataInfoX.min, oDataInfoX.max, chartConfigOptions.xAxis.numberOfGridLines);
        oNormalizedDataXAxis.sum = oNormalizedDataXAxis.max + Math.abs(oNormalizedDataXAxis.min);
        oNormalizedDataYAxis.sum = oNormalizedDataYAxis.max + Math.abs(oNormalizedDataYAxis.min);
        var oxAxisSeries = [];
        chartConfigOptions.xAxis.labels.series = [];
        var iStartX = oNormalizedDataXAxis.min,
            numberParts;
        iLength = oNormalizedDataXAxis.sum / oNormalizedDataXAxis.interval;
        for (iCounter = 0; iCounter <= iLength; iCounter += 1) {
            numberParts = iStartX.toString().split('.');
            if (numberParts[1] && numberParts[1].length > 2) {
                oxAxisSeries.push(iStartX.toFixed(2));
            } else {
                oxAxisSeries.push(iStartX);
            }
            iStartX += oNormalizedDataXAxis.interval;
        }
        chartConfigOptions.plotOptions.bubble.normalizedData = oNormalizedDataYAxis;
        MAQ.drawAxis(chartConfigOptions);
        chartConfigOptions.availWidth += chartConfigOptions.plotIntervalWidth;
        var oClipAttr = {
            id: 'myclippath'
        };
        var oGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'clipPath', oClipAttr);
        var oClipRectAttr = {
            x: 0,
            y: 0,
            width: chartConfigOptions.availWidth,
            height: chartConfigOptions.availHeight
        };
        oGrpELE.appendChild(MAQ.createSVGElement(chartConfigOptions.svgNS, 'rect', oClipRectAttr));
        chartConfigOptions.svgELE.appendChild(oGrpELE);
        var oAttr = {
            class: 'MAQCharts-plotArea',
            transform: 'translate(' + chartConfigOptions.availX + ',' + chartConfigOptions.availY + ')',
            opacity: 0,
            'clip-path': 'url(#myclippath)'
        };
        oGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
        chartConfigOptions.svgELE.appendChild(oGrpELE);
        var iHeightFactor = chartConfigOptions.availHeight / (Math.abs(oNormalizedDataYAxis.min) + oNormalizedDataYAxis.max);
        var iWidthFactor = chartConfigOptions.availWidth / (Math.abs(oNormalizedDataXAxis.min) + oNormalizedDataXAxis.max);
        var iZeroXAxis = oNormalizedDataXAxis.min / oNormalizedDataXAxis.sum * chartConfigOptions.availWidth;
        iZeroXAxis = Math.abs(iZeroXAxis);
        var iZeroYAxis = oNormalizedDataYAxis.max / oNormalizedDataYAxis.sum * chartConfigOptions.availHeight;
        var oBubbleAttr = {
                cx: 0,
                cy: 0,
                r: 0,
                fill: '#0066CC',
                opacity: oBubblePlotOptions.opacity,
                stroke: oBubblePlotOptions.borderColor,
                'stroke-width': oBubblePlotOptions.borderWidth,
                'stroke-dasharray': MAQ.computeStrokeDashStyle(oBubblePlotOptions.borderDashStyle)
            },
            oGrpBubbleChart, oDataArray, iXcord, iYcord, height, width, oBubble, oParam, oToolTip;
        for (iSeriesCounter = 0; iSeriesCounter < iSeriesLength; iSeriesCounter += 1) {
            oAttr = {
                class: 'MAQCharts-plotArea-bubbleChart-' + (iSeriesCounter + 1)
            };
            oGrpBubbleChart = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
            oGrpELE.appendChild(oGrpBubbleChart);
            oBubblePlotOptions.bubbles.push(oGrpBubbleChart);
            if (oBubblePlotOptions.color[iSeriesCounter]) {
                oBubbleAttr.fill = oBubblePlotOptions.color[iSeriesCounter];
                oBubbleAttr.stroke = oBubblePlotOptions.color[iSeriesCounter];
            } else {
                oBubbleAttr.fill = oBubblePlotOptions.color[iSeriesCounter % oBubblePlotOptions.color.length];
                oBubbleAttr.stroke = oBubblePlotOptions.color[iSeriesCounter % oBubblePlotOptions.color.length];
            }
            oDataArray = oSeries[iSeriesCounter].data;
            iLength = oDataArray.scaleX.length;
            iXcord = 0;
            iYcord = 0;
            for (iCounter = 0; iCounter < iLength; iCounter += 1) {
                if (isSeriesEnabled(oSeries, iSeriesCounter)) {
                    height = iHeightFactor * Math.abs(oDataArray.scaleY[iCounter]);
                    width = iWidthFactor * Math.abs(oDataArray.scaleX[iCounter]);
                    iYcord = iZeroYAxis - height;
                    if (oDataArray.scaleY[iCounter] < 0) {
                        iYcord = iYcord + 2 * height;
                    }
                    if (oDataArray.scaleX[iCounter] >= 0) {
                        iXcord = iZeroXAxis + width;
                    } else {
                        iXcord = iZeroXAxis - width;
                    }
                    if (iSeriesLength === 1) {
                        if (oBubblePlotOptions.color[iCounter]) {
                            oBubbleAttr.fill = oBubblePlotOptions.color[iCounter];
                            oBubbleAttr.stroke = oBubblePlotOptions.color[iCounter];
                        } else {
                            oBubbleAttr.fill = oBubblePlotOptions.color[iCounter % oBubblePlotOptions.color.length];
                            oBubbleAttr.stroke = oBubblePlotOptions.color[iCounter % oBubblePlotOptions.color.length];
                        }
                    }
                    oBubbleAttr.cx = Math.abs(iXcord);
                    oBubbleAttr.cy = iYcord;
                    oBubbleAttr.r = oDataArray.radius[iCounter];
                    oBubble = MAQ.createSVGElement(chartConfigOptions.svgNS, 'circle', oBubbleAttr);
                    oGrpBubbleChart.appendChild(oBubble);
                    oParam = {
                        seriesIndex: iSeriesCounter,
                        isPosavail: true,
                        position: iCounter,
                        config: chartConfigOptions
                    };
                    if (chartConfigOptions.tooltip.enabled) {
                        oToolTip = chartConfigOptions.tooltipDiv;
                        MAQ.addEventListener(oBubble, 'mousemove', showToolTip, oParam);
                        MAQ.addEventListener(oBubble, 'mouseout', hideToolTip, oToolTip);
                    }
                }
            }
        }
        MAQ.animateElement(oGrpELE, 'opacity', 1, 1000);
    }
};
/*
MAQ.createTimelineChart: Renders timeline chart
@param {chartConfigOptions} user configuration parameters
*/
MAQ.createTimelineChart = function(chartConfigOptions) {
    'use strict';
    chartConfigOptions.isTimeLineChart = true;
    var iLength = chartConfigOptions.timeline.series.length;
    var iNumberOfLabels = chartConfigOptions.plotOptions.timeline.xAxisLabelCount;
    var iSkip = Math.round(iLength / iNumberOfLabels);
    chartConfigOptions.chart.type = 'area';
    chartConfigOptions.xAxis.skipInterval = iSkip;
    var oPattern = chartConfigOptions.plotOptions.pattern.slice(0);
    chartConfigOptions.plotOptions.pattern = [];
    chartConfigOptions.plotOptions.line.stepLine = chartConfigOptions.plotOptions.timeline.stepLine;
    chartConfigOptions.plotOptions.pattern = oPattern;
    if (undefined !== chartConfigOptions.plotOptions.timeline.color[0]) {
        chartConfigOptions.plotOptions.area.color = chartConfigOptions.plotOptions.timeline.color;
    }
    if (undefined !== chartConfigOptions.plotOptions.timeline.strokes[0]) {
        chartConfigOptions.plotOptions.area.strokes = chartConfigOptions.plotOptions.timeline.strokes;
    }
    chartConfigOptions.plotOptions.area.opacity = chartConfigOptions.plotOptions.timeline.opacity;
    chartConfigOptions.plotOptions.area.lineWidth = chartConfigOptions.plotOptions.timeline.lineWidth;
    chartConfigOptions.plotOptions.area.lineDashStyle = chartConfigOptions.plotOptions.timeline.lineDashStyle;
    chartConfigOptions.plotOptions.area.marker = chartConfigOptions.plotOptions.timeline.marker;
    MAQ.createAreaChart(chartConfigOptions);
    chartConfigOptions.isTimeLineChart = true;
    chartConfigOptions.chart.type = 'timeline';
};
/*
MAQ.addEventListener: Attaches code to object's event
@param {oELE} object to attach event
@param {sEventName} event name
@param {sFunctionName} function name
@param {oParam} parameters object
*/
MAQ.addEventListener = function(oELE, sEventName, sFunctionName, oParam) {
    'use strict';
    if ('string' === typeof sFunctionName && 'function' === typeof window[sFunctionName]) {
        oELE.addEventListener(sEventName, function(event) {
            window[sFunctionName](event, oParam);
        }, true);
    } else if ('function' === typeof sFunctionName) {
        oELE.addEventListener(sEventName, function(event) {
            sFunctionName(event, oParam);
        }, true);
    } else {
        console.log(sFunctionName + ' is not a function!');
    }
};
/*
MAQ.removeEventListener: Removes code from object's event
@param {oELE} object to attach event
@param {sEventName} event name
@param {sFunctionName} function name
@param {oParam} parameters object
*/
MAQ.removeEventListener = function(oELE, sEventName, sFunctionName, oParam) {
    'use strict';
    oELE.removeEventListener(sEventName, function(event) {
        window[sFunctionName](event, oParam);
    }, true);
};
/*
MAQ.getDataIndexPosition: Gets the current data index based on mouse pointer position on SVG
@param {oSVGCord} SVG coordinates
@param {oCalCord} Calculated coordinates
@param {fInterval} step interval on x axis
*/
MAQ.getDataIndexPosition = function(oSVGCord, oCalCord, fInterval) {
    'use strict';
    var fPt1 = oSVGCord.x - fInterval,
        fPt2 = oSVGCord.x + fInterval,
        oFilterData = oCalCord.filter(function(x) {
            return x > fPt1 && x < fPt2;
        });
    if (oFilterData.length === 1) {
        return oCalCord.indexOf(oFilterData[0]);
    } else {
        fPt1 = oSVGCord.x - oFilterData[0];
        fPt2 = oFilterData[1] - oSVGCord.x;
        if (fPt1 < fPt2) {
            return oCalCord.indexOf(oFilterData[0]);
        } else {
            return oCalCord.indexOf(oFilterData[1]);
        }
    }
};
/*
MAQ.createSpiderWebChart: Renders spider web chart
@param {chartConfigOptions} user configuration parameters
*/
MAQ.createSpiderWebChart = function(chartConfigOptions) {
    'use strict';
    var oSeries = chartConfigOptions.series;
    MAQ.drawLegend(chartConfigOptions);
    MAQ.applyMargin(chartConfigOptions, chartConfigOptions.chart.margin);
    var iCounter = 0,
        iLength = oSeries.length,
        oDataInfo = [],
        iGlobalMax = 1,
        oAttr,
        oGrpELE;
    for (iCounter = 0; iCounter < iLength; iCounter += 1) {
        oDataInfo[iCounter] = {
            min: 0,
            max: 1
        };
    }
    for (iCounter = 0; iCounter < iLength; iCounter += 1) {
        if (isSeriesEnabled(oSeries, iCounter)) {
            oDataInfo[iCounter] = MAQ.getMinMax(oSeries[iCounter].data, oDataInfo[iCounter].min, oDataInfo[iCounter].max);
            iGlobalMax = iGlobalMax < oDataInfo[iCounter].max ? oDataInfo[iCounter].max : iGlobalMax;
        }
    }
    oAttr = {
        class: 'MAQCharts-plotArea',
        transform: 'translate(' + chartConfigOptions.availX + ',' + chartConfigOptions.availY + ')',
        opacity: 0
    };
    oGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    chartConfigOptions.svgELE.appendChild(oGrpELE);
    if (iGlobalMax > 0) {
        var fAvailHeight = chartConfigOptions.availHeight,
            fAvailWidth = chartConfigOptions.availWidth,
            fCenterX = fAvailWidth / 2,
            fCenterY = fAvailHeight / 2;
        var fRadius = Math.min(fAvailHeight, fAvailWidth) / 2;
        fRadius = fRadius * 0.7;
        MAQ.addAttr(oGrpELE, 'transform', 'translate(' + (chartConfigOptions.availX + fCenterX) + ', ' + (chartConfigOptions.availY + fCenterY) + ')');
        var oPiePlotOptions = chartConfigOptions.plotOptions.spiderweb;
        var oPathAttr = {
            r: 0,
            cx: 0,
            cy: 0,
            fill: 'none',
            stroke: '#ebebeb',
            'stroke-width': oPiePlotOptions.lineWidth
        };
        var oCircle, oCircleGroupAttr = {
                class: 'bgCircleGroup'
            },
            oCircleGroup = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oCircleGroupAttr);
        var iCount;
        oGrpELE.appendChild(oCircleGroup);
        for (iCount = oPiePlotOptions.axis.numberOfGridLines; iCount >= 0; iCount -= 1) {
            oPathAttr.r = fRadius * iCount / oPiePlotOptions.axis.numberOfGridLines;
            oCircle = MAQ.createSVGElement(chartConfigOptions.svgNS, 'circle', oPathAttr);
            oCircleGroup.appendChild(oCircle);
        }
        var fDegree = 0,
            xPos = 0,
            yPos = 0;
        oPiePlotOptions.degrees = [];
        var numOfAxis = oPiePlotOptions.axis.labels.series.length;
        var fIncrementDegree = 2 * Math.PI / numOfAxis;
        var oAxisGroupAttr = {
            class: 'bgAxisGroup'
        };
        var oAxisGroup = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAxisGroupAttr);
        oGrpELE.appendChild(oAxisGroup);
        var oSpiderLineAttr = {
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
                stroke: oPiePlotOptions.axis.lineColor,
                'stroke-width': oPiePlotOptions.axis.lineWidth
            },
            oSpiderLine,
            oSpiderLabelStyles,
            oSpiderLabel,
            oTextNode,
            oLabelBox;
        fRadius += 10;
        for (iCount = 0; iCount < numOfAxis; iCount += 1) {
            oSpiderLineAttr.x2 = fRadius * Math.sin(fDegree);
            oSpiderLineAttr.y2 = -fRadius * Math.cos(fDegree);
            oSpiderLine = MAQ.createSVGElement(chartConfigOptions.svgNS, 'line', oSpiderLineAttr);
            oAxisGroup.appendChild(oSpiderLine);
            oSpiderLabelStyles = {
                x: (fRadius + 5) * Math.sin(fDegree),
                y: -(fRadius + 5) * Math.cos(fDegree),
                style: oPiePlotOptions.axis.labels.style
            };
            oSpiderLabel = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oSpiderLabelStyles);
            oTextNode = document.createTextNode(oPiePlotOptions.axis.labels.series[iCount]);
            oSpiderLabel.appendChild(oTextNode);
            oAxisGroup.appendChild(oSpiderLabel);
            oLabelBox = oSpiderLabel.getBBox();
            if (3 < Math.abs(fDegree - Math.PI) || 1 > Math.abs(fDegree - Math.PI)) {
                MAQ.addAttr(oSpiderLabel, 'dx', -oLabelBox.width / 2 - 3);
            } else if (oSpiderLabelStyles.x > 0) {
                MAQ.addAttr(oSpiderLabel, 'dx', 3);
            } else {
                MAQ.addAttr(oSpiderLabel, 'dx', -oLabelBox.width - 3);
            }
            if (oSpiderLabelStyles.y < 0) {
                MAQ.addAttr(oSpiderLabel, 'dy', 2);
            } else {
                MAQ.addAttr(oSpiderLabel, 'dy', oLabelBox.height / 2 - 2);
            }
            fDegree += fIncrementDegree;
        }
        var oCurrentSeries, iCurrentSeriesLength, i, oSpiderPathAttr, oSpiderPath, oSpiderPathPointAttr, oSpiderPathPoint, iSeriesIndex, oParam, oToolTip;
        fRadius -= 10;
        for (i = 0; i < iLength; i += 1) {
            if (isSeriesEnabled(oSeries, i)) {
                oCurrentSeries = oSeries[i].data;
                iCurrentSeriesLength = oCurrentSeries.length;
                oSpiderPathAttr = {
                    d: '',
                    fill: 'none',
                    stroke: oPiePlotOptions.color[i],
                    'stroke-width': oPiePlotOptions.lineWidth
                };
                oSpiderPathPointAttr = {
                    cx: '',
                    cy: '',
                    r: '2.5',
                    fill: oPiePlotOptions.color[i],
                    stroke: oPiePlotOptions.color[i],
                    'stroke-width': '1'
                };
                fDegree = 0;
                for (iSeriesIndex = 0; iSeriesIndex < iCurrentSeriesLength; iSeriesIndex += 1) {
                    xPos = oCurrentSeries[iSeriesIndex] / oDataInfo[i].max * fRadius * Math.sin(fDegree);
                    yPos = -oCurrentSeries[iSeriesIndex] / oDataInfo[i].max * fRadius * Math.cos(fDegree);
                    if (!iSeriesIndex) {
                        oSpiderPathAttr.d = 'M ' + xPos + ',' + yPos;
                    } else {
                        oSpiderPathAttr.d += ' L ' + xPos + ',' + yPos;
                    }
                    fDegree += fIncrementDegree;
                    oSpiderPathPointAttr.cx = xPos;
                    oSpiderPathPointAttr.cy = yPos;
                    oSpiderPathPoint = MAQ.createSVGElement(chartConfigOptions.svgNS, 'circle', oSpiderPathPointAttr);
                    oGrpELE.appendChild(oSpiderPathPoint);
                }
                oSpiderPathAttr.d += ' z';
                oSpiderPath = MAQ.createSVGElement(chartConfigOptions.svgNS, 'path', oSpiderPathAttr);
                oGrpELE.appendChild(oSpiderPath);
                oParam = {
                    seriesIndex: i,
                    isPosavail: true,
                    position: 0,
                    config: chartConfigOptions
                };
                if (chartConfigOptions.tooltip.enabled) {
                    oToolTip = chartConfigOptions.tooltipDiv;
                    MAQ.addEventListener(oSpiderPath, 'mousemove', showToolTip, oParam);
                    MAQ.addEventListener(oSpiderPath, 'mouseout', hideToolTip, oToolTip);
                }
            }
        }
        MAQ.animateElement(oGrpELE, 'opacity', 1, 2500);
    }
};
/*
MAQ.createComboLineColumnChart: Renders combo line column chart
@param {chartConfigOptions} user configuration parameters
*/
MAQ.createComboLineColumnChart = function(chartConfigOptions) {
    'use strict';
    var oSeries = chartConfigOptions.series;
    MAQ.drawLegend(chartConfigOptions);
    MAQ.drawXAxisTitle(chartConfigOptions);
    MAQ.drawYAxisTitle(chartConfigOptions);
    MAQ.applyMargin(chartConfigOptions, chartConfigOptions.chart.margin);
    var oColumnPlotOptions = chartConfigOptions.plotOptions.combolinecolumn.column;
    var iCounter = 0,
        iSeriesLength = oSeries.length,
        iBarSeriesLength = 0,
        iLength,
        oNYCord,
        oYCord,
        //variables for multiStacked column chart
        iBarsPerUnit = 1,
        aTransSeries = [];
    if (oColumnPlotOptions.multiStacked) {
        //no. of bars per time unit
        iBarsPerUnit = oSeries[0].data.length;
        //convert the multi stacked column data format to a linear data format
        //transform the data array into linear arrays
        //this will help calculate the stacked column y values for height
        //now for each rows in the data array (loop)
        //create a new series object with one data row each from the data arrays
        //continue drawing the chart as if it were a stacked column chart but with width = width/no of rows in data array
        //then retransform to original state to allow the legends on off to work
        aTransSeries = [];
        for (iCounter = 0; iCounter < iSeriesLength; iCounter += 1) {
            aTransSeries[iCounter] = {};
            aTransSeries[iCounter].name = oSeries[iCounter].name;
            aTransSeries[iCounter].type = oSeries[iCounter].type;
            aTransSeries[iCounter].xAxis = oSeries[iCounter].xAxis;
            aTransSeries[iCounter].yAxis = oSeries[iCounter].yAxis;
            aTransSeries[iCounter].enabled = oSeries[iCounter].enabled;
            aTransSeries[iCounter].data = MAQ.utils.toLinear(MAQ.utils.pivotArray(oSeries[iCounter].data));
        }
        oSeries = aTransSeries;
    }
    var oDataInfoSeriesLeft = {
            min: 0,
            max: 1
        },
        oDataInfoSeriesRight = {
            min: 0,
            max: 1
        },
        iSeriesCounter;
    for (iSeriesCounter = 0; iSeriesCounter < iSeriesLength; iSeriesCounter += 1) {
        if (isSeriesEnabled(oSeries, iSeriesCounter) && !oSeries[iSeriesCounter].data[0].length) {
            switch (oSeries[iSeriesCounter].yAxis) {
                case 1:
                    oDataInfoSeriesLeft = MAQ.getMinMax(oSeries[iSeriesCounter].data, oDataInfoSeriesLeft.min, oDataInfoSeriesLeft.max, 'data');
                    break;
                case 2:
                    oDataInfoSeriesRight = MAQ.getMinMax(oSeries[iSeriesCounter].data, oDataInfoSeriesRight.min, oDataInfoSeriesRight.max, 'data');
                    break;
            }
        }
        if (oSeries[iSeriesCounter].type === 'bar') {
            iBarSeriesLength += 1;
        }
    }
    chartConfigOptions.series.label = chartConfigOptions.xAxis.labels.series;
    if (oColumnPlotOptions.stacked) {
        var oMin = oSeries[0].data.map(function(x) {
            return x - x;
        });
        var oMax = oMin.slice(0),
            i = 0,
            j = 0;
        oYCord = oMin.slice(0);
        oNYCord = oMin.slice(0);
        if (oColumnPlotOptions.multiStacked) {
            iLength = aTransSeries[0].data.length;
        } else {
            iLength = chartConfigOptions.series.label.length;
        }
        for (i = 0; i < iLength; i += 1) {
            for (j = 0; j < iSeriesLength; j += 1) {
                if (oSeries[j].yAxis === 1) {
                    if (isSeriesEnabled(oSeries, j)) {
                        if (oSeries[j].type === 'bar') {
                            if (oSeries[j].data[i] < 0) {
                                oMin[i] += oSeries[j].data[i];
                            }
                            if (oSeries[j].data[i] >= 0) {
                                oMax[i] += oSeries[j].data[i];
                            }
                        } else if (oSeries[j].type === 'line') {
                            if (oSeries[j].data[i] < 0) {
                                oMin[i] = oMin[i] > oSeries[j].data[i] ? oSeries[j].data[i] : oMin[i];
                            } else if (oSeries[j].data[i] >= 0) {
                                oMax[i] = oMax[i] < oSeries[j].data[i] ? oSeries[j].data[i] : oMax[i];
                            }
                        }
                    }
                }
            }
        }
        var oConcatArr = oMax.concat(oMin),
            iCount;
        oDataInfoSeriesLeft.min = Math.min.apply(null, oConcatArr);
        oDataInfoSeriesLeft.max = Math.max.apply(null, oConcatArr);
        oDataInfoSeriesLeft.max = 0 === oDataInfoSeriesLeft.max ? 1 : oDataInfoSeriesLeft.max;
        oDataInfoSeriesLeft.total = 0;
        for (iCount = 0; iCount < oConcatArr.length; iCount += 1) {
            oDataInfoSeriesLeft.total += oConcatArr[iCount];
        }
    }
    var oNormalizedDataY1, oNormalizedDataY2;
    /* Calculate normalized min/ max values */
    chartConfigOptions.plotOptions.combolinecolumn.normalizedData = [];
    if (oDataInfoSeriesLeft.min || oDataInfoSeriesLeft.max) {
        oNormalizedDataY1 = MAQ.getNormalized_Min_Max_Interval(oDataInfoSeriesLeft.min, oDataInfoSeriesLeft.max, chartConfigOptions.yAxis.numberOfGridLines);
        oNormalizedDataY1.sum = oNormalizedDataY1.max + Math.abs(oNormalizedDataY1.min);
        chartConfigOptions.plotOptions.combolinecolumn.normalizedData[0] = oNormalizedDataY1;
    }
    if (oDataInfoSeriesRight.min || oDataInfoSeriesRight.max) {
        oNormalizedDataY2 = MAQ.getNormalized_Min_Max_Interval(oDataInfoSeriesRight.min, oDataInfoSeriesRight.max, chartConfigOptions.yAxis.dualyAxis.numberOfGridLines);
        oNormalizedDataY2.sum = oNormalizedDataY2.max + Math.abs(oNormalizedDataY2.min);
        chartConfigOptions.plotOptions.combolinecolumn.normalizedData[1] = oNormalizedDataY2;
    }
    if (oColumnPlotOptions.multiStacked) {
        //store reference to original series in oSeries
        oSeries = chartConfigOptions.series;
        for (iCounter = 0; iCounter < iSeriesLength; iCounter += 1) {
            aTransSeries[iCounter].data = oSeries[iCounter].data[0];
        }
        //point original reference to transformed series
        chartConfigOptions.series = aTransSeries;
    }
    MAQ.drawSecondaryYAxis(chartConfigOptions);
    if (oColumnPlotOptions.multiStacked) {
        //point original reference back to original series
        chartConfigOptions.series = oSeries;
    }
    var oAttr = {
        class: 'MAQCharts-plotArea',
        transform: 'translate(' + chartConfigOptions.availX + ',' + chartConfigOptions.availY + ')'
    };
    var oGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    chartConfigOptions.svgELE.appendChild(oGrpELE);
    /* Column chart properties */
    var oBarWidth = chartConfigOptions.plotIntervalWidth - oColumnPlotOptions.padding;
    if (oColumnPlotOptions.multiStacked) {
        oBarWidth = oBarWidth / iBarsPerUnit;
    }
    var fGrpPadding = oColumnPlotOptions.groupPadding;
    if (fGrpPadding < 0) {
        fGrpPadding = 0;
    }
    if (fGrpPadding > 100) {
        fGrpPadding = 100;
    }
    fGrpPadding = fGrpPadding / 100 * oBarWidth;
    if (!oColumnPlotOptions.stacked) {
        oBarWidth = oBarWidth - fGrpPadding * (iBarSeriesLength - 1);
    }
    var iMultiplier = 1;
    if (oColumnPlotOptions.multiStacked) {
        iMultiplier = iBarsPerUnit;
    }
    var iInnerPadding = oColumnPlotOptions.innerPadding || 0;
    MAQ.addAttr(chartConfigOptions.xLabels, 'transform', 'translate(' + (oBarWidth * iMultiplier / 2 + fGrpPadding) + ', 0)');
    MAQ.addAttr(chartConfigOptions.xInnerLabels, 'transform', 'translate(' + (oBarWidth / 2 + fGrpPadding - iInnerPadding) + ', 0)');
    if (!oColumnPlotOptions.stacked) {
        oBarWidth = oColumnPlotOptions.fixedWidth || oBarWidth / iBarSeriesLength;
    }
    var oRectAttr = {
        x: 0,
        y: 0,
        rx: oColumnPlotOptions.borderRadius,
        ry: oColumnPlotOptions.borderRadius,
        width: oBarWidth,
        height: 0,
        fill: '',
        'z-index': 5,
        opacity: oColumnPlotOptions.opacity,
        stroke: oColumnPlotOptions.borderColor,
        'stroke-width': oColumnPlotOptions.borderWidth,
        'stroke-dasharray': MAQ.computeStrokeDashStyle(oColumnPlotOptions.borderDashStyle)
    };
    if (oColumnPlotOptions.multiStacked) {
        oRectAttr.width = Math.max(oBarWidth - iInnerPadding, 2);
    }
    var oValueBoxAttr = {
        x: 0,
        y: 0,
        text: null,
        'text-anchor': 'middle',
        style: oColumnPlotOptions.valueBox.style
    };
    /* Line chart properties */
    var oLinePlotOptions = chartConfigOptions.plotOptions.combolinecolumn.line;
    var oMarker = oLinePlotOptions.marker;
    var bShowMarker = oMarker.enabled;
    var oCircleAttr;
    if (bShowMarker) {
        oCircleAttr = {
            cx: 0,
            cy: 0,
            r: oMarker.width,
            fill: oMarker.fillColor,
            'z-index': 10,
            stroke: oMarker.lineColor,
            'stroke-width': oMarker.lineWidth
        };
    }
    var bStepLine = oLinePlotOptions.stepLine,
        oParam = {},
        oDataArray, iSeriesBarCounter = 0,
        iHeightFactor = 0,
        iZeroAxis = 0,
        iXcord, iYcord, height, oToolTip, oTmpNYCord, oTmpYCord, jCounter, oGrpColumnChart, iNumberOfColors, oRect, oValueBox, oGrpLineChart, oPathAttr, oPath, oXcord, oYcord, oCircle;
    if (oColumnPlotOptions.multiStacked) {
        oTmpNYCord = oNYCord.slice(0);
        oTmpYCord = oYCord.slice(0);
    }
    for (jCounter = 0; jCounter < iBarsPerUnit; jCounter += 1) {
        //point oSeries to transformed series
        if (oColumnPlotOptions.multiStacked) {
            oSeries = aTransSeries;
        }
        iSeriesLength = oSeries.length;
        for (iSeriesCounter = 0; iSeriesCounter < iSeriesLength; iSeriesCounter += 1) {
            if (oSeries[iSeriesCounter].yAxis === 1) {
                iHeightFactor = chartConfigOptions.availHeight / (Math.abs(oNormalizedDataY1.min) + oNormalizedDataY1.max);
                iZeroAxis = oNormalizedDataY1.max / oNormalizedDataY1.sum * chartConfigOptions.availHeight;
            } else if (oSeries[iSeriesCounter].yAxis === 2) {
                iHeightFactor = chartConfigOptions.availHeight / (Math.abs(oNormalizedDataY2.min) + oNormalizedDataY2.max);
                iZeroAxis = oNormalizedDataY2.max / oNormalizedDataY2.sum * chartConfigOptions.availHeight;
            }
            if (isSeriesEnabled(oSeries, iSeriesCounter)) {
                if (oSeries[iSeriesCounter].type === 'bar') {
                    oAttr = {
                        class: 'MAQCharts-plotArea-columnChart-' + (iSeriesCounter + 1)
                    };
                    oGrpColumnChart = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
                    oGrpELE.appendChild(oGrpColumnChart);
                    oRectAttr.fill = oColumnPlotOptions.color[iSeriesCounter];
                    oDataArray = oSeries[iSeriesCounter];
                    iLength = oDataArray.data.length;
                    iXcord = 0;
                    iYcord = 0;
                    for (iCounter = 0; iCounter < iLength; iCounter += 1) {
                        height = iHeightFactor * Math.abs(oDataArray.data[iCounter]);
                        iYcord = iZeroAxis - height;
                        if (oDataArray.data[iCounter] < 0) {
                            iYcord = iZeroAxis;
                        }
                        if (!oColumnPlotOptions.stacked) {
                            oRectAttr.x = iXcord + (oBarWidth + fGrpPadding) * iSeriesBarCounter;
                            oRectAttr.y = iYcord;
                        } else if (oColumnPlotOptions.multiStacked) {
                            oRectAttr.x = iXcord + oBarWidth * jCounter;
                            if (oDataArray.data[iCounter] < 0) {
                                oRectAttr.y = iYcord + oNYCord[iCounter];
                                oNYCord[iCounter] += height;
                            } else {
                                oRectAttr.y = iYcord - oYCord[iCounter];
                                oYCord[iCounter] += height;
                            }
                        } else {
                            oRectAttr.x = iXcord;
                            if (oDataArray.data[iCounter] < 0) {
                                oRectAttr.y = iYcord + oNYCord[iCounter];
                                oNYCord[iCounter] += height;
                            } else {
                                oRectAttr.y = iYcord - oYCord[iCounter];
                                oYCord[iCounter] += height;
                            }
                        }
                        oRectAttr.height = height;
                        if (oColumnPlotOptions.multiColored) {
                            iNumberOfColors = oColumnPlotOptions.color.length;
                            oRectAttr.fill = oColumnPlotOptions.color[iCounter % iNumberOfColors];
                        }
                        //create bar
                        oRect = MAQ.createSVGElement(chartConfigOptions.svgNS, 'rect', oRectAttr);
                        oGrpColumnChart.appendChild(oRect);
                        //draw value box
                        if (oColumnPlotOptions.valueBox.enabled) {
                            oValueBoxAttr.x = oRectAttr.x + oRectAttr.width / 2;
                            if (oColumnPlotOptions.valueBox.position === 'middle') {
                                oValueBoxAttr.y = oRectAttr.y + oRectAttr.height / 2;
                            } else {
                                if (oRectAttr.y < 15) {
                                    oValueBoxAttr.y = 15;
                                } else if (oDataArray.data[iCounter] < 0) {
                                    if (chartConfigOptions.availHeight - (oRectAttr.y + oRectAttr.height) < 15) {
                                        oValueBoxAttr.y = oRectAttr.y + oRectAttr.height - 5;
                                    } else {
                                        oValueBoxAttr.y = oRectAttr.y + oRectAttr.height + 15;
                                    }
                                } else {
                                    oValueBoxAttr.y = oRectAttr.y - 5;
                                }
                            }
                            oValueBoxAttr.text = MAQ.applyFormatter(Math.round(oDataArray.data[iCounter] * 10) / 10, oColumnPlotOptions.valueBox.formatter);
                            oValueBox = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oValueBoxAttr);
                            oGrpColumnChart.appendChild(oValueBox);
                        }
                        oParam = {
                            seriesIndex: iSeriesCounter,
                            isPosavail: true,
                            position: iCounter,
                            config: chartConfigOptions
                        };
                        if (oColumnPlotOptions.multiStacked) {
                            oParam.rowIndex = jCounter;
                        }
                        if (chartConfigOptions.tooltip.enabled) {
                            oToolTip = chartConfigOptions.tooltipDiv;
                            MAQ.addEventListener(oRect, 'mousemove', showToolTip, oParam);
                            MAQ.addEventListener(oRect, 'mouseout', hideToolTip, oToolTip);
                        }
                        iXcord += chartConfigOptions.plotIntervalWidth;
                    }
                    iSeriesBarCounter += 1;
                } else if (oSeries[iSeriesCounter].type === 'line' && undefined !== oSeries[iSeriesCounter] && undefined !== oSeries[iSeriesCounter].data) {
                    oAttr = {
                        class: 'MAQCharts-plotArea-lineChart-' + (iSeriesCounter + 1)
                    };
                    oGrpLineChart = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
                    oGrpELE.appendChild(oGrpLineChart);
                    oPathAttr = {
                        d: '',
                        fill: 'transparent',
                        'z-index': 5,
                        'pointer-events': 'visibleStroke',
                        stroke: oLinePlotOptions.color[iSeriesCounter],
                        'stroke-width': oLinePlotOptions.lineWidth,
                        'stroke-dasharray': MAQ.computeStrokeDashStyle(oLinePlotOptions.lineDashStyle)
                    };
                    oPath = MAQ.createSVGElement(chartConfigOptions.svgNS, 'path', oPathAttr);
                    oGrpLineChart.appendChild(oPath);
                    oDataArray = oSeries[iSeriesCounter];
                    iLength = oDataArray.data.length;
                    iXcord = (chartConfigOptions.plotIntervalWidth - oColumnPlotOptions.padding) / 2;
                    iYcord = 0;
                    oXcord = [];
                    oYcord = [];
                    for (iCounter = 0; iCounter < iLength; iCounter += 1) {
                        height = iHeightFactor * Math.abs(oDataArray.data[iCounter]);
                        iYcord = iZeroAxis - height;
                        if (oDataArray.data[iCounter] < 0) {
                            iYcord = iYcord + 2 * height;
                        }
                        if (null !== oDataArray.data[iCounter] || oLinePlotOptions.nullValues !== 'ignore') {
                            if (iCounter > 0) {
                                if (bStepLine) {
                                    oPathAttr.d += ' H ' + iXcord + ' V ' + iYcord;
                                } else {
                                    if (oDataArray.data[iCounter - 1] !== null || oLinePlotOptions.nullValues !== 'ignore') {
                                        oPathAttr.d += ' L ' + iXcord + ',' + iYcord;
                                    } else {
                                        oPathAttr.d += 'M' + iXcord + ',' + iYcord;
                                    }
                                }
                            } else {
                                oPathAttr.d = 'M ' + iXcord + ',' + iYcord;
                            }
                            if (bShowMarker) {
                                if (!oMarker.lineColor) {
                                    oCircleAttr.stroke = oLinePlotOptions.color[iSeriesCounter];
                                }
                                if (!oMarker.fillColor) {
                                    oCircleAttr.fill = oLinePlotOptions.color[iSeriesCounter];
                                }
                                oCircleAttr.cx = iXcord;
                                oCircleAttr.cy = iYcord;
                                oCircle = MAQ.createSVGElement(chartConfigOptions.svgNS, 'circle', oCircleAttr);
                                oGrpLineChart.appendChild(oCircle);
                                oParam = {
                                    seriesIndex: iSeriesCounter,
                                    isPosavail: true,
                                    position: iCounter,
                                    config: chartConfigOptions
                                };
                                if (oColumnPlotOptions.multiStacked) {
                                    oParam.rowIndex = jCounter;
                                }
                                if (chartConfigOptions.tooltip.enabled) {
                                    oToolTip = chartConfigOptions.tooltipDiv;
                                    MAQ.addEventListener(oCircle, 'mouseover', showToolTip, oParam);
                                    MAQ.addEventListener(oCircle, 'mouseout', hideToolTip, oToolTip);
                                }
                            }
                        }
                        oXcord[iCounter] = iXcord + chartConfigOptions.availX;
                        oYcord[iCounter] = iYcord + chartConfigOptions.availY;
                        iXcord += chartConfigOptions.plotIntervalWidth;
                    }
                    if (oColumnPlotOptions.multiStacked) {
                        if (!chartConfigOptions.series[iSeriesCounter].xPos && !chartConfigOptions.series[iSeriesCounter].yPos) {
                            chartConfigOptions.series[iSeriesCounter].xPos = [];
                            chartConfigOptions.series[iSeriesCounter].yPos = [];
                        }
                        chartConfigOptions.series[iSeriesCounter].xPos[jCounter] = oXcord.slice(0);
                        chartConfigOptions.series[iSeriesCounter].yPos[jCounter] = oYcord.slice(0);
                    } else {
                        oDataArray.xPos = oXcord.slice(0);
                        oDataArray.yPos = oYcord.slice(0);
                    }
                    MAQ.addAttr(oPath, 'd', oPathAttr.d);
                    oParam = {
                        seriesIndex: iSeriesCounter,
                        isPosavail: false,
                        config: chartConfigOptions
                    };
                    if (oColumnPlotOptions.multiStacked) {
                        oParam.rowIndex = jCounter;
                    }
                    if (chartConfigOptions.tooltip.enabled) {
                        oToolTip = chartConfigOptions.tooltipDiv;
                        MAQ.addEventListener(oPath, 'mousemove', showToolTip, oParam);
                        MAQ.addEventListener(oPath, 'mouseout', hideToolTip, oToolTip);
                    }
                }
            }
        }
        if (oColumnPlotOptions.multiStacked) {
            oNYCord = oTmpNYCord.slice(0);
            oYCord = oTmpYCord.slice(0);
        }
        if (jCounter < iBarsPerUnit - 1) {
            for (iCounter = 0; iCounter < iSeriesLength; iCounter += 1) {
                if (undefined !== chartConfigOptions.series[iCounter].data[jCounter + 1]) {
                    aTransSeries[iCounter].data = chartConfigOptions.series[iCounter].data[jCounter + 1];
                } else {
                    aTransSeries[iCounter].data = undefined;
                }
            }
        }
    }
};
/*
MAQ.getMax: Gets maximum value
@param {array} array of values
*/
MAQ.getMax = function(array) {
    'use strict';
    return Math.max.apply(Math, array);
};
/*
MAQ.showToolTip: Gets maximum value
@param {array} array of values
*/
MAQ.getMin = function(array) {
    'use strict';
    return Math.min.apply(Math, array);
};
/*
MAQ.arraySum: Gets sum of values
@param {array} array of values
*/
MAQ.arraySum = function(array) {
    'use strict';
    var i = 0,
        L, sum = 0;
    for (L = array.length; i < L; i += 1) {
        sum += array[i];
    }
    return sum;
};
/* Time-Line functions*/
var bNavigatorDrag = false,
    bExpanderDrag = false,
    movingSource = '',
    sSelectedExpander = '',
    iCurrentNavigatorX;
/*
MAQ.formatDate: Date formatting function
@param {formatDate} input date
@param {formatString} format string
*/
MAQ.formatDate = function(formatDate, formatString) {
    'use strict';
    if (formatDate instanceof Date) {
        var months = [
            'Jan',
            'Feb',
            'Mar',
            'Apr',
            'May',
            'Jun',
            'Jul',
            'Aug',
            'Sep',
            'Oct',
            'Nov',
            'Dec'
        ];
        var yyyy = formatDate.getFullYear();
        var yy = yyyy.toString().substring(2);
        var m = formatDate.getMonth();
        var mm = m < 10 ? '0' + m : m;
        var mmm = months[m];
        var d = formatDate.getDate();
        var dd = d < 10 ? '0' + d : d;
        var h = formatDate.getHours();
        var hh = h < 10 ? '0' + h : h;
        var n = formatDate.getMinutes();
        var nn = n < 10 ? '0' + n : n;
        var s = formatDate.getSeconds();
        var ss = s < 10 ? '0' + s : s;
        formatString = formatString.toLowerCase();
        formatString = formatString.replace('hh', hh);
        formatString = formatString.replace('h', h);
        formatString = formatString.replace('nn', nn);
        formatString = formatString.replace('n', n);
        formatString = formatString.replace('ss', ss);
        formatString = formatString.replace('s', s);
        formatString = formatString.replace('dd', dd);
        formatString = formatString.replace('d', d);
        formatString = formatString.replace('yyyy', yyyy);
        formatString = formatString.replace('yy', yy);
        formatString = formatString.replace('mmm', mmm);
        formatString = formatString.replace('mm', mm + 1);
        formatString = formatString.replace('m', m + 1);
        return formatString;
    } else {
        return '';
    }
};

function navigatorMouseDown(event, oParam) {
    'use strict';
    bExpanderDrag = false;
    bNavigatorDrag = true;
    event.preventDefault();
    var oCurrentElement = event.target || event.srcElement;
    MAQ.addEventListener(oCurrentElement, 'mousemove', navigatorMouseMove, oParam);
    iCurrentNavigatorX = event.clientX;
}

function navigatorMouseMove(event, oParam) {
    'use strict';
    //set the dragging source container id
    movingSource = oParam.config.chart.renderTo;
    event.preventDefault();
    var oCurrentElement = event.target || event.srcElement;
    if (bNavigatorDrag === true) {
        var iMouseXDiff = event.clientX - iCurrentNavigatorX;
        var iCurrX = parseFloat(oCurrentElement.x.baseVal.value + iMouseXDiff);
        if (iCurrX >= oParam.x && iCurrX <= oParam.maxX - oCurrentElement.width.baseVal.value) {
            oCurrentElement.x.baseVal.value = iCurrX;
            if (oParam.config.isTimeLineChart || oParam.config.chart.enableTimeline) {
                oParam.expanderLeft.x.baseVal.value += iMouseXDiff;
                oParam.expanderRight.x.baseVal.value += iMouseXDiff;
                MAQ.addAttr(oParam.clipLeft, 'd', MAQ.getTriangleCoords(oParam.expanderLeft.x.baseVal.value + oParam.expanderLeft.width.baseVal.value, oParam.expanderLeft.y.baseVal.value + oParam.expanderLeft.height.baseVal.value / 2, -1 * Math.min(20, oParam.height)));
                MAQ.addAttr(oParam.clipRight, 'd', MAQ.getTriangleCoords(oParam.expanderRight.x.baseVal.value, oParam.expanderRight.y.baseVal.value + oParam.expanderRight.height.baseVal.value / 2, Math.min(20, oParam.height)));
            } else if (oParam.config.isLiftChart) {
                oParam.lineLeft.x1.baseVal.value += iMouseXDiff;
                oParam.lineLeft.x2.baseVal.value += iMouseXDiff;
                oParam.lineRight.x1.baseVal.value += iMouseXDiff;
                oParam.lineRight.x2.baseVal.value += iMouseXDiff;
                oParam.lineTop.x1.baseVal.value += iMouseXDiff;
                oParam.lineTop.x2.baseVal.value += iMouseXDiff;
                oParam.lineBottom.x1.baseVal.value += iMouseXDiff;
                oParam.lineBottom.x2.baseVal.value += iMouseXDiff;
                oParam.expanderLeft.cx.baseVal.value += iMouseXDiff;
                oParam.expanderLeftBottom.cx.baseVal.value += iMouseXDiff;
                oParam.expanderRight.cx.baseVal.value += iMouseXDiff;
                oParam.expanderRightBottom.cx.baseVal.value += iMouseXDiff;
                MAQ.addAttr(oParam.leftTopTri, 'd', MAQ.getTriangleCoords(oParam.expanderLeft.cx.baseVal.value, oParam.expanderLeft.cy.baseVal.value, oParam.expanderLeft.r.baseVal.value));
                MAQ.addAttr(oParam.leftBottomTri, 'd', MAQ.getTriangleCoords(oParam.expanderLeftBottom.cx.baseVal.value, oParam.expanderLeftBottom.cy.baseVal.value, oParam.expanderLeftBottom.r.baseVal.value));
                MAQ.addAttr(oParam.rightTopTri, 'd', MAQ.getTriangleCoords(oParam.expanderRight.cx.baseVal.value, oParam.expanderRight.cy.baseVal.value, -oParam.expanderRight.r.baseVal.value));
                MAQ.addAttr(oParam.rightBottomTri, 'd', MAQ.getTriangleCoords(oParam.expanderRightBottom.cx.baseVal.value, oParam.expanderRightBottom.cy.baseVal.value, -oParam.expanderRightBottom.r.baseVal.value));
                /*Create intersection circles*/
                var oIntersectionPointsAttr = MAQ.getIntersectionPoints(oParam.config, oParam.navigator.x.baseVal.value + oParam.navigator.width.baseVal.value),
                    iCounter;
                for (iCounter = 0; iCounter < oParam.config.series.length; iCounter += 1) {
                    if (isSeriesEnabled(oParam.config.series, iCounter)) {
                        oParam.intersectionCircles[iCounter].cx.baseVal.value = oIntersectionPointsAttr.circleX[iCounter];
                        oParam.intersectionCircles[iCounter].cy.baseVal.value = oIntersectionPointsAttr.circleY[iCounter];
                        MAQ.addAttr(oParam.circleTexts[iCounter], 'x', oIntersectionPointsAttr.circleX[iCounter]);
                        MAQ.addAttr(oParam.circleTexts[iCounter], 'y', oIntersectionPointsAttr.circleY[iCounter]);
                        MAQ.addAttr(oParam.circleTexts[iCounter], 'text', oIntersectionPointsAttr.values[iCounter] + '%');
                        oParam.circleTexts[iCounter].innerHTML = oIntersectionPointsAttr.values[iCounter] + '%';
                        /*for chrome*/
                        oParam.circleTexts[iCounter].textContent = oIntersectionPointsAttr.values[iCounter] + '%'; /*for IE*/
                    }
                }
            }
            var oRectAttr = {
                x: oCurrentElement.x.baseVal.value,
                y: oCurrentElement.y.baseVal.value,
                width: oCurrentElement.width.baseVal.value,
                height: oCurrentElement.height.baseVal.value
            };
            var sDattr = ' M ' + oParam.x + ',' + (oParam.height + oParam.y) + ' L ' + oParam.x + ',' + oParam.y + ' L ' + oRectAttr.x + ',' + oRectAttr.y + ' L ' + oRectAttr.x + ',' + (oRectAttr.y + oRectAttr.height) + ' L ' + (oRectAttr.x + oRectAttr.width) + ',' + (oRectAttr.y + oRectAttr.height) + ' L ' + (oRectAttr.x + oRectAttr.width) + ',' + oRectAttr.y + ' L ' + (oParam.x + oParam.width) + ',' + oRectAttr.y + ' L ' + (oParam.x + oParam.width) + ',' + (oParam.height + oParam.y) + ' Z';
            MAQ.addAttr(oParam.dimmer, 'd', sDattr);
            iCurrentNavigatorX = event.clientX;
        }
    }
    var rangeStart = oParam.config.timeline.rangeStart,
        fNavigatorShiftRatio = oParam.config.timeline.shiftRatio;
    /*invoke the callback function*/
    if (typeof oParam.config.events.onNavigatorMove === 'function') {
        oParam.config.events.onNavigatorMove(oParam.config, Math.round(rangeStart + fNavigatorShiftRatio * oParam.navigator.x.baseVal.value), Math.round(rangeStart + fNavigatorShiftRatio * (oParam.navigator.x.baseVal.value + oParam.navigator.width.baseVal.value)));
    }
}

function navigatorMouseUp(event, oParam) {
    'use strict';
    //if this function is not called by the drag source container then simply return
    if (oParam.config.chart.renderTo !== movingSource && false === bNavigatorDrag) {
        return;
    }
    event.stopPropagation();
    event.preventDefault();
    var rangeStart = oParam.config.timeline.rangeStart,
        fNavigatorShiftRatio = oParam.config.timeline.shiftRatio;
    if (bNavigatorDrag) {
        var oCurrentElement = event.target || event.srcElement;
        MAQ.removeEventListener(oCurrentElement, 'mousemove', navigatorMouseMove, oParam);
        if (oParam.config.isTimeLineChart || oParam.config.chart.enableTimeline) {
            MAQ.updateTimeLineDisplayArea(oParam.config, rangeStart + fNavigatorShiftRatio * oParam.navigator.x.baseVal.value, rangeStart + fNavigatorShiftRatio * (oParam.navigator.x.baseVal.value + oParam.navigator.width.baseVal.value));
        } else if (oParam.config.isLiftChart) {
            onRangeChange(oParam.config, oParam.navigator.x.baseVal.value, oParam.navigator.x.baseVal.value + oParam.navigator.width.baseVal.value);
        }
        bNavigatorDrag = false;
    }
}

function stretcherMouseDown(event, oParam) {
    'use strict';
    bNavigatorDrag = false;
    bExpanderDrag = true;
    event.preventDefault();
    if (('TIMELINE' === oParam.config.chart.type.toUpperCase() && 'CHART' !== oParam.config.plotOptions.timeline.rangeDisplay.toUpperCase()) || oParam.config.chart.enableTimeline) {
        var oNavigatorWindow = document.getElementById('MAQCharts-NavWindow-' + oParam.config.chart.renderTo);
        oNavigatorWindow.setAttribute('pointer-events', 'visible-fill');
    }

    var oCurrentElement = event.target || event.srcElement;
    if (event.srcElement.id === "MAQCharts-InlineSlider-" + oParam.config.chart.renderTo) {
        MAQ.addEventListener(oCurrentElement, 'mousemove', stretcherMouseMove, oParam);
    } else {
        MAQ.addEventListener(oParam.panel, 'mousemove', stretcherMouseMove, oParam);
    }
    sSelectedExpander = oCurrentElement.getAttribute('desc');
    iCurrentNavigatorX = event.clientX;
}

function stretcherMouseMove(event, oParam) {
    'use strict';
    //set the dragging source container id
    movingSource = oParam.config.chart.renderTo;
    event.preventDefault();
    var iMouseXDiff = event.clientX - iCurrentNavigatorX;
    if (bExpanderDrag === true) {
        stretcherMove(oParam, iMouseXDiff);
        iCurrentNavigatorX = event.clientX;
    }
}

function stretcherMove(oParam, iMouseXDiff) {
    'use strict';
    var oCurrentElement = oParam.navigator;
    var oInlineSliderRect = oParam.inlineSliderRect;
    var iCurrX = parseFloat(oCurrentElement.x.baseVal.value + iMouseXDiff);
    var fLeftExpaderX, fRightExpaderX;
    if (oParam.config.isTimeLineChart || oParam.config.chart.enableTimeline) {
        fLeftExpaderX = oParam.expanderLeft.x.baseVal.value;
        fRightExpaderX = oParam.expanderRight.x.baseVal.value;
    } else if (oParam.config.isLiftChart) {
        fLeftExpaderX = oParam.expanderLeft.cx.baseVal.value;
        fRightExpaderX = oParam.expanderRight.cx.baseVal.value;
    }
    if (sSelectedExpander === 'left') {
        if (iCurrX >= oParam.x && fLeftExpaderX + iMouseXDiff <= fRightExpaderX - oParam.expanderWidth) {
            if (oParam.config.isTimeLineChart || oParam.config.chart.enableTimeline) {
                oParam.expanderLeft.x.baseVal.value += iMouseXDiff;
                oCurrentElement.x.baseVal.value = iCurrX;
                oInlineSliderRect.x.baseVal.value = iCurrX;
                oCurrentElement.width.baseVal.value = oParam.expanderRight.x.baseVal.value - oParam.expanderLeft.x.baseVal.value - oParam.expanderRight.width.baseVal.value;
                oInlineSliderRect.width.baseVal.value = oParam.expanderRight.x.baseVal.value - oParam.expanderLeft.x.baseVal.value;
                MAQ.addAttr(oParam.clipLeft, 'd', MAQ.getTriangleCoords((oParam.expanderLeft.x.baseVal.value + oParam.expanderLeft.width.baseVal.value / 2), (oParam.expanderLeft.y.baseVal.value + oParam.expanderLeft.height.baseVal.value / 2), -Math.min(20, oParam.height)));
                oParam.timelineBorder.d = ' M ' + 0 + ',' + 0 + ' L ' + (oParam.expanderLeft.x.baseVal.value + oParam.expanderLeft.width.baseVal.value / 2) + ',' + 0 + ' L ' + (oParam.expanderLeft.x.baseVal.value + oParam.expanderLeft.width.baseVal.value / 2) + ',' + (oParam.expanderRight.height.baseVal.value * 2 + oParam.inlineSliderRect.height.baseVal.value) + ' L ' + (oParam.inlineSliderRect.x.baseVal.value + oParam.inlineSliderRect.width.baseVal.value) + ',' + (oParam.expanderRight.height.baseVal.value * 2 + oParam.inlineSliderRect.height.baseVal.value) + ' L ' + (oParam.inlineSliderRect.x.baseVal.value + oParam.inlineSliderRect.width.baseVal.value) + ',' + '0' + ' L ' + oParam.width + ',' + 0;
                MAQ.addAttr(oParam.timelineBorder, 'd', oParam.timelineBorder.d);
                oCurrentElement.width.baseVal.value = oCurrentElement.width.baseVal.value + oParam.expanderRight.width.baseVal.value
            } else if (oParam.config.isLiftChart) {
                oParam.lineLeft.x1.baseVal.value += iMouseXDiff;
                oParam.lineLeft.x2.baseVal.value += iMouseXDiff;
                oParam.lineTop.x1.baseVal.value += iMouseXDiff;
                oParam.lineBottom.x1.baseVal.value += iMouseXDiff;
                oParam.expanderLeft.cx.baseVal.value += iMouseXDiff;
                oParam.expanderLeftBottom.cx.baseVal.value += iMouseXDiff;
                oCurrentElement.width.baseVal.value = oParam.expanderRight.cx.baseVal.value - oParam.expanderLeft.cx.baseVal.value;
                oCurrentElement.x.baseVal.value = oParam.expanderLeft.cx.baseVal.value;
                MAQ.addAttr(oParam.leftTopTri, 'd', MAQ.getTriangleCoords(oParam.expanderLeft.cx.baseVal.value, oParam.expanderLeft.cy.baseVal.value, oParam.expanderLeft.r.baseVal.value));
                MAQ.addAttr(oParam.leftBottomTri, 'd', MAQ.getTriangleCoords(oParam.expanderLeftBottom.cx.baseVal.value, oParam.expanderLeftBottom.cy.baseVal.value, oParam.expanderLeftBottom.r.baseVal.value));
            }

        }
    } else if (sSelectedExpander === 'right') {
        if (iCurrX + oCurrentElement.width.baseVal.value <= oParam.maxX && fRightExpaderX + iMouseXDiff >= fLeftExpaderX + oParam.expanderWidth) {
            if (oParam.config.isTimeLineChart || oParam.config.chart.enableTimeline) {
                oParam.expanderRight.x.baseVal.value += iMouseXDiff;
                oCurrentElement.width.baseVal.value = oParam.expanderRight.x.baseVal.value - oParam.expanderLeft.x.baseVal.value - oParam.expanderRight.width.baseVal.value;
                MAQ.addAttr(oParam.clipRight, 'd', MAQ.getTriangleCoords((oParam.expanderRight.x.baseVal.value + oParam.expanderRight.width.baseVal.value / 2), oParam.expanderRight.y.baseVal.value + oParam.expanderRight.height.baseVal.value / 2, Math.min(20, oParam.height)));
                oInlineSliderRect.width.baseVal.value = oParam.expanderRight.x.baseVal.value - oParam.expanderLeft.x.baseVal.value;
                oParam.timelineBorder.d = ' M ' + 0 + ',' + 0 + ' L ' + (oParam.expanderLeft.x.baseVal.value + oParam.expanderLeft.width.baseVal.value / 2) + ',' + 0 + ' L ' + (oParam.expanderLeft.x.baseVal.value + oParam.expanderLeft.width.baseVal.value / 2) + ',' + (oParam.expanderRight.height.baseVal.value * 2 + oParam.inlineSliderRect.height.baseVal.value) + ' L ' + (oParam.inlineSliderRect.x.baseVal.value + oParam.inlineSliderRect.width.baseVal.value) + ',' + (oParam.expanderRight.height.baseVal.value * 2 + oParam.inlineSliderRect.height.baseVal.value) + ' L ' + (oParam.inlineSliderRect.x.baseVal.value + oParam.inlineSliderRect.width.baseVal.value) + ',' + '0' + ' L ' + oParam.width + ',' + 0;
                MAQ.addAttr(oParam.timelineBorder, 'd', oParam.timelineBorder.d);
                oCurrentElement.width.baseVal.value = oCurrentElement.width.baseVal.value + oParam.expanderRight.width.baseVal.value
            } else if (oParam.config.isLiftChart) {
                oParam.lineRight.x1.baseVal.value += iMouseXDiff;
                oParam.lineRight.x2.baseVal.value += iMouseXDiff;
                oParam.lineTop.x2.baseVal.value += iMouseXDiff;
                oParam.lineBottom.x2.baseVal.value += iMouseXDiff;
                oParam.expanderRight.cx.baseVal.value += iMouseXDiff;
                oParam.expanderRightBottom.cx.baseVal.value += iMouseXDiff;
                oCurrentElement.width.baseVal.value = oParam.expanderRight.cx.baseVal.value - oParam.expanderLeft.cx.baseVal.value;
                MAQ.addAttr(oParam.rightTopTri, 'd', MAQ.getTriangleCoords(oParam.expanderRight.cx.baseVal.value, oParam.expanderRight.cy.baseVal.value, -oParam.expanderRight.r.baseVal.value));
                MAQ.addAttr(oParam.rightBottomTri, 'd', MAQ.getTriangleCoords(oParam.expanderRightBottom.cx.baseVal.value, oParam.expanderRightBottom.cy.baseVal.value, -oParam.expanderRightBottom.r.baseVal.value));
                /*Create intersection circles*/
                var oIntersectionPointsAttr = MAQ.getIntersectionPoints(oParam.config, oParam.navigator.x.baseVal.value + oParam.navigator.width.baseVal.value),
                    iCounter;
                for (iCounter = 0; iCounter < oParam.config.series.length; iCounter += 1) {
                    if (isSeriesEnabled(oParam.config.series, iCounter)) {
                        oParam.intersectionCircles[iCounter].cx.baseVal.value = oIntersectionPointsAttr.circleX[iCounter];
                        oParam.intersectionCircles[iCounter].cy.baseVal.value = oIntersectionPointsAttr.circleY[iCounter];
                        MAQ.addAttr(oParam.circleTexts[iCounter], 'x', oIntersectionPointsAttr.circleX[iCounter]);
                        MAQ.addAttr(oParam.circleTexts[iCounter], 'y', oIntersectionPointsAttr.circleY[iCounter]);
                        MAQ.addAttr(oParam.circleTexts[iCounter], 'text', oIntersectionPointsAttr.values[iCounter] + '%');
                        oParam.circleTexts[iCounter].innerHTML = oIntersectionPointsAttr.values[iCounter] + '%';
                        /*for chrome*/
                        oParam.circleTexts[iCounter].textContent = oIntersectionPointsAttr.values[iCounter] + '%'; /*for IE*/
                    }
                }
            }

        }
    } else if (sSelectedExpander === 'slider') {
        if ((oParam.inlineSliderRect.x.baseVal.value + iMouseXDiff) >= 0 && (oParam.inlineSliderRect.x.baseVal.value + iMouseXDiff + oParam.inlineSliderRect.width.baseVal.value) <= oParam.slider.width.baseVal.value) {
            oParam.inlineSliderRect.x.baseVal.value = oParam.inlineSliderRect.x.baseVal.value + iMouseXDiff;
            oParam.navigator.width.baseVal.value = oParam.inlineSliderRect.width.baseVal.value - oParam.expanderLeft.width.baseVal.value;
            oParam.navigator.x.baseVal.value = oParam.inlineSliderRect.x.baseVal.value;
            oParam.expanderLeft.x.baseVal.value += iMouseXDiff;
            oParam.expanderRight.x.baseVal.value += iMouseXDiff;
            MAQ.addAttr(oParam.clipLeft, 'd', MAQ.getTriangleCoords((oParam.expanderLeft.x.baseVal.value + oParam.expanderLeft.width.baseVal.value / 2), oParam.expanderLeft.y.baseVal.value + oParam.expanderLeft.height.baseVal.value / 2, -1 * Math.min(20, oParam.height)));
            MAQ.addAttr(oParam.clipRight, 'd', MAQ.getTriangleCoords((oParam.expanderRight.x.baseVal.value + oParam.expanderLeft.width.baseVal.value / 2), oParam.expanderRight.y.baseVal.value + oParam.expanderRight.height.baseVal.value / 2, Math.min(20, oParam.height)));
            oParam.timelineBorder.d = ' M ' + 0 + ',' + 0 + ' L ' + (oParam.expanderLeft.x.baseVal.value + oParam.expanderLeft.width.baseVal.value / 2) + ',' + 0 + ' L ' + (oParam.expanderLeft.x.baseVal.value + oParam.expanderLeft.width.baseVal.value / 2) + ',' + (oParam.expanderRight.height.baseVal.value * 2 + oParam.inlineSliderRect.height.baseVal.value) + ' L ' + (oParam.inlineSliderRect.x.baseVal.value + oParam.inlineSliderRect.width.baseVal.value) + ',' + (oParam.expanderRight.height.baseVal.value * 2 + oParam.inlineSliderRect.height.baseVal.value) + ' L ' + (oParam.inlineSliderRect.x.baseVal.value + oParam.inlineSliderRect.width.baseVal.value) + ',' + '0' + ' L ' + oParam.width + ',' + 0;
            MAQ.addAttr(oParam.timelineBorder, 'd', oParam.timelineBorder.d);
            oCurrentElement.width.baseVal.value = oCurrentElement.width.baseVal.value + oParam.expanderRight.width.baseVal.value
        }
    }
    var oRectAttr = {
        x: oCurrentElement.x.baseVal.value,
        y: oCurrentElement.y.baseVal.value,
        width: oCurrentElement.width.baseVal.value,
        height: oCurrentElement.height.baseVal.value
    };
    var sDattr = ' M ' + oParam.x + ',' + (oParam.height + oParam.y) + ' L ' + oParam.x + ',' + oParam.y + ' L ' + oRectAttr.x + ',' + oRectAttr.y + ' L ' + oRectAttr.x + ',' + (oRectAttr.y + oRectAttr.height) + ' L ' + (oRectAttr.x + oRectAttr.width) + ',' + (oRectAttr.y + oRectAttr.height) + ' L ' + (oRectAttr.x + oRectAttr.width) + ',' + oRectAttr.y + ' L ' + (oParam.x + oParam.width) + ',' + oRectAttr.y + ' L ' + (oParam.x + oParam.width) + ',' + (oParam.height + oParam.y) + ' Z';
    MAQ.addAttr(oParam.dimmer, 'd', sDattr);
    var rangeStart = oParam.config.timeline.rangeStart;
    var fNavigatorShiftRatio = oParam.config.timeline.shiftRatio;
    /*invoke the callback function*/
    if (typeof oParam.config.events.onNavigatorMove === 'function') {
        oParam.config.events.onNavigatorMove(oParam.config, Math.round(rangeStart + fNavigatorShiftRatio * oParam.navigator.x.baseVal.value), Math.round(rangeStart + fNavigatorShiftRatio * (oParam.navigator.x.baseVal.value + oParam.navigator.width.baseVal.value)));
    }
}

function stretcherMouseUp(event, oParam) {
    'use strict';
    //if this function is not called by the drag source container then simply return
    if (oParam.config.chart.renderTo !== movingSource && false === bExpanderDrag) {
        return;
    }
    event.stopPropagation();
    event.preventDefault();
    var rangeStart = oParam.config.timeline.rangeStart;
    var fNavigatorShiftRatio = oParam.config.timeline.shiftRatio;
    if (('TIMELINE' === oParam.config.chart.type.toUpperCase() && 'CHART' !== oParam.config.plotOptions.timeline.rangeDisplay.toUpperCase() && bExpanderDrag && (document !== event.target || document !== event.srcElement)) || oParam.config.chart.enableTimeline) {
        var oNavigatorWindow = document.getElementById('MAQCharts-NavWindow-' + oParam.config.chart.renderTo);
        oNavigatorWindow.setAttribute('pointer-events', 'none');
    }

    if (bExpanderDrag) {
        MAQ.removeEventListener(oParam.panel, 'mousemove', stretcherMouseMove, oParam);
        if (oParam.config.isTimeLineChart || oParam.config.chart.enableTimeline) {
            MAQ.updateTimeLineDisplayArea(oParam.config, rangeStart + fNavigatorShiftRatio * oParam.navigator.x.baseVal.value, rangeStart + fNavigatorShiftRatio * (oParam.navigator.x.baseVal.value + oParam.navigator.width.baseVal.value));
        } else if (oParam.config.isLiftChart) {
            onRangeChange(oParam.config, oParam.navigator.x.baseVal.value, oParam.navigator.x.baseVal.value + oParam.navigator.width.baseVal.value);
        }
        bExpanderDrag = false;
    }
}

function expandFullNavigator(chartConfigOptions) {
    'use strict';
    var oNavigatorWindow = document.getElementById('MAQCharts-NavWindow-' + chartConfigOptions.chart.renderTo);
    var oExpanderLeft = document.getElementById('MAQCharts-ExpanderLeft-' + chartConfigOptions.chart.renderTo);
    var oExpanderRight = document.getElementById('MAQCharts-ExpanderRight-' + chartConfigOptions.chart.renderTo);
    var oTriLeft = document.getElementById('MAQCharts-ClipLeft-' + chartConfigOptions.chart.renderTo);
    var oTriRight = document.getElementById('MAQCharts-ClipRight-' + chartConfigOptions.chart.renderTo);
    var oDimmer = document.getElementById('MAQCharts-Dimmer-' + chartConfigOptions.chart.renderTo);
    var oInlineSliderRect = document.getElementById('MAQCharts-InlineSlider-' + chartConfigOptions.chart.renderTo);
    var timelineBorder = document.getElementById('MAQCharts-timelineBorder-' + chartConfigOptions.chart.renderTo);
    var oSliderRect = document.getElementById('MAQCharts-SliderWindow-' + chartConfigOptions.chart.renderTo);
    oNavigatorWindow.x.baseVal.value = 0;
    oNavigatorWindow.width.baseVal.value = chartConfigOptions.fNavigatorWidth;
    oInlineSliderRect.x.baseVal.value = 0;
    oInlineSliderRect.width.baseVal.value = chartConfigOptions.fNavigatorWidth;

    var d = ' M ' + 0 + ',' + 0 + ' L ' + 0 + ',' + (oExpanderRight.height.baseVal.value * 2 + oInlineSliderRect.height.baseVal.value) + ' L ' + oSliderRect.width.baseVal.value + ',' + (oExpanderRight.height.baseVal.value * 2 + oInlineSliderRect.height.baseVal.value) + ' L ' + oNavigatorWindow.width.baseVal.value + ',' + 0;
    MAQ.addAttr(timelineBorder, 'd', d);

    oExpanderLeft.x.baseVal.value = -oExpanderLeft.width.baseVal.value / 2;
    oExpanderRight.x.baseVal.value = oNavigatorWindow.width.baseVal.value - oExpanderLeft.width.baseVal.value / 2;
    MAQ.addAttr(oTriLeft, 'd', MAQ.getTriangleCoords(oExpanderLeft.x.baseVal.value + oExpanderLeft.width.baseVal.value / 2, oNavigatorWindow.height.baseVal.value / 2, -Math.min(20, chartConfigOptions.fNavigatorHeight)));
    MAQ.addAttr(oTriRight, 'd', MAQ.getTriangleCoords((oExpanderRight.x.baseVal.value + oExpanderRight.width.baseVal.value / 2), oNavigatorWindow.height.baseVal.value / 2, Math.min(20, chartConfigOptions.fNavigatorHeight)));
    var sDattr = ' M ' + 0 + ',' + 0 + ' L ' + 0 + ',' + 0 + ' Z';
    MAQ.addAttr(oDimmer, 'd', sDattr);
}
/*
clickEventListener: Renders total value in center of both bows
@param {evt} event
@param {oParam} user configuration parameters
*/
function clickEventListener(evt, oParam) {
    'use strict';
    var oConfig = oParam.config;
    var oSVG = oConfig.svgELE;
    var fInterval = oConfig.plotIntervalWidth,
        oSeries = oConfig.series[oParam.seriesIndex],
        oLabels = oConfig.series.label,
        oPoint = oSVG.createSVGPoint();
    oPoint.x = evt.clientX;
    oPoint.y = evt.clientY;
    var oSVGCord = oPoint.matrixTransform(oSVG.getScreenCTM().inverse()),
        iSelectedIndex = 0;
    if (oParam.isPosavail) {
        iSelectedIndex = oParam.position;
    } else {
        iSelectedIndex = MAQ.getDataIndexPosition(oSVGCord, oSeries.xPos, fInterval);
    }
    if (oConfig.plotOptions.column.drill) {
        drillDown(oConfig, iSelectedIndex);
    }
    if (typeof window[oConfig.onClick.clickFunction] === 'function') {
        /* */
        switch (oConfig.chart.type) {
            case 'pie':
            case 'donut':
                window[oConfig.onClick.clickFunction](oSeries.name, '', oSeries.data);
                break;
            default:
                window[oConfig.onClick.clickFunction](oSeries.name, oLabels[iSelectedIndex], oSeries.data[iSelectedIndex]);
                break;
        }
    }
}
/* ----------------- */
/*
clickEventListener: Implements drill down functionality for the Column chart
@param {oConfig} user configuration parameters
@param {isSelectedIndex} index of clicked column
*/
//Note: Currently works only for Single column chart
function drillDown(oConfig, iSelectedIndex) {
    'use strict';

    function addDrillData() {
        oConfig.drillIndex = iSelectedIndex;
        oConfig.drillDataLength = oConfig.series[0].drillData[iSelectedIndex].data.length;
        var drillColor = [],
            i;
        for (i = 0; i < oConfig.drillDataLength; i += 1) {
            drillColor.push(oConfig.plotOptions[oConfig.chart.type].drillColor[i % oConfig.plotOptions[oConfig.chart.type].drillColor.length]);
        }
        oConfig.plotOptions[oConfig.chart.type].color.splice.apply(oConfig.plotOptions[oConfig.chart.type].color, [
            iSelectedIndex + 1,
            0
        ].concat(drillColor.slice(0, oConfig.drillDataLength)));
        oConfig.xAxis.labels.series.splice.apply(oConfig.xAxis.labels.series, [
            iSelectedIndex + 1,
            0
        ].concat(oConfig.series[0].drillData[iSelectedIndex].labels));
        oConfig.series[0].data.splice.apply(oConfig.series[0].data, [
            iSelectedIndex + 1,
            0
        ].concat(oConfig.series[0].drillData[iSelectedIndex].data));
    }
    if (undefined === oConfig.series[0].drillData || undefined === oConfig.series[0].drillData[iSelectedIndex].data || oConfig.series[0].drillData[iSelectedIndex].data.length <= 0) {
        return;
    }
    oConfig.animation.enabled = false;
    if (undefined === oConfig.drillActive || 0 === oConfig.drillActive) {
        oConfig.drillActive = 1;
        addDrillData();
    } else {
        oConfig.drillActive = 0;
        removeDrillData();
        if (iSelectedIndex !== oConfig.drillIndex) {
            if (iSelectedIndex > oConfig.drillIndex) {
                iSelectedIndex -= oConfig.drillDataLength;
            }
            oConfig.drillActive = 1;
            addDrillData();
        }
    }
    oConfig.series[0].enabled = undefined;
    redrawChart(null, {
        config: oConfig,
        seriesIndex: 0
    });
    oConfig.animation.enabled = true;

    function removeDrillData() {
        oConfig.plotOptions[oConfig.chart.type].color.splice(oConfig.drillIndex + 1, oConfig.drillDataLength);
        oConfig.xAxis.labels.series.splice(oConfig.drillIndex + 1, oConfig.drillDataLength);
        oConfig.series[0].data.splice(oConfig.drillIndex + 1, oConfig.drillDataLength);
    }
}
/*
MAQ.createTotalArea: Renders total value in center of both bows
@param {chartConfigOptions} user configuration parameters
@param {oBowTie} BotTie plotOptions
@param {oGrpELE} <g> object holding the total value
*/
MAQ.createTotalArea = function(chartConfigOptions, oBowTie, oGrpELE) {
    'use strict';
    var oTrialObject = null,
        oDimension = null,
        oDimensionTotalTitle = null;
    var oBow0 = chartConfigOptions.series[0].child;
    var oBow1 = chartConfigOptions.series[1].child;
    var sPlotFieldName = [
        oBowTie.branch.left.fieldName,
        oBowTie.branch.right.fieldName
    ];
    var oDataInfoBow0 = MAQ.getMinMax(oBow0, 0, 0, sPlotFieldName[0]);
    var oDataInfoBow1 = MAQ.getMinMax(oBow1, 0, 0, sPlotFieldName[1]);
    var iMax = oDataInfoBow0.total > oDataInfoBow1.total ? oDataInfoBow0.total : oDataInfoBow1.total;
    switch (oBowTie.showTotal.side) {
        case 'left':
            iMax = oDataInfoBow0.total;
            break;
        case 'right':
            iMax = oDataInfoBow1.total;
            break;
    }
    var sTotal = Math.round(iMax);
    var oGrpELESum, oAttr;
    if (oBowTie.showTotal.enabled) {
        oGrpELESum = null;
        if (oBowTie.showTotal.totalObj) {
            oGrpELE.removeChild(oBowTie.showTotal.totalObj);
        }
        oAttr = {
            class: 'MAQCharts-plotArea-Sum'
        };
        oGrpELESum = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
        oGrpELE.appendChild(oGrpELESum);
        if (oBowTie.branch.drillDepenedency === 'independent') {
            oBowTie.showTotal.totalObj = oGrpELESum;
        }
        var sFormatter = oBowTie.showTotal.formatter;
        if (sFormatter) {
            if (typeof window[sFormatter] === 'function') {
                sTotal = window[sFormatter](sTotal);
            } else if (typeof sFormatter === 'function') {
                sTotal = sFormatter(sTotal);
            }
        }
        oAttr = {
            x: chartConfigOptions.availWidth / 2,
            y: chartConfigOptions.availHeight / 2 + chartConfigOptions.availY,
            text: sTotal,
            'text-anchor': 'middle',
            style: oBowTie.showTotal.style
        };
        oTrialObject = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttr);
        oGrpELESum.appendChild(oTrialObject);
        oDimension = MAQ.getObjectDimension(oTrialObject);
        MAQ.addAttr(oTrialObject, 'y', oAttr.y + oDimension.height / 2);
        oDimension.width += oBowTie.showTotal.spacing;
        oAttr.text = oBowTie.showTotal.title.text;
        oAttr.style = oBowTie.showTotal.title.style;
        sFormatter = oBowTie.showTotal.title.formatter;
        if (sFormatter) {
            if (typeof window[sFormatter] === 'function') {
                oAttr.text = window[sFormatter](oAttr.text);
            } else if (sFormatter === 'function') {
                oAttr.text = sFormatter(oAttr.text);
            }
        }
        oTrialObject = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttr);
        var oTextTitleObj = MAQ.createSVGElement(chartConfigOptions.svgNS, 'title', {
            text: oBowTie.showTotal.title.text
        });
        oTrialObject.appendChild(oTextTitleObj);
        oGrpELESum.appendChild(oTrialObject);
        oDimensionTotalTitle = MAQ.getObjectDimension(oTrialObject);
        MAQ.addAttr(oTrialObject, 'y', oAttr.y - oDimensionTotalTitle.height / 2);
        oDimensionTotalTitle.width += oBowTie.showTotal.spacing;
        oDimension = oDimension.width > oDimensionTotalTitle.width ? oDimension : oDimensionTotalTitle;
        oBowTie.showTotal.dimension = oDimension;
    } else {
        oBowTie.showTotal.dimension = {
            width: oBowTie.branch.spacing
        };
    }
    if (oBowTie.branch.currentLevel > 0) {
        var oDrillBackImage = {
            x: oAttr.x - 12,
            y: oDimensionTotalTitle.y,
            width: 24,
            height: 24
        };
        var oBackImage = MAQ.createSVGElement(chartConfigOptions.svgNS, 'image', oDrillBackImage);
        oGrpELESum.appendChild(oBackImage);
        var oParam = {
            chartConfig: chartConfigOptions,
            series: chartConfigOptions.series
        };
        MAQ.addEventListener(oBackImage, 'click', oBowTie.branch.drillBackFunction, oParam);
        oBackImage.setAttributeNS(chartConfigOptions.xlinkNS, 'xlink:href', '../PublishingImages/PreviousArrow.png');
        var oImageDim = MAQ.getObjectDimension(oBackImage);
        MAQ.addAttr(oBackImage, 'y', oDrillBackImage.y - oDimensionTotalTitle.height - oImageDim.height);
    }
    var dataInfo = {
        series: [
            oBow0,
            oBow1
        ],
        datainfo: [
            oDataInfoBow0,
            oDataInfoBow1
        ]
    };
    return dataInfo;
};
/*
MAQ.getSpaceForGridArea: Computes space for grid area in bow tie chart
@param {chartConfigOptions} user configuration parameters
@param {oBowTieSide} config object for particular bow
@param {oBowSeries} data series holding data for particular bow
*/
MAQ.getSpaceForGridArea = function(chartConfigOptions, oBowTieSide, oBowSeries) {
    'use strict';
    var oTextAttr = {
        x: 0,
        y: 0,
        text: '',
        'text-anchor': 'start',
        style: null
    };
    var oWidth = [],
        iWidth = 0,
        iHeight = 0,
        iNumberOfColumns = oBowTieSide.header.length,
        sHeaderText = '',
        iCounter = 0,
        oHeader, oDimensionHeader, oCurrentColumn, oData, oDimensionData;
    for (iCounter = 0; iCounter < iNumberOfColumns; iCounter += 1) {
        sHeaderText = oBowTieSide.header[iCounter];
        oTextAttr.text = sHeaderText;
        oTextAttr.style = oBowTieSide.headerStyle;
        oHeader = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oTextAttr);
        chartConfigOptions.svgELE.appendChild(oHeader);
        oDimensionHeader = MAQ.getObjectDimension(oHeader);
        iHeight = oDimensionHeader.height + oBowTieSide.headerDataSpacing;
        chartConfigOptions.svgELE.removeChild(oHeader);
        oCurrentColumn = oBowTieSide.colModel[iCounter];
        if (oCurrentColumn.type === 'string') {
            sHeaderText = MAQ.getMinMax(oBowSeries, '', '', oCurrentColumn.name).max;
        } else {
            sHeaderText = MAQ.getMinMax(oBowSeries, 0, 0, oCurrentColumn.name).max;
        }
        /* Apply Column level formatting */
        if (oCurrentColumn.formatter) {
            if (typeof window[oCurrentColumn.formatter] === 'function') {
                sHeaderText = window[oCurrentColumn.formatter](sHeaderText);
            } else if (typeof oCurrentColumn.formatter === 'function') {
                sHeaderText = oCurrentColumn.formatter(sHeaderText);
            }
        }
        oTextAttr.text = sHeaderText;
        oTextAttr.style = oCurrentColumn.style;
        oData = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oTextAttr);
        chartConfigOptions.svgELE.appendChild(oData);
        oDimensionData = MAQ.getObjectDimension(oData);
        chartConfigOptions.svgELE.removeChild(oData);
        if (oDimensionHeader.width > oDimensionData.width) {
            oWidth[iCounter] = oDimensionHeader.width;
            iWidth += oDimensionHeader.width;
        } else {
            oWidth[iCounter] = oDimensionData.width;
            iWidth += oDimensionData.width;
        }
        iWidth += oCurrentColumn.spacing;
    }
    return {
        x: 0,
        y: 0,
        width: iWidth,
        height: iHeight,
        widthColl: oWidth
    };
};
/*
MAQ.createSideSpecifiedBow: Renders one half bow tie chart
@param {chartConfigOptions} user configuration parameters
@param {oGrpELE} group object for holding a bow
@param {oGrpELEGrid} group object for holing grid data
@param {oBowTie} object containing plotOptions
@param {oDataInfoBow} object holing min, max and total for the series provided
@param {oBow} data series for a side of bow
@param {sSide} side of bow viz. left, right
*/
MAQ.createSideSpecifiedBow = function(chartConfigOptions, oGrpELE, oGrpELEGrid, oBowTie, oDataInfoBow, oBow, sSide) {
    'use strict';
    MAQ.removeAllChildren(oGrpELE);
    MAQ.removeAllChildren(oGrpELEGrid);
    var oDimensionForColumnTitle = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        },
        oAttr = {
            x: 0,
            y: 0,
            text: '',
            style: {}
        },
        fCurveFactor = 0.25,
        oHeader, oHeadDim, oHeaderText, oSideSpecificBow = oBowTie.label[sSide],
        oBranch = oBowTie.branch[sSide],
        fCentralX = chartConfigOptions.availWidth / 2,
        iArrayLabelCounter = 0,
        oCurrentBow;
    if (sSide === 'none') {
        //oBowTie.branch.drillDepenedency = 'independent';
        oSideSpecificBow = oBowTie.label;
        oBranch = oBowTie.branch;
        fCentralX = chartConfigOptions.availX;
        fCurveFactor = 0.5;
    }
    oSideSpecificBow.headerDataSpacing = oBowTie.label.headerDataSpacing;
    oSideSpecificBow.title = oBranch.title;
    if (oSideSpecificBow.enabled) {
        oDimensionForColumnTitle = MAQ.getSpaceForGridArea(chartConfigOptions, oSideSpecificBow, oBow);
    }
    var sPlotFieldName = oBranch.fieldName,
        fStartX = oBowTie.showTotal.dimension.width / 2 + fCentralX,
        fEndX = chartConfigOptions.availWidth - oDimensionForColumnTitle.width;
    /* Adding grid title */
    oAttr.x = fEndX;
    oAttr.text = oSideSpecificBow.title.text;
    oAttr.style = oSideSpecificBow.title.style;
    var oGridTitle = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttr);
    oGrpELEGrid.appendChild(oGridTitle);
    var oDimGridTitle = MAQ.getObjectDimension(oGridTitle);
    switch (oSideSpecificBow.title.align) {
        case 'center':
            MAQ.addAttr(oGridTitle, 'text-anchor', 'middle');
            MAQ.addAttr(oGridTitle, 'x', oAttr.x + oDimensionForColumnTitle.width / 2);
            break;
        case 'right':
            MAQ.addAttr(oGridTitle, 'text-anchor', 'end');
            MAQ.addAttr(oGridTitle, 'x', oAttr.x + oDimensionForColumnTitle.width);
            break;
    }
    MAQ.addAttr(oGridTitle, 'y', oAttr.y + oDimGridTitle.height);
    oDimensionForColumnTitle.height += oDimGridTitle.height * 1.5;
    /*-------------------*/
    var fEndY = oDimensionForColumnTitle.height;
    var fPipeStartHeight = (chartConfigOptions.availHeight - oDimensionForColumnTitle.height) / 6;
    var fMaxBranchHeight = (chartConfigOptions.availHeight - oDimensionForColumnTitle.height) / oBow.length;
    var fBranchHeight = oBow[0][sPlotFieldName] / oDataInfoBow.total * fPipeStartHeight;
    var fStartY = (chartConfigOptions.availHeight - oDimensionForColumnTitle.height - fEndY) / 2 - fPipeStartHeight / 2 + oDimensionForColumnTitle.height;
    var fPipeArea = fEndX - fStartY;
    var iArrayCounter = 0;
    var iLength = oBow.length;
    fEndY += fBranchHeight / 2;
    fBranchHeight = 0;
    if (sSide === 'left') {
        MAQ.addAttr(oGrpELEGrid, 'transform', 'translate(' + -fEndX + ',' + chartConfigOptions.availY + ')');
    }
    var oPathAttr = {
            d: '',
            stroke: oBranch.fillColor,
            fill: 'none'
        },
        oPath, oColModel, oParam, oCurrColModel, sTitleText, oTextTitleObj;
    if (oSideSpecificBow.enabled) {
        oHeader = oSideSpecificBow.header;
        oAttr.x = fEndX + oSideSpecificBow.colModel[0].spacing / 2;
        for (iArrayCounter = 0; iArrayCounter < oHeader.length; iArrayCounter += 1) {
            oAttr.y = oDimGridTitle.height * 1.5;
            oAttr.text = oHeader[iArrayCounter];
            oAttr.style = oSideSpecificBow.headerStyle;
            oHeaderText = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttr);
            oGrpELEGrid.appendChild(oHeaderText);
            oHeadDim = MAQ.getObjectDimension(oHeaderText);
            MAQ.addAttr(oHeaderText, 'y', oAttr.y + oHeadDim.height / 2);
            oAttr.x += oDimensionForColumnTitle.widthColl[iArrayCounter] + oSideSpecificBow.colModel[iArrayCounter].spacing;
        }
    }
    /* Plot each branch with user specidfied column values */
    for (iArrayCounter = 0; iArrayCounter < iLength; iArrayCounter += 1) {
        oCurrentBow = oBow[iArrayCounter];
        fStartY += fBranchHeight / 2;
        fBranchHeight = oCurrentBow[sPlotFieldName] / oDataInfoBow.total * fPipeStartHeight;
        fBranchHeight = fBranchHeight < 1 ? 1 : fBranchHeight;
        fBranchHeight = fBranchHeight <= fMaxBranchHeight ? fBranchHeight : fMaxBranchHeight;
        fStartY += fBranchHeight / 2;
        if (iLength === 1) {
            fEndY = fStartY;
        }
        oPathAttr.d = 'M ' + fStartX + ' ' + fStartY + ' C ' + (fEndX - fPipeArea * fCurveFactor) + ' ' + fStartY + ' ' + (fStartX + fPipeArea * fCurveFactor) + ' ' + fEndY + ' ' + fEndX + ' ' + fEndY;
        oPathAttr['stroke-width'] = fBranchHeight;
        oPath = MAQ.createSVGElement(chartConfigOptions.svgNS, 'path', oPathAttr);
        oGrpELE.appendChild(oPath);
        oColModel = oSideSpecificBow.colModel;
        oAttr.x = fEndX + oColModel[0].spacing / 2;
        MAQ.addAttr(oPath, 'name', oCurrentBow.name);
        oParam = {
            chartConfig: chartConfigOptions,
            position: iArrayCounter,
            side: sSide,
            series: oBow,
            branchGroup: oGrpELE,
            gridGroup: oGrpELEGrid
        };
        if (oCurrentBow[sPlotFieldName] > 0) {
            if (oBowTie.branch.drillDepenedency === 'independent') {
                if (oCurrentBow.child && oCurrentBow.child.length > 0) {
                    MAQ.addEventListener(oPath, 'click', 'bowTieDrill', oParam);
                }
            } else {
                oParam.drillFunction = oBowTie.branch.drillFunction;
                MAQ.addEventListener(oPath, 'click', 'bowTieDependentDrill', oParam);
            }
            oPath.style.cursor = 'pointer';
        }
        if (oSideSpecificBow.enabled) {
            for (iArrayLabelCounter = 0; iArrayLabelCounter < oHeader.length; iArrayLabelCounter += 1) {
                oCurrColModel = oColModel[iArrayLabelCounter];
                oAttr.y = fEndY;
                oAttr.text = oCurrentBow[oCurrColModel.name];
                sTitleText = oAttr.text;
                if (oCurrColModel.formatter) {
                    if (typeof window[oCurrColModel.formatter] === 'function') {
                        oAttr.text = window[oCurrColModel.formatter](oAttr.text);
                    } else if (typeof oCurrColModel.formatter === 'function') {
                        oAttr.text = oCurrColModel.formatter(oAttr.text);
                    }
                }
                oAttr.style = oCurrColModel.style;
                oHeaderText = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttr);
                oGrpELEGrid.appendChild(oHeaderText);
                oHeadDim = MAQ.getObjectDimension(oHeaderText);
                if (oCurrColModel.align === 'right') {
                    MAQ.addAttr(oHeaderText, 'x', oAttr.x + oDimensionForColumnTitle.widthColl[iArrayLabelCounter]);
                    MAQ.addAttr(oHeaderText, 'text-anchor', 'end');
                }
                if (oAttr.text.toString().indexOf('...') > 0) {
                    oTextTitleObj = MAQ.createSVGElement(chartConfigOptions.svgNS, 'title', {
                        text: sTitleText
                    });
                    oHeaderText.appendChild(oTextTitleObj);
                }
                MAQ.addAttr(oHeaderText, 'y', oAttr.y + oHeadDim.height / 4);
                oAttr.x += oDimensionForColumnTitle.widthColl[iArrayLabelCounter] + oCurrColModel.spacing;
            }
        }
        fEndY += fMaxBranchHeight;
    }
};
/*
MAQ.createBowTieChart: Renders full bow tie chart
@param {chartConfigOptions} user configuration parameters
*/
MAQ.createBowTieChart = function(chartConfigOptions) {
    'use strict';
    var oBowTie = chartConfigOptions.plotOptions.bowtie;
    if (oBowTie.container) {
        MAQ.removeAllChildren(oBowTie.container);
    }
    var oAttr = {};
    oAttr = {
        class: 'MAQCharts-plotArea'
    };
    var oGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    chartConfigOptions.svgELE.appendChild(oGrpELE);
    oBowTie.container = oGrpELE;
    var oDataInfo = MAQ.createTotalArea(chartConfigOptions, oBowTie, oGrpELE);
    oAttr = {
        class: 'MAQCharts-plotAreaRightBow',
        transform: 'translate(' + 0 + ',' + chartConfigOptions.availY + ')'
    };
    var oGrpELERightBow = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    oGrpELE.appendChild(oGrpELERightBow);
    oAttr = {
        class: 'MAQCharts-plotAreaRightGrid',
        transform: 'translate(' + 0 + ',' + chartConfigOptions.availY + ')'
    };
    var oGrpELERightGrid = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    oGrpELE.appendChild(oGrpELERightGrid);
    oAttr.class = 'MAQCharts-plotAreaLeftBow';
    oAttr.transform = 'translate(' + chartConfigOptions.availWidth + ',' + chartConfigOptions.availY + ') scale(-1,1)';
    var oGrpELELeftBow = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    oGrpELE.appendChild(oGrpELELeftBow);
    oAttr = {
        class: 'MAQCharts-plotAreaLeftGrid'
    };
    var oGrpELELeftGrid = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    oGrpELE.appendChild(oGrpELELeftGrid);
    MAQ.createSideSpecifiedBow(chartConfigOptions, oGrpELELeftBow, oGrpELELeftGrid, oBowTie, oDataInfo.datainfo[0], oDataInfo.series[0], 'left');
    MAQ.createSideSpecifiedBow(chartConfigOptions, oGrpELERightBow, oGrpELERightGrid, oBowTie, oDataInfo.datainfo[1], oDataInfo.series[1], 'right');
};
/*
MAQ.createHalfBowTieChart: Renders half bow tie chart
@param {chartConfigOptions} user configuration parameters
*/
MAQ.createHalfBowTieChart = function(chartConfigOptions) {
    var oBowTie = chartConfigOptions.plotOptions.halfbowtie,
        oBow0 = chartConfigOptions.series[0].child,
        sPlotFieldName = oBowTie.branch.fieldName,
        oDataInfo = MAQ.getMinMax(oBow0, 0, 0, sPlotFieldName),
        oAttr;
    if (oBowTie.container) {
        MAQ.removeAllChildren(oBowTie.container);
    }
    oAttr = {
        class: 'MAQCharts-plotArea'
    };
    var oGrpELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    chartConfigOptions.svgELE.appendChild(oGrpELE);
    oBowTie.container = oGrpELE;
    var sTotal = Math.round(oDataInfo.total);
    if (oBowTie.showTotal.enabled) {
        oAttr = {
            class: 'MAQCharts-plotArea-Sum'
        };
        oGrpELESum = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
        oGrpELE.appendChild(oGrpELESum);
        var sFormatter = oBowTie.showTotal.formatter;
        if (sFormatter) {
            if (typeof window[sFormatter] === 'function') {
                sTotal = window[sFormatter](sTotal);
            } else if (typeof sFormatter === 'function') {
                sTotal = sFormatter(sTotal);
            }
        }
        oAttr = {
            x: chartConfigOptions.availX,
            y: chartConfigOptions.availHeight / 2 + chartConfigOptions.availY,
            text: sTotal,
            'text-anchor': 'middle',
            style: oBowTie.showTotal.style
        };
        var oSumObject = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttr);
        oGrpELESum.appendChild(oSumObject);
        var oDimension = MAQ.getObjectDimension(oSumObject);
        MAQ.addAttr(oSumObject, 'y', oAttr.y + oDimension.height / 2);
        oDimension.width += oBowTie.showTotal.spacing;
        oAttr.text = oBowTie.showTotal.title.text;
        oAttr.style = oBowTie.showTotal.title.style;
        sFormatter = oBowTie.showTotal.title.formatter;
        if (sFormatter) {
            if (typeof window[sFormatter] === 'function') {
                oAttr.text = window[sFormatter](oAttr.text);
            } else if (typeof sFormatter === 'function') {
                oAttr.text = sFormatter(oAttr.text);
            }
        }
        var oTitleObject = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oAttr);
        var oTextTitleObj = MAQ.createSVGElement(chartConfigOptions.svgNS, 'title', {
            text: oBowTie.showTotal.title.text
        });
        oTitleObject.appendChild(oTextTitleObj);
        oGrpELESum.appendChild(oTitleObject);
        oDimensionTotalTitle = MAQ.getObjectDimension(oTitleObject);
        MAQ.addAttr(oTitleObject, 'y', oAttr.y - oDimensionTotalTitle.height / 2);
        oDimensionTotalTitle.width += oBowTie.showTotal.spacing;
        oDimension = oDimension.width > oDimensionTotalTitle.width ? oDimension : oDimensionTotalTitle;
        MAQ.addAttr(oSumObject, 'x', oAttr.x + oDimension.width / 2);
        MAQ.addAttr(oTitleObject, 'x', oAttr.x + oDimension.width / 2);
        oDimension.width *= 2;
        oBowTie.showTotal.dimension = oDimension;
    }
    oAttr = {
        class: 'MAQCharts-plotAreaBow',
        transform: 'translate(' + 0 + ',' + chartConfigOptions.availY + ')'
    };
    var oGrpELEBow = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    oGrpELE.appendChild(oGrpELEBow);
    oAttr = {
        class: 'MAQCharts-plotAreaGrid',
        transform: 'translate(' + 0 + ',' + chartConfigOptions.availY + ')'
    };
    var oGrpELEGrid = MAQ.createSVGElement(chartConfigOptions.svgNS, 'g', oAttr);
    oGrpELE.appendChild(oGrpELEGrid);
    MAQ.createSideSpecifiedBow(chartConfigOptions, oGrpELEBow, oGrpELEGrid, oBowTie, oDataInfo, oBow0, 'none');
};
/*
MAQ.createWaterfallChart: Renders waterfall chart
@param {chartConfigOptions} user configuration parameters
*/
MAQ.createWaterfallChart = function(chartConfigOptions) {
    'use strict';
    MAQ.getSeriesValidation(chartConfigOptions);
    var oPlotOptions = chartConfigOptions.plotOptions;
    var oSection = oPlotOptions.waterfall.section;
    var oChartSeries = MAQ.getChartSeries(oSection.vertical.seriesDivision.chartMetric, chartConfigOptions);
    var oNonChartSeries = MAQ.getChartSeries(oSection.vertical.seriesDivision.nonChartMetric, chartConfigOptions);
    var oContainer = document.querySelector('#' + chartConfigOptions.chart.renderTo);
    var iCount = 0,
        jCount = 0;
    var oLabelDiv = null;
    var oChartMetricDivArray = [],
        oNonChartMetricDivArray = [];
    var iChartSeries = oSection.vertical.seriesDivision.chartMetric.length;
    var fTopSpace = 20,
        fPrevDivHeight = 0,
        fCellDivHeight = 0;
    // Create divisions of full area.
    // Create horizontal divisions.
    var oHLeftSection = null;
    oHLeftSection = document.createElement('div');
    oHLeftSection.className = 'LeftSectiondiv';
    oHLeftSection.style.width = parseInt(oSection.horizontal.division[0]) + 'px';
    oHLeftSection.style.height = oContainer.clientHeight + 'px';
    oHLeftSection.style.cssFloat = 'left';
    oContainer.appendChild(oHLeftSection);
    var oHRightSection = document.createElement('div');
    oHRightSection.style.width = parseInt((oContainer.clientWidth - oSection.horizontal.division[0] - 4).toString()) + 'px';
    oHRightSection.style.height = parseInt(oContainer.clientHeight.toString()) + 'px';
    oHRightSection.style.cssFloat = 'left';
    oHRightSection.className = 'RightSectiondiv';
    oContainer.appendChild(oHRightSection);
    // Fill vertical divisions in left horizontal partition
    var oCMetricDiv = document.createElement('div');
    oCMetricDiv.style.width = oHLeftSection.clientWidth + 'px';
    oCMetricDiv.style.height = oSection.vertical.division[0] + 'px';
    oCMetricDiv.className = 'ChartMetricLabel';
    oHLeftSection.appendChild(oCMetricDiv);
    var oEmptyLeftDiv = document.createElement('div');
    oEmptyLeftDiv.style.width = oHLeftSection.clientWidth + 'px';
    oEmptyLeftDiv.style.height = oContainer.clientHeight - oSection.vertical.division[0] - oSection.vertical.division[2] + 'px';
    oEmptyLeftDiv.className = 'EmptyLeftDiv';
    oHLeftSection.appendChild(oEmptyLeftDiv);
    var oNonCMetricDiv = document.createElement('div');
    oNonCMetricDiv.style.width = oHLeftSection.clientWidth + 'px';
    oNonCMetricDiv.style.height = oSection.vertical.division[2] + 'px';
    oNonCMetricDiv.className = 'NonChartMetricLabel';
    oHLeftSection.appendChild(oNonCMetricDiv);
    //// Fill vertical divisions in right horizontal partition
    var oCMetricValDiv = document.createElement('div');
    oCMetricValDiv.style.width = oHRightSection.clientWidth + 'px';
    oCMetricValDiv.style.height = oSection.vertical.division[0] + 'px';
    oCMetricValDiv.className = 'ChartMetricValue';
    oHRightSection.appendChild(oCMetricValDiv);
    var oChartDiv = document.createElement('div');
    oChartDiv.style.width = oHRightSection.clientWidth + 'px';
    oChartDiv.style.height = oContainer.clientHeight - oSection.vertical.division[0] - oSection.vertical.division[2] + 'px';
    oChartDiv.className = 'ChartDiv';
    oHRightSection.appendChild(oChartDiv);
    var oRightBottomLabelDiv = document.createElement('div');
    oRightBottomLabelDiv.style.width = oHRightSection.clientWidth + 'px';
    oRightBottomLabelDiv.style.height = oSection.vertical.division[2] + 'px';
    oRightBottomLabelDiv.className = 'RightBottomLabelDiv';
    oHRightSection.appendChild(oRightBottomLabelDiv);
    for (iCount = 0; iCount < iChartSeries; iCount += 1) {
        oLabelDiv = document.createElement('div');
        oLabelDiv.style.height = parseInt(((oCMetricDiv.clientHeight - 5) / iChartSeries).toString()) + 'px';
        if (oSection.vertical.seriesDivision.chartMetric[iCount].indexOf('$$') === -1) {
            oLabelDiv.innerText = oSection.vertical.seriesDivision.chartMetric[iCount];
        }
        if (oSection.vertical.seriesDivision.chartLabelStyle[iCount]) {
            MAQ.applyStyle(oLabelDiv, oSection.vertical.seriesDivision.chartLabelStyle[iCount]);
        } else {
            MAQ.applyStyle(oLabelDiv, chartConfigOptions.plotOptions.waterfall.section.labelStyle);
        }
        oCMetricDiv.appendChild(oLabelDiv);
        // Maintain labels div in array
        oChartMetricDivArray[iCount] = document.createElement('div');
        oChartMetricDivArray[iCount].style.height = parseInt(((oCMetricValDiv.clientHeight - 5) / iChartSeries).toString()) + 'px';
        oCMetricValDiv.appendChild(oChartMetricDivArray[iCount]);
    }
    for (iCount = 0; iCount < oSection.vertical.seriesDivision.nonChartMetric.length; iCount += 1) {
        oLabelDiv = document.createElement('div');
        oLabelDiv.style.height = parseInt(((oNonCMetricDiv.clientHeight - 5) / oSection.vertical.seriesDivision.nonChartMetric.length).toString()) + 'px';
        if (oSection.vertical.seriesDivision.nonChartMetric[iCount].indexOf('$$') === -1) {
            oLabelDiv.innerText = oSection.vertical.seriesDivision.nonChartMetric[iCount];
        }
        if (oSection.vertical.seriesDivision.nonChartLabelStyle[iCount]) {
            MAQ.applyStyle(oLabelDiv, oSection.vertical.seriesDivision.nonChartLabelStyle[iCount]);
        } else {
            MAQ.applyStyle(oLabelDiv, chartConfigOptions.plotOptions.waterfall.section.labelStyle);
        }
        if (!iCount) {
            oLabelDiv.style.marginTop = '5px';
        }
        oNonCMetricDiv.appendChild(oLabelDiv);
        // Maintain labels div in array
        oNonChartMetricDivArray[iCount] = document.createElement('div');
        if (!iCount) {
            oNonChartMetricDivArray[iCount].style.marginTop = '5px';
        }
        oNonChartMetricDivArray[iCount].style.height = parseInt(((oRightBottomLabelDiv.clientHeight - 5) / oSection.vertical.seriesDivision.nonChartMetric.length).toString()) + 'px';
        oRightBottomLabelDiv.appendChild(oNonChartMetricDivArray[iCount]);
    }
    if (oPlotOptions.waterfall.isCustomLegends) {
        var oLegends = {
            color: oPlotOptions.colors,
            style: chartConfigOptions.xAxis.labels.style,
            series: chartConfigOptions.xAxis.labels.series,
            formatter: chartConfigOptions.xAxis.labels.formatter
        };
        MAQ.createCustomLegends(oLegends, oEmptyLeftDiv);
    }
    var fBudgetForecastDiff = 0,
        oDiffDiv = null,
        oDiffLabelDiv = null,
        fDiffDivHeight = 0;
    var iTotalRecords = chartConfigOptions.series[0].data.length;
    var oMinMax = MAQ.getForecastMinMax(chartConfigOptions.series[0], 0, '');
    var fColumnDivWidth = (oChartDiv.clientWidth - (oPlotOptions.waterfall.padding * oChartSeries[0].data.length - 1)) / oChartSeries[0].data.length;
    var oBackColumnDiv = null,
        oGapDiv = null,
        oCellDiv = null,
        oMVDiv = null,
        oDottedLineDiv = null,
        oStackedDiv = null,
        sContent = '',
        kCount, iSum = 0;
    var isNegative = false,
        iNegativeHeight = 0,
        iNegativeCheck = 1;
    //  Calculate sum for stacked elements in case of single stack column
    if (oPlotOptions.waterfall.singleColumnStack.enabled) {
        for (kCount = 0; kCount < oChartSeries[0].data.length; kCount += 1) {
            if (oChartSeries[jCount].stacked[kCount]) {
                if (oChartSeries[jCount].data[kCount] < 0) {
                    iNegativeCheck *= -1;
                }
                iSum += parseInt(oChartSeries[jCount].data[kCount]);
            } else {
                break;
            }
        }
    }
    if (0 > iNegativeCheck) {
        oMinMax = MAQ.getMinMax(oChartSeries[0].data, 0, 0);
    }
    // Find 0 position height
    var fNormalizedHeight = (oChartDiv.clientHeight - fTopSpace) * Math.abs(oMinMax.max) / (Math.abs(oMinMax.max) + Math.abs(oMinMax.min)),
        iMarginTopNegative;
    // Calculate bar div width
    if (oPlotOptions.waterfall.singleColumnStack.enabled) {
        fColumnDivWidth = (oChartDiv.clientWidth - (oPlotOptions.waterfall.padding * oChartSeries[0].data.length - 1)) / (oChartSeries[0].data.length - 1);
    }
    for (iCount = 0; iCount < iTotalRecords; iCount += 1) {
        // Create Column background div
        oBackColumnDiv = document.createElement('div');
        oBackColumnDiv.style.width = fColumnDivWidth + 'px';
        oBackColumnDiv.style.height = oChartDiv.clientHeight + 'px';
        oBackColumnDiv.style.cssFloat = 'left';
        oBackColumnDiv.style.backgroundColor = '#EEEEEE';
        if (!oPlotOptions.waterfall.singleColumnStack.enabled || !oStackedDiv || oPlotOptions.waterfall.singleColumnStack.enabled && !oChartSeries[0].stacked[iCount]) {
            oChartDiv.appendChild(oBackColumnDiv);
        }
        // Create Gap div
        if (iCount !== oChartSeries[0].data.length - 1) {
            oGapDiv = document.createElement('div');
            oGapDiv.style.width = oPlotOptions.waterfall.padding + 'px';
            oGapDiv.style.height = oChartDiv.clientHeight + 'px';
            oGapDiv.style.cssFloat = 'left';
            oChartDiv.appendChild(oGapDiv);
        }
        // Create data div
        oCellDiv = document.createElement('div');
        oCellDiv.style.width = fColumnDivWidth + 'px';
        if (chartConfigOptions.xAxis.labels.series[iCount].toString().toLowerCase() === 'gap') {
            oChartSeries[0].data[iCount] = oMinMax.gapPoint - oChartSeries[0].data[iCount + 1];
        }
        // Calculate height of the bar
        fCellDivHeight = (oChartDiv.clientHeight - fTopSpace) * Math.abs(oChartSeries[0].data[iCount]) / (Math.abs(oMinMax.max) + Math.abs(oMinMax.min));
        if ('undefined' !== typeof oPlotOptions.waterfall.minHeight && 0 < oPlotOptions.waterfall.minHeight && fCellDivHeight < oPlotOptions.waterfall.minHeight && oChartSeries[0].data[iCount]) {
            fCellDivHeight = oPlotOptions.waterfall.minHeight;
        }
        oCellDiv.style.height = fCellDivHeight + 'px';
        oCellDiv.style.backgroundColor = oPlotOptions.colors[iCount];
        if (oChartSeries[0].stacked[iCount]) {
            if (oPlotOptions.waterfall.singleColumnStack.enabled && !oStackedDiv) {
                oStackedDiv = oBackColumnDiv;
            }
            if (oChartSeries[0].data[iCount] >= 0) {
                oCellDiv.style.marginTop = fNormalizedHeight + fTopSpace - fCellDivHeight - fPrevDivHeight + 'px';
            } else {
                oCellDiv.style.marginTop = fTopSpace + fNormalizedHeight + fPrevDivHeight + 'px';
            }
            if (oPlotOptions.waterfall.grouping.enabled && oPlotOptions.waterfall.grouping.index - 1 === iCount) {
                fPrevDivHeight = 0;
            } else {
                fPrevDivHeight += fCellDivHeight;
            }
            // Draw dotted line
            oPlotOptions.waterfall.staggeredLine.staggeredLineStyle.width = oChartDiv.clientWidth - iCount * (fColumnDivWidth + oPlotOptions.waterfall.padding) - oPlotOptions.waterfall.padding + 'px';
            oPlotOptions.waterfall.staggeredLine.staggeredLineStyle.marginTop = oCellDiv.style.marginTop;
            oPlotOptions.waterfall.staggeredLine.staggeredLineStyle.marginLeft = iCount * (fColumnDivWidth + oPlotOptions.waterfall.padding) + 'px';
        } else {
            if (chartConfigOptions.xAxis.labels.series[iCount].toString().toLowerCase() === 'gap') {
                // Calculation for Gap
                if (oChartSeries[0].data[iCount] < 0) {
                    oCellDiv.style.marginTop = fTopSpace + fNormalizedHeight - fCellDivHeight - fPrevDivHeight + 'px';
                } else {
                    oCellDiv.style.marginTop = fTopSpace + fNormalizedHeight - fPrevDivHeight + 'px';
                }
                oPlotOptions.waterfall.staggeredLine.staggeredLineStyle.width = oChartDiv.clientWidth - oPlotOptions.waterfall.padding + 'px';
                oPlotOptions.waterfall.staggeredLine.staggeredLineStyle.marginLeft = -oPlotOptions.waterfall.padding + 'px';
            } else {
                // Quota, Budget, Forecast
                if (oChartSeries[0].data[iCount] < 0) {
                    oCellDiv.style.marginTop = fNormalizedHeight + fTopSpace + 'px';
                    oPlotOptions.waterfall.staggeredLine.staggeredLineStyle.marginTop = fNormalizedHeight + fCellDivHeight + fTopSpace + 'px';
                } else {
                    oCellDiv.style.marginTop = fNormalizedHeight + fTopSpace - fCellDivHeight + 'px';
                    oPlotOptions.waterfall.staggeredLine.staggeredLineStyle.marginTop = oCellDiv.style.marginTop;
                }
                if (chartConfigOptions.plotOptions.waterfall.isBudgetForecastDiff && (chartConfigOptions.xAxis.labels.series[iCount].toString().toLowerCase() === 'budget' || chartConfigOptions.xAxis.labels.series[iCount].toString().toLowerCase() === 'forecast')) {
                    // Get difference
                    if (chartConfigOptions.xAxis.labels.series[iCount].toString().toLowerCase() === 'budget') {
                        fBudgetForecastDiff = oChartSeries[0].data[iCount] - oChartSeries[0].data[iCount + 1];
                        if (fBudgetForecastDiff < 0) {
                            fDiffDivHeight = (oChartDiv.clientHeight - fTopSpace) * Math.abs(fBudgetForecastDiff) / (Math.abs(oMinMax.max) + Math.abs(oMinMax.min));
                            oDiffDiv = document.createElement('div');
                            MAQ.applyStyle(oDiffDiv, {
                                marginTop: fNormalizedHeight + fTopSpace - fCellDivHeight - fDiffDivHeight + 'px',
                                opacity: 0.3,
                                height: fDiffDivHeight + 'px',
                                position: 'absolute',
                                width: fColumnDivWidth + 'px',
                                backgroundColor: oPlotOptions.colors[iCount]
                            });
                            oBackColumnDiv.appendChild(oDiffDiv);
                            oDiffLabelDiv = document.createElement('div');
                            oDiffLabelDiv.style.marginTop = fNormalizedHeight + fTopSpace - fCellDivHeight - fDiffDivHeight - chartConfigOptions.plotOptions.waterfall.auxiliaryLabel.height + 'px';
                            oDiffLabelDiv.style.position = 'absolute';
                            oDiffLabelDiv.style.width = fColumnDivWidth + 'px';
                            oDiffLabelDiv.innerHTML = MAQ.applyFormatter(Math.abs(fBudgetForecastDiff), chartConfigOptions.plotOptions.waterfall.auxiliaryLabel.formatter);
                            MAQ.applyStyle(oDiffLabelDiv, chartConfigOptions.plotOptions.waterfall.auxiliaryLabel.style);
                            oBackColumnDiv.appendChild(oDiffLabelDiv);
                            fBudgetForecastDiff = 0;
                        }
                    }
                    if (chartConfigOptions.xAxis.labels.series[iCount].toString().toLowerCase() === 'forecast') {
                        if (fBudgetForecastDiff > 0) {
                            fDiffDivHeight = (oChartDiv.clientHeight - fTopSpace) * Math.abs(fBudgetForecastDiff) / (Math.abs(oMinMax.max) + Math.abs(oMinMax.min));
                            oDiffDiv = document.createElement('div');
                            MAQ.applyStyle(oDiffDiv, {
                                marginTop: fNormalizedHeight + fTopSpace - fCellDivHeight - fDiffDivHeight + 'px',
                                opacity: 0.3,
                                height: fDiffDivHeight + 'px',
                                position: 'absolute',
                                width: fColumnDivWidth + 'px',
                                backgroundColor: oPlotOptions.colors[iCount]
                            });
                            oBackColumnDiv.appendChild(oDiffDiv);
                            oDiffLabelDiv = document.createElement('div');
                            oDiffLabelDiv.style.marginTop = fNormalizedHeight + fTopSpace - fCellDivHeight - fDiffDivHeight - chartConfigOptions.plotOptions.waterfall.auxiliaryLabel.height + 'px';
                            oDiffLabelDiv.style.position = 'absolute';
                            oDiffLabelDiv.style.width = fColumnDivWidth + 'px';
                            oDiffLabelDiv.innerHTML = MAQ.applyFormatter(Math.abs(fBudgetForecastDiff), chartConfigOptions.plotOptions.waterfall.auxiliaryLabel.formatter);
                            MAQ.applyStyle(oDiffLabelDiv, chartConfigOptions.plotOptions.waterfall.auxiliaryLabel.style);
                            oBackColumnDiv.appendChild(oDiffLabelDiv);
                        }
                    }
                    oPlotOptions.waterfall.staggeredLine.staggeredLineStyle.marginLeft = '0px';
                    oPlotOptions.waterfall.staggeredLine.staggeredLineStyle.width = oChartDiv.clientWidth - oPlotOptions.waterfall.padding + 'px';
                } else {
                    if (oPlotOptions.waterfall.staggeredLine.align === 'left') {
                        oPlotOptions.waterfall.staggeredLine.staggeredLineStyle.marginLeft = (iCount ? iCount - 1 : 0) * (fColumnDivWidth + oPlotOptions.waterfall.padding) - oPlotOptions.waterfall.padding + 'px';
                    } else {
                        oPlotOptions.waterfall.staggeredLine.staggeredLineStyle.marginLeft = iCount * (fColumnDivWidth + oPlotOptions.waterfall.padding) + 'px';
                    }
                    oPlotOptions.waterfall.staggeredLine.staggeredLineStyle.width = oChartDiv.clientWidth - iCount * (fColumnDivWidth + oPlotOptions.waterfall.padding) - oPlotOptions.waterfall.padding + 'px';
                }
            }
        }
        // If single stack has to be created
        if (oPlotOptions.waterfall.singleColumnStack.enabled && oStackedDiv && 0 !== iCount && oChartSeries[0].stacked[iCount]) {
            oStackedDiv.appendChild(oCellDiv);
        } else {
            oBackColumnDiv.appendChild(oCellDiv);
        }
        if (oPlotOptions.waterfall.singleColumnStack.enabled && oChartSeries[0].stacked[iCount]) {
            if (iSum > oChartSeries[0].data[oChartSeries[0].data.length - 1] && 0 < iNegativeCheck) {
                oCellDiv.style.marginTop = fTopSpace + 'px';
            }
            if (0 > oChartSeries[0].data[iCount]) {
                iMarginTopNegative = (parseInt(oCellDiv.style.marginTop) - parseInt(oStackedDiv.firstChild.style.height) < fTopSpace ? fTopSpace : parseInt(oCellDiv.style.marginTop) - parseInt(oStackedDiv.firstChild.style.height)) + 'px';
                if (0 > iNegativeCheck) {
                    isNegative = true;
                    if (0 === iCount) {
                        iNegativeHeight = parseInt(oStackedDiv.firstChild.style.height);
                        oCellDiv.style.marginTop = parseFloat(iMarginTopNegative) + iNegativeHeight + 'px';
                        if (parseInt(oCellDiv.style.marginTop) + parseInt(oCellDiv.style.height) > parseInt(oStackedDiv.style.height) - 20) {
                            oCellDiv.style.marginTop = parseFloat(oStackedDiv.style.height) - parseFloat(oCellDiv.style.height) + 'px';
                        }
                    } else {
                        oCellDiv.style.marginTop = 0;
                    }
                } else {
                    oStackedDiv.firstChild.style.marginTop = iMarginTopNegative;
                }
            } else {
                if (!isNegative || 1 === iNegativeCheck) {
                    oStackedDiv.firstChild.style.marginTop = oCellDiv.style.marginTop;
                } else {
                    oCellDiv.style.marginTop = -fCellDivHeight - iNegativeHeight + 'px';
                }
            }
            if (1 === iNegativeCheck) {
                oCellDiv.style.marginTop = 0;
            }
        }
        if (oChartSeries[0].data[iCount] && (oPlotOptions.waterfall.staggeredLine.enabled || oChartSeries[0].staggeredLineEnable[iCount])) {
            // Add only if data exists
            oDottedLineDiv = document.createElement('div');
            oPlotOptions.waterfall.staggeredLine.staggeredLineStyle.position = 'absolute';
            MAQ.applyStyle(oDottedLineDiv, oPlotOptions.waterfall.staggeredLine.staggeredLineStyle);
            oChartDiv.appendChild(oDottedLineDiv);
        }
        // Create xLabel and chart metric
        if (chartConfigOptions.xAxis.labels.enabled) {
            oMVDiv = document.createElement('div');
            oMVDiv.style.width = fColumnDivWidth + 'px';
            oMVDiv.style.cssFloat = 'left';
            if (oPlotOptions.waterfall.singleColumnStack.enabled && 0 === iCount) {
                sContent = oPlotOptions.waterfall.singleColumnStack.stackLabel;
            } else {
                sContent = chartConfigOptions.xAxis.labels.series[iCount];
            }
            if (chartConfigOptions.xAxis.labels.formatter) {
                oMVDiv.innerHTML = MAQ.applyFormatter(sContent, chartConfigOptions.xAxis.labels.formatter);
            } else {
                oMVDiv.innerHTML = sContent;
            }
            MAQ.applyStyle(oMVDiv, chartConfigOptions.plotOptions.waterfall.section.vertical.seriesDivision.chartMetricStyle[0]);
            if (!(oPlotOptions.waterfall.singleColumnStack.enabled && 0 !== iCount && oChartSeries[0].stacked[iCount])) {
                oChartMetricDivArray[0].appendChild(oMVDiv);
            }
            if (iCount !== chartConfigOptions.xAxis.labels.series.length - 1) {
                oGapDiv = document.createElement('div');
                oGapDiv.style.width = oPlotOptions.waterfall.padding + 'px';
                oGapDiv.style.cssFloat = 'left';
                oGapDiv.style.height = oChartMetricDivArray[0].clientHeight + 'px';
                oChartMetricDivArray[0].appendChild(oGapDiv);
            }
        }
        for (jCount = 0; jCount < oChartSeries.length; jCount += 1) {
            oMVDiv = document.createElement('div');
            oMVDiv.style.width = fColumnDivWidth + 'px';
            oMVDiv.style.cssFloat = 'left';
            if (oPlotOptions.waterfall.singleColumnStack.enabled && 0 === iCount) {
                if (oPlotOptions.waterfall.singleColumnStack.formatter) {
                    sContent = MAQ.applyFormatter(iSum, oPlotOptions.waterfall.singleColumnStack.formatter);
                } else {
                    sContent = iSum.toString();
                }
            } else {
                // Custom formatter
                if (oChartSeries[jCount].formatter) {
                    sContent = MAQ.applyFormatter(oChartSeries[jCount], iCount, oChartSeries[jCount].formatter);
                } else {
                    sContent = oChartSeries[jCount].data[iCount];
                }
            }
            oMVDiv.innerHTML = sContent;
            MAQ.applyStyle(oMVDiv, chartConfigOptions.plotOptions.waterfall.section.vertical.seriesDivision.chartMetricStyle[jCount + 1]);
            if (!(oPlotOptions.waterfall.singleColumnStack.enabled && 0 !== iCount && oChartSeries[0].stacked[iCount])) {
                oChartMetricDivArray[jCount + 1].appendChild(oMVDiv);
            }
            if (iCount !== oChartSeries[jCount].data.length - 1) {
                oGapDiv = document.createElement('div');
                oGapDiv.style.width = oPlotOptions.waterfall.padding + 'px';
                oGapDiv.style.cssFloat = 'left';
                oGapDiv.style.height = oChartMetricDivArray[0].clientHeight + 'px';
                oChartMetricDivArray[jCount + 1].appendChild(oGapDiv);
            }
        }
        for (jCount = 0; jCount < oNonChartSeries.length; jCount += 1) {
            oMVDiv = document.createElement('div');
            oMVDiv.style.width = fColumnDivWidth + 'px';
            oMVDiv.style.cssFloat = 'left';
            if (oNonChartSeries[jCount].formatter) {
                oMVDiv.innerHTML = MAQ.applyFormatter(oNonChartSeries[jCount].data[iCount], oNonChartSeries[jCount].formatter);
            } else {
                oMVDiv.innerText = oNonChartSeries[jCount].data[iCount];
            }
            MAQ.applyStyle(oMVDiv, chartConfigOptions.plotOptions.waterfall.section.vertical.seriesDivision.nonChartMetricStyle[jCount]);
            oNonChartMetricDivArray[jCount].appendChild(oMVDiv);
            if (iCount !== oNonChartSeries[jCount].data.length - 1) {
                oGapDiv = document.createElement('div');
                oGapDiv.style.width = oPlotOptions.waterfall.padding + 'px';
                oGapDiv.style.cssFloat = 'left';
                oGapDiv.style.height = oNonChartMetricDivArray[0].clientHeight + 'px';
                oNonChartMetricDivArray[jCount].appendChild(oGapDiv);
            }
        }
    }
};
// Function to create brick
MAQ.createBrickChart = function(chartOptions) {
    'use strict';
    if (chartOptions.series.length) {
        var oSeries = chartOptions.series,
            oPlotOptions = chartOptions.plotOptions,
            oChartPlotOptions = oPlotOptions.brick,
            oContainer = document.querySelector('#' + chartOptions.chart.renderTo),
            arraySeries = chartOptions.series,
            iSeriesLength = arraySeries.length,
            iRowCounter,
            iColumnCounter,
            oBrickGrid = document.createElement('div'),
            oRow = null,
            oCell = null,
            sColor, iSeriesIterator = 0,
            iCellIterator = 0,
            iSum = 0,
            brickCell,
            iBrickCellLength,
            iBrickCount = oChartPlotOptions.brickCount,
            iRowIncrement,
            iColumnIncrement,
            iColumnLength,
            oDataInfo = {
                max: 0,
                min: 0,
                total: 0
            };
        document.querySelector('#' + chartOptions.chart.renderTo).innerHTML = '';
        // Obtain total for the series
        oDataInfo = MAQ.getMinMax(oSeries, oDataInfo.min, oDataInfo.max, 'data');
        MAQ.applyStyle(oContainer, chartOptions.chart.style);
        chartOptions.availX = 0;
        chartOptions.availY = 0;
        chartOptions.availWidth = oContainer.clientWidth;
        chartOptions.availHeight = oContainer.clientHeight;
        MAQ.applyMargin(chartOptions, chartOptions.chart.margin);
        // Create Legends
        chartOptions.chart.style.width = oContainer.clientWidth + 'px';
        chartOptions.chart.style.height = oContainer.clientHeight / 8 + 'px';
        chartOptions.svgNS = 'http://www.w3.org/2000/svg';
        chartOptions.xlinkNS = 'http://www.w3.org/1999/xlink';
        MAQ.createSVGDoc(chartOptions);
        // Create SVG document
        MAQ.styles.addClass(oBrickGrid, 'BrickChart');
        for (iRowCounter = 0; iRowCounter < iBrickCount; iRowCounter += 1) {
            oRow = document.createElement('div');
            oRow.style.float = 'left';
            MAQ.styles.addClass(oRow, 'column');
            oBrickGrid.appendChild(oRow);
            for (iColumnCounter = 0; iColumnCounter < iBrickCount; iColumnCounter += 1) {
                oCell = document.createElement('div');
                oRow.appendChild(oCell);
                MAQ.applyStyle(oCell, oChartPlotOptions.brickStyle);
                MAQ.styles.addClass(oCell, 'brickCell');
            }
        }
        MAQ.applyStyle(oBrickGrid, oChartPlotOptions.style);
        oBrickGrid.style.marginTop = -(oContainer.clientHeight - oContainer.clientHeight / 8 - oContainer.style.marginTop) + 'px';
        oContainer.appendChild(oBrickGrid);
        brickCell = document.querySelectorAll('.brickCell');
        // Updated type to any to avoid warnings while accessing the properties of cell.
        iBrickCellLength = brickCell.length;
        // Find the percentage of first data point
        oSeries[0].data = oSeries[0].data / oDataInfo.total * 100;
        iSum = Math.round(oSeries[0].data);
        switch (oChartPlotOptions.type) {
            case 'horizontal':
                iColumnIncrement = 1;
                iColumnLength = iBrickCount;
                iRowIncrement = oChartPlotOptions.brickCount;
                break;
            case 'vertical':
                iColumnIncrement = oChartPlotOptions.brickCount;
                iColumnLength = iBrickCellLength;
                iRowIncrement = 1;
                break;
            default:
                return false;
        }
        for (iColumnCounter = 0; iSeriesIterator < iSeriesLength && iCellIterator < iBrickCellLength && iColumnCounter < iColumnLength; iColumnCounter += iColumnIncrement) {
            for (iRowCounter = iColumnCounter; iRowCounter < iBrickCellLength; iRowCounter += iRowIncrement) {
                sColor = oChartPlotOptions.color[iSeriesIterator];
                if (0 === iSum) {
                    sColor = oChartPlotOptions.color[iSeriesIterator + 1];
                }
                if (undefined !== oSeries[iSeriesIterator].enabled && !oSeries[iSeriesIterator].enabled) {
                    brickCell[iRowCounter].style.opacity = 0.5;
                }
                // Change the color for series depending upon the data value
                if ((iSum - 1 > 0 ? iSum - 1 : 0) === iCellIterator && iSeriesIterator < iSeriesLength - 1) {
                    // Calculate percentage for each data unit
                    oSeries[iSeriesIterator + 1].data = oSeries[iSeriesIterator + 1].data / oDataInfo.total * 100;
                    iSum += Math.round(oSeries[iSeriesIterator + 1].data) || 0;
                    iSeriesIterator += 1;
                }
                brickCell[iRowCounter].style.backgroundColor = sColor;
                iCellIterator += 1;
            }
        }
        MAQ.drawLegend(chartOptions);
    } else {
        return false;
    }
};
/*
MAQ.getSeriesValidation: Validate waterfall chart data series
@param {chartConfigOptions} user configuration parameters
*/
MAQ.getSeriesValidation = function(chartConfigOptions) {
    'use strict';
    var oChartSeries = [],
        jCount = 0,
        boolDataCheck = false,
        oChartPlotOptions = chartConfigOptions.plotOptions[chartConfigOptions.chart.type];

    function validateDataNode(iDataNode) {
        if (!parseFloat(iDataNode)) {
            return true;
        }
    }
    for (jCount = 0; jCount < chartConfigOptions.series.length; jCount += 1) {
        if (oChartPlotOptions.errorCheck.notNullSeries.indexOf(chartConfigOptions.series[jCount].name) !== -1) {
            boolDataCheck = chartConfigOptions.series[jCount].data.every(validateDataNode);
            if (!chartConfigOptions.series[jCount].data.length || boolDataCheck) {
                throw 'No data';
            }
        }
    }
    return oChartSeries;
};
MAQ.getChartSeries = function(oLabelArray, chartConfigOptions) {
    'use strict';
    var oChartSeries = [],
        jCount = 0;
    for (jCount = 0; jCount < chartConfigOptions.series.length; jCount += 1) {
        if (oLabelArray.indexOf(chartConfigOptions.series[jCount].name) !== -1) {
            oChartSeries.push(chartConfigOptions.series[jCount]);
        }
    }
    return oChartSeries;
};
MAQ.getForecastMinMax = function(oDataArray, min, max, fieldName) {
    'use strict';
    var oMergedDataArray = [],
        jCount = 0,
        oMinMax = null;
    oMergedDataArray[0] = 0;
    for (jCount = 0; jCount < oDataArray.data.length; jCount += 1) {
        if (oDataArray.stacked[jCount]) {
            oMergedDataArray[0] += oDataArray.data[jCount];
        } else {
            oMergedDataArray[oMergedDataArray.length] = oDataArray.data[jCount];
        }
    }
    oMinMax = MAQ.getMinMax(oMergedDataArray, min, max);
    oMinMax.gapPoint = oMergedDataArray[0];
    return oMinMax;
};
/*
MAQ.bowTieDrill: Drills in data of bow-tie chart
@param {evt} event object
@param {oParam} param collection
*/
function bowTieDrill(evt, oParam) {
    'use strict';
    oParam.chartConfig.plotOptions.bowtie.branch.currentLevel += 1;
    var oCurrentElement = event.target || evt.srcElement;
    var oParent = oCurrentElement.parentNode;
    var iCounter = oParam.position;
    var oSeries = oParam.series;
    var oConfig = oParam.chartConfig;
    var sChartType = oConfig.chart.type;
    var oBowTie = oConfig.plotOptions[sChartType];
    var oDataInfo;
    oBowTie.showTotal.side = oParam.side;
    oBowTie.showTotal.title.text = oSeries[iCounter].name;
    if (oParam.side === 'left') {
        oConfig.series[0].child = oSeries[iCounter].child;
        oDataInfo = MAQ.createTotalArea(oConfig, oBowTie, oParent.parentNode);
        MAQ.createSideSpecifiedBow(oConfig, oParam.branchGroup, oParam.gridGroup, oBowTie, oDataInfo.datainfo[0], oDataInfo.series[0], 'left');
    } else if (oParam.side === 'right') {
        oConfig.series[1].child = oSeries[iCounter].child;
        oDataInfo = MAQ.createTotalArea(oConfig, oBowTie, oParent.parentNode);
        MAQ.createSideSpecifiedBow(oConfig, oParam.branchGroup, oParam.gridGroup, oBowTie, oDataInfo.datainfo[1], oDataInfo.series[1], 'right');
    } else {
        oConfig.series[0].child = oSeries[iCounter].child;
        MAQ.createHalfBowTieChart(oConfig);
        oBowTie.branch.currentLevel += 1;
        if (oBowTie.branch.currentLevel > 0) {
            var oDrillBackImage = {
                x: oConfig.svgELE.x.baseVal.value - 12,
                y: oDimensionTotalTitle.y,
                width: 24,
                height: 24
            };
            var oBackImage = MAQ.createSVGElement(oConfig.svgNS, 'image', oDrillBackImage);
            oGrpELESum.appendChild(oBackImage);
            oParam = {
                chartConfig: oConfig,
                series: oConfig.series
            };
            MAQ.addEventListener(oBackImage, 'click', oBowTie.branch.drillBackFunction, oParam);
            oBackImage.setAttributeNS(oConfig.xlinkNS, 'xlink:href', '../PublishingImages/PreviousArrow.png');
            var oImageDim = MAQ.getObjectDimension(oBackImage);
            MAQ.addAttr(oBackImage, 'y', oDrillBackImage.y - oDimensionTotalTitle.height - oImageDim.height);
        }
    }
}

function bowTieDependentDrill(evt, oParam) {
    'use strict';
    if (oParam.drillFunction && typeof window[oParam.drillFunction] === 'function') {
        oParam.chartConfig.plotOptions.bowtie.branch.currentLevel += 1;
        var oUserConfig = window[oParam.drillFunction](evt, oParam);
        if (oUserConfig) {
            MAQ.createBowTieChart(oUserConfig);
        }
    }
}

function dynamicSort(property, flag) {
    'use strict';
    if (flag) {
        return function(a, b) {
            return a[property] < b[property] ? -1 : a[property] > b[property] ? 1 : 0;
        };
    } else {
        return function(a, b) {
            return b[property] < a[property] ? -1 : b[property] > a[property] ? 1 : 0;
        };
    }
}

function getContainerRelativeCord(e) {
    'use strict';
    var posx = 0;
    var posy = 0;
    if (!e) {
        e = window.event;
    }
    if (e.pageX || e.pageY) {
        posx = e.pageX;
        posy = e.pageY;
    } else if (e.clientX || e.clientY) {
        posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
        posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
    }
    return {
        x: posx,
        y: posy
    };
}

function treemapDrill(evt, oParam) {
    'use strict';
    var chartConfigOptions = oParam.chartConfigOptions;
    var oTreemapOptions = chartConfigOptions.plotOptions.treemap;
    if (evt.which === 1) {
        if (oParam.data.child) {
            chartConfigOptions.series = oParam.data;
            oTreemapOptions.selectedValue[oTreemapOptions.currentLevel] = oParam.name;
            oTreemapOptions.currentLevel += 1;
            chartConfigOptions.container = document.getElementById(chartConfigOptions.chart.renderTo);
            chartConfigOptions.container.innerHTML = '';
            MAQ.createTreemap(chartConfigOptions);
            var oNav = document.getElementById('navig');
            if (oTreemapOptions.currentLevel === 0) {
                oNav.innerHTML = 'All';
            } else {
                oNav.innerHTML += ' -> ' + oTreemapOptions.selectedValue[oTreemapOptions.currentLevel - 1];
            }
        }
    } else {
        chartConfigOptions.series.child = clone(oTreemapOptions.original.child);
        if (oTreemapOptions.currentLevel > 0) {
            oTreemapOptions.currentLevel -= 1;
        }
        MAQ.getDataR(oTreemapOptions.currentLevel, chartConfigOptions, 0);
        chartConfigOptions.container = document.getElementById(chartConfigOptions.chart.renderTo);
        chartConfigOptions.container.innerHTML = '';
        MAQ.createTreemap(chartConfigOptions);
    }
}

function treemapInfoBox(evt, oParam) {
    'use strict';
    var chartConfigOptions = oParam.chartConfigOptions;
    var oCord = getContainerRelativeCord(evt);
    var oToolTip = chartConfigOptions.tooltipDiv;
    var sChunk = '<b>Name:</b> ' + oParam.data.name + '<br /><b>Revenue:</b> ' + oParam.data.revenue;
    oToolTip.innerHTML = sChunk;
    oToolTip.style.display = 'block';
    var fTopCordinate = oCord.y - oToolTip.clientHeight - 5;
    if (fTopCordinate <= 10) {
        fTopCordinate = oCord.y + 10;
    }
    var fLeftCordinate = oCord.x - oToolTip.clientWidth - 10;
    if (fLeftCordinate <= 10) {
        fLeftCordinate = oCord.x + 10;
    }
    oToolTip.style.top = fTopCordinate + 'px';
    oToolTip.style.left = fLeftCordinate + 'px';
    if (!oToolTip.clientWidth) {
        chartConfigOptions.container.appendChild(oToolTip);
    }
}
MAQ.calculateAspectRatio = function(chartConfigOptions, iDimensionX, iDimensionY, iSum, iLastIndex) {
    'use strict';
    var iDataCounter = 0,
        oDataArray = chartConfigOptions.series.child,
        sFieldName = chartConfigOptions.plotOptions.treemap.fieldName,
        iCurrentDimensionX = iDimensionX,
        iIndividualHeight = 0,
        oLayout = chartConfigOptions.plotOptions.treemap.currentLayout;
    for (iDataCounter = 0; iDataCounter <= iLastIndex; iDataCounter += 1) {
        iIndividualHeight = oDataArray[iDataCounter][sFieldName] / iSum * iDimensionX;
        oLayout[iDataCounter] = iIndividualHeight;
        if (iIndividualHeight <= iCurrentDimensionX) {
            iCurrentDimensionX = iIndividualHeight;
        }
    }
    return Math.max(iCurrentDimensionX / iDimensionY, iDimensionY / iCurrentDimensionX);
};
MAQ.plotArea = function(chartConfigOptions, iWidth, iHeight, numberOfValues, iDimension, a, b) {
    'use strict';
    var iCounter = 0,
        oContainerDiv = chartConfigOptions.container,
        oTreemapOptions = chartConfigOptions.plotOptions.treemap,
        oPrevLayout = oTreemapOptions.prevLayout,
        oData = chartConfigOptions.series.child,
        leftDiv = document.createElement('div'),
        div,
        oParam,
        fParentHeight,
        titleDiv,
        width;
    leftDiv.style[a] = Math.round(iDimension) + 'px';
    leftDiv.style[b] = iHeight + 'px';
    leftDiv.style.cssFloat = 'left';
    oContainerDiv.appendChild(leftDiv);
    for (iCounter = 0; iCounter < numberOfValues; iCounter += 1) {
        if (Math.round(oPrevLayout[iCounter])) {
            div = document.createElement('div');
            div.style.cssFloat = 'left';
            div.style.border = '1px solid white';
            div.style[b] = oPrevLayout[iCounter] + 'px';
            div.style[a] = Math.round(iDimension) + 'px';
            if (typeof window[oTreemapOptions.fieldColor] === 'function') {
                window[oTreemapOptions.fieldColor](div, oData[iCounter], oTreemapOptions.original.sum);
            } else {
                div.style.backgroundColor = '#CC0000';
            }
            leftDiv.appendChild(div);
            if (oTreemapOptions.drillThrough) {
                if (oData[iCounter].child) {
                    div.style.cursor = 'pointer';
                }
                oParam = {
                    chartConfigOptions: chartConfigOptions,
                    name: oData[iCounter][oTreemapOptions.title.fieldName],
                    level: oTreemapOptions.currentLevel,
                    data: oData[iCounter]
                };
                MAQ.addEventListener(div, 'mousedown', treemapDrill, oParam);
                MAQ.addEventListener(div, 'mousemove', treemapInfoBox, oParam);
                MAQ.addEventListener(div, 'mouseout', hideToolTip, chartConfigOptions.tooltipDiv);
            }
            if (oTreemapOptions.title && oTreemapOptions.title.fieldName) {
                fParentHeight = div.clientHeight;
                titleDiv = document.createElement('div');
                if (oTreemapOptions.title.style) {
                    MAQ.applyStyle(titleDiv, oTreemapOptions.title.style);
                }
                width = 0;
                if (b === 'width') {
                    width = Math.round(oPrevLayout[iCounter]);
                } else {
                    width = Math.round(iDimension);
                }
                titleDiv.style.width = width - 2 + 'px';
                if (oData[iCounter][oTreemapOptions.title.fieldName]) {
                    if (undefined !== titleDiv.innerText) {
                        titleDiv.innerText = oData[iCounter][oTreemapOptions.title.fieldName];
                    } else {
                        titleDiv.textContent = oData[iCounter][oTreemapOptions.title.fieldName];
                    }
                } else {
                    if (undefined !== titleDiv.innerText) {
                        titleDiv.innerText = 'NA';
                    } else {
                        titleDiv.textContent = 'NA';
                    }
                }
                div.appendChild(titleDiv);
                if (fParentHeight < titleDiv.clientHeight) {
                    div.removeChild(titleDiv);
                }
            }
        }
    }
    if (oData.length > 1) {
        var RightDiv = document.createElement('div');
        RightDiv.style[a] = iWidth - Math.round(iDimension) + 'px';
        RightDiv.style[b] = iHeight + 'px';
        RightDiv.style.cssFloat = 'right';
        oContainerDiv.appendChild(RightDiv);
        chartConfigOptions.container = RightDiv;
        chartConfigOptions.series.child = oData.splice(numberOfValues);
        MAQ.createTreemap(chartConfigOptions);
    }
};
MAQ.calculateDimension = function(chartConfigOptions, iDimensionX, iDimensionY, iTotal, bFlag) {
    'use strict';
    var iPrevAspectRatio = 0,
        iLoopCounter = 0,
        iSum = 0,
        iCurrAspectRatio = 0,
        oContainerDiv = chartConfigOptions.container,
        oData = chartConfigOptions.series.child,
        sFieldName = chartConfigOptions.plotOptions.treemap.fieldName,
        iCalcDimension = 0;
    for (iLoopCounter = 0; iLoopCounter < oData.length; iLoopCounter += 1) {
        iSum = iSum + oData[iLoopCounter][sFieldName];
        iCalcDimension = iSum / iTotal * iDimensionX;
        iCurrAspectRatio = MAQ.calculateAspectRatio(chartConfigOptions, iDimensionY, iCalcDimension, iSum, iLoopCounter);
        if (iPrevAspectRatio && iPrevAspectRatio < iCurrAspectRatio) {
            break;
        }
        chartConfigOptions.plotOptions.treemap.prevLayout = chartConfigOptions.plotOptions.treemap.currentLayout.slice(0);
        iPrevAspectRatio = iCurrAspectRatio;
    }
    if (oData.length > 1) {
        if (iLoopCounter === oData.length) {
            iLoopCounter -= 1;
        }
        iCalcDimension = (iSum - oData[iLoopCounter][sFieldName]) / iTotal * iDimensionX;
    }
    if (bFlag) {
        MAQ.plotArea(chartConfigOptions, oContainerDiv.clientWidth, oContainerDiv.clientHeight, iLoopCounter, iCalcDimension, 'width', 'height');
    } else {
        MAQ.plotArea(chartConfigOptions, oContainerDiv.clientHeight, oContainerDiv.clientWidth, iLoopCounter, iCalcDimension, 'height', 'width');
    }
};
MAQ.createTreemap = function(chartConfigOptions) {
    'use strict';
    var oTreemapOptions = chartConfigOptions.plotOptions.treemap;
    var oContainer = chartConfigOptions.container;
    var oData = chartConfigOptions.series.child,
        iWidth = oContainer.clientWidth,
        iHeight = oContainer.clientHeight,
        iTotal = MAQ.getMinMax(oData, 0, 0, oTreemapOptions.fieldName).total;
    oData.sort(dynamicSort(oTreemapOptions.fieldName, false));
    if (oData.length > 0) {
        if (iWidth >= iHeight) {
            MAQ.calculateDimension(chartConfigOptions, iWidth, iHeight, iTotal, true);
        } else {
            MAQ.calculateDimension(chartConfigOptions, iHeight, iWidth, iTotal, false);
        }
    }
    if (oTreemapOptions.currentLevel === 0) {
        var oNav = document.getElementById('navig');
        oNav.innerHTML = 'All';
    }
};
MAQ.getTriangleCoords = function(cX, cY, r) {
    'use strict';
    var triCoords = {};
    triCoords.x1 = cX;
    triCoords.y1 = cY - r / 1.8;
    triCoords.x2 = cX;
    triCoords.y2 = cY + r / 1.8;
    triCoords.x3 = cX + r / 2;
    triCoords.y3 = cY;
    return 'M' + triCoords.x1 + ' ' + triCoords.y1 + ' L' + triCoords.x2 + ' ' + triCoords.y2 + ' L' + triCoords.x3 + ' ' + triCoords.y3 + ' Z';
};
MAQ.getIntersectionPoints = function(config, xPos) {
    'use strict';
    var fIndex = xPos / config.plotIntervalWidth,
        iLowerIndex = Math.floor(fIndex),
        iHigerIndex = Math.ceil(fIndex),
        delta = fIndex - iLowerIndex,
        fLineLeftPointX = [],
        fLineRightPointX = [],
        fLineLeftPointY = [],
        fLineRightPointY = [],
        fLineLeftValues = [],
        fLineRightValues = [],
        intersectValue = [],
        iCounter;
    for (iCounter = 0; iCounter < config.series.length; iCounter += 1) {
        fLineLeftPointX[iCounter] = config.series[iCounter].xPos[iLowerIndex] - config.availXLift;
        fLineRightPointX[iCounter] = config.series[iCounter].xPos[iHigerIndex] - config.availXLift;
        fLineLeftPointY[iCounter] = config.series[iCounter].yPos[iLowerIndex] - config.availYLift;
        fLineRightPointY[iCounter] = config.series[iCounter].yPos[iHigerIndex] - config.availYLift;
        fLineLeftValues[iCounter] = config.series[iCounter].data[iLowerIndex];
        fLineRightValues[iCounter] = config.series[iCounter].data[iHigerIndex];
        intersectValue[iCounter] = fLineLeftValues[iCounter] + (fLineRightValues[iCounter] - fLineLeftValues[iCounter]) * delta;
        intersectValue[iCounter] = intersectValue[iCounter].toFixed(1);
    }
    var circleX = [],
        circleY = [],
        slope;
    for (iCounter = 0; iCounter < config.series.length; iCounter += 1) {
        circleX[iCounter] = xPos;
        slope = (fLineRightPointY[iCounter] - fLineLeftPointY[iCounter]) / (fLineRightPointX[iCounter] - fLineLeftPointX[iCounter]);
        if (isNaN(slope)) {
            slope = 0;
        }
        circleY[iCounter] = slope * (xPos - fLineLeftPointX[iCounter]) + fLineLeftPointY[iCounter];
    }
    return {
        circleX: circleX,
        circleY: circleY,
        values: intersectValue,
        lowerIndex: iLowerIndex,
        higherIndex: iHigerIndex
    };
};
MAQ.CreatePattern = function(chartConfigOptions, iID) {
    'use strict';
    var sPatID = '';
    if (undefined !== chartConfigOptions.plotOptions.pattern[iID] && '' !== chartConfigOptions.plotOptions.pattern[iID]) {
        var sPattern = chartConfigOptions.plotOptions.pattern[iID].toUpperCase();
        if ('#' === sPattern[0] || 0 === sPattern.indexOf('RGB') || 0 === sPattern.indexOf('RGBA')) {
            sPattern = 'COLOR';
        }
        sPatID = chartConfigOptions.chart.renderTo + 'Pat' + sPattern;
        var ele = document.getElementById(sPatID),
            oDefsELE, oPatternAttr, oPatELE, oCircleAttr, oLineAttr;
        if (null !== ele) {
            return sPatID;
        }
        switch (sPattern) {
            case 'COLOR':
                sPatID = sPattern;
                break;
            case 'DOTS':
                oDefsELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'defs');
                oPatternAttr = {
                    id: sPatID,
                    x: 0,
                    y: 0,
                    width: 4,
                    height: 4,
                    patternUnits: 'userSpaceOnUse'
                };
                oPatELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'pattern', oPatternAttr);
                oCircleAttr = {
                    cx: 2,
                    cy: 2,
                    r: 1,
                    fill: '#7DBBDB'
                };
                oPatELE.appendChild(MAQ.createSVGElement(chartConfigOptions.svgNS, 'circle', oCircleAttr));
                oDefsELE.appendChild(oPatELE);
                chartConfigOptions.svgELE.appendChild(oDefsELE);
                break;
            case 'HBARS':
                oDefsELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'defs');
                oPatternAttr = {
                    id: sPatID,
                    x: 0,
                    y: 0,
                    width: 4,
                    height: 4,
                    patternUnits: 'userSpaceOnUse'
                };
                oPatELE = MAQ.createSVGElement(chartConfigOptions.svgNS, 'pattern', oPatternAttr);
                oLineAttr = {
                    x1: 0,
                    y1: 0,
                    x2: 100,
                    y2: 0,
                    'stroke-width': 4,
                    stroke: '#5e9cd2'
                };
                oPatELE.appendChild(MAQ.createSVGElement(chartConfigOptions.svgNS, 'line', oLineAttr));
                oLineAttr.stroke = 'white';
                oLineAttr.y2 = oLineAttr.y1 + oLineAttr['stroke-width'];
                oLineAttr.y1 += oLineAttr['stroke-width'];
                oLineAttr['stroke-width'] = 4;
                oPatELE.appendChild(MAQ.createSVGElement(chartConfigOptions.svgNS, 'line', oLineAttr));
                oDefsELE.appendChild(oPatELE);
                chartConfigOptions.svgELE.appendChild(oDefsELE);
                break;
            default:
                sPatID = '';
                break;
        }
    }
    return sPatID;
};
MAQ.createMarker = function(oPlotOptions, oAttrs, svgNS) {
    'use strict';
    var oMarker = oPlotOptions.marker,
        oShape,
        sShape = oMarker.shape[(oMarker.markers.length - 1) % oMarker.shape.length],
        oMarkerAttr = {};
    switch (sShape.toLowerCase()) {
        case 'diamond':
            sShape = 'rect';
            oMarkerAttr = {
                x: oAttrs.x - oMarker.width / 2,
                y: oAttrs.y - oMarker.width / 2,
                width: oMarker.width,
                height: oMarker.width,
                transform: 'rotate(45,' + oAttrs.x + ',' + oAttrs.y + ')'
            };
            break;
        case 'square':
            sShape = 'rect';
            oMarkerAttr = {
                x: oAttrs.x - oMarker.width / 2,
                y: oAttrs.y - oMarker.width / 2,
                width: oMarker.width,
                height: oMarker.width
            };
            break;
        case 'tridown':
            sShape = 'path';
            oMarkerAttr = {
                d: MAQ.getTriangleCoords(oAttrs.x, oAttrs.y, oMarker.width),
                transform: 'rotate(90,' + oAttrs.x + ',' + oAttrs.y + ')'
            };
            break;
        case 'triup':
            sShape = 'path';
            oMarkerAttr = {
                d: MAQ.getTriangleCoords(oAttrs.x, oAttrs.y, oMarker.width),
                transform: 'rotate(-90,' + oAttrs.x + ',' + oAttrs.y + ')'
            };
            break;
        default:
            sShape = 'circle';
            oMarkerAttr = {
                cx: oAttrs.x,
                cy: oAttrs.y,
                r: oMarker.width / 2
            };
    }
    oMarkerAttr.fill = oMarker.fillColor;
    oMarkerAttr.stroke = oMarker.lineColor;
    oMarkerAttr['stroke-width'] = oMarker.lineWidth;
    oMarkerAttr['pointer-events'] = 'all';
    oMarkerAttr.style = oMarker.style;
    oMarkerAttr['z-index'] = 10;
    if (!oMarker.lineColor) {
        oMarkerAttr.stroke = oAttrs.fill;
    }
    if (!oMarker.fillColor) {
        oMarkerAttr.fill = oAttrs.stroke;
    }
    oShape = MAQ.createSVGElement(svgNS, sShape, oMarkerAttr);
    return oShape;
};
MAQ.createStaticTooltips = function(oConfig, iSelectedIndex, oAttrs, svgNS) {
    'use strict';
    var iSeriesIndex = oConfig.tooltip.tooltips.length - 1;
    var oSeries = oConfig.series[iSeriesIndex];
    var sLabel = oConfig.series.label[iSelectedIndex];
    var oTooltip = MAQ.createSVGElement(oConfig.svgNS, 'g');
    var oRectAttr = {
        width: '50',
        height: '30',
        x: oAttrs.x,
        y: oAttrs.y,
        stroke: oAttrs.stroke,
        fill: 'white',
        'stroke-width': 2
    };
    var oTextAttr = {
        text: sLabel + ': ' + (Math.round(oSeries.data[iSelectedIndex] * 100) / 100 || 0),
        style: {
            'font-size': oConfig.tooltip.style['font-size'],
            'font-family': oConfig.tooltip.style['font-family']
        }
    };
    var oDim = MAQ.utils.getTextDim(oTextAttr.text, oTextAttr.style, oConfig);
    oRectAttr.width = oDim.width + 6;
    oRectAttr.height = oDim.height + 4;
    oTextAttr.x = oAttrs.x + 3;
    oTextAttr.y = oAttrs.y + oDim.height - 1;
    oTooltip.appendChild(MAQ.createSVGElement(oConfig.svgNS, 'rect', oRectAttr));
    oTooltip.appendChild(MAQ.createSVGElement(oConfig.svgNS, 'text', oTextAttr));
    return oTooltip;
};
/*BowTie Drill Functions*/
function PerformDrill(evt, oParam) {
    'use strict';
    var oSeries = [];
    var oBowTie = oParam.chartConfig.plotOptions.bowtie;
    if (oBowTie.branch.currentLevel < oData.length) {
        var iCurrentDrillLevel = oBowTie.branch.currentLevel;
        var oCurrData = oData[iCurrentDrillLevel];
        oSeries[0] = oCurrData.left;
        oBowTie.branch.left.title.text = oCurrData.lefttitle;
        oSeries[1] = oCurrData.right;
        oBowTie.branch.right.title.text = oCurrData.righttitle;
        oParam.chartConfig.series = oSeries;
        return oParam.chartConfig;
    }
    oParam.chartConfig.plotOptions.bowtie.branch.currentLevel -= 1;
}

function PerformDrillBack(evt, oParam) {
    'use strict';
    var oBowTie = oParam.chartConfig.plotOptions.bowtie;
    oBowTie.branch.currentLevel -= 1;
    var oSeries = [];
    var iCurrentDrillLevel = oBowTie.branch.currentLevel;
    var oCurrData = oData[iCurrentDrillLevel];
    oSeries[0] = oCurrData.left;
    oBowTie.branch.left.title.text = oCurrData.lefttitle;
    oSeries[1] = oCurrData.right;
    oBowTie.branch.right.title.text = oCurrData.righttitle;
    oParam.chartConfig.series = oSeries;
    MAQ.createBowTieChart(oParam.chartConfig);
}

function PerformBowTieDrill(evt, oParam) {
    var oSeries = [];
    var oBowTie = oParam.chartConfig.plotOptions.halfbowtie;
    if (oBowTie.branch.currentLevel < oData.length) {
        oBowTie.branch.currentLevel += 1;
        var iCurrentDrillLevel = oBowTie.branch.currentLevel;
        var oCurrData = oData[iCurrentDrillLevel];
        oSeries[0] = oCurrData.right;
        oParam.chartConfig.series = oSeries;
        MAQ.createHalfBowTieChart(oParam.chartConfig);
        if (oBowTie.branch.currentLevel > 0) {
            var oDrillBackImage = {
                x: oParam.chartConfig.svgELE.x.baseVal.value + 5,
                y: oDimensionTotalTitle.y,
                width: 24,
                height: 24
            };
            var oBackImage = MAQ.createSVGElement(oParam.chartConfig.svgNS, 'image', oDrillBackImage);
            oGrpELESum.appendChild(oBackImage);
            MAQ.addEventListener(oBackImage, 'click', oBowTie.branch.drillBackFunction, oParam);
            oBackImage.setAttributeNS(oParam.chartConfig.xlinkNS, 'xlink:href', '../PublishingImages/PreviousArrow.png');
            var oImageDim = MAQ.getObjectDimension(oBackImage);
            MAQ.addAttr(oBackImage, 'y', oDrillBackImage.y - oDimensionTotalTitle.height - oImageDim.height);
        }
    } else {
        oParam.chartConfig.plotOptions.halfbowtie.branch.currentLevel -= 1;
    }
}

function PerformBowTieDrillBack(evt, oParam) {
    'use strict';
    var oBowTie = oParam.chartConfig.plotOptions.halfbowtie;
    oBowTie.branch.currentLevel -= 1;
    var oSeries = [];
    var iCurrentDrillLevel = oBowTie.branch.currentLevel;
    var oCurrData = oData[iCurrentDrillLevel];
    oSeries[0] = oCurrData.right;
    oParam.chartConfig.series = oSeries;
    MAQ.createHalfBowTieChart(oParam.chartConfig);
    if (oBowTie.branch.currentLevel > 0) {
        var oDrillBackImage = {
            x: oParam.chartConfig.svgELE.x.baseVal.value - 12,
            y: oDimensionTotalTitle.y,
            width: 24,
            height: 24
        };
        var oBackImage = MAQ.createSVGElement(oParam.chartConfig.svgNS, 'image', oDrillBackImage);
        oGrpELESum.appendChild(oBackImage);
        MAQ.addEventListener(oBackImage, 'click', oBowTie.branch.drillBackFunction, oParam);
        oBackImage.setAttributeNS(oParam.chartConfig.xlinkNS, 'xlink:href', '../PublishingImages/PreviousArrow.png');
        var oImageDim = MAQ.getObjectDimension(oBackImage);
        MAQ.addAttr(oBackImage, 'y', oDrillBackImage.y - oDimensionTotalTitle.height - oImageDim.height);
    }
}

function getDateParts(dateArray, sDatePart, iStart, iEnd) {
    'use strict';
    if ('string' !== typeof sDatePart) {
        console.log('Error: Expected string found ' + typeof sDatePart);
    } else {
        sDatePart = sDatePart.toUpperCase();
    }
    if (undefined === iStart) {
        iStart = 0;
    }
    if (undefined === iEnd) {
        iEnd = dateArray.length;
    }
    var months = [
        'Jan',
        'Feb',
        'Mar',
        'Apr',
        'May',
        'Jun',
        'Jul',
        'Aug',
        'Sep',
        'Oct',
        'Nov',
        'Dec'
    ];
    var datePartFunc;
    switch (sDatePart) {
        case 'DAY':
            datePartFunc = function(array) {
                return array.slice(iStart, iEnd + 1).map(function(iItem, iIndex) {
                    var oDate = new Date(iItem);
                    return {
                        value: oDate.getDate(),
                        start: iIndex,
                        end: iIndex
                    };
                });
            };
            break;
        case 'WEEK':
            datePartFunc = function(array) {
                return array.slice(iStart, iEnd + 1).map(function(iItem, iIndex) {
                    var oDate = new Date(iItem);
                    return {
                        value: 'Week ' + oDate.getWeek(),
                        start: iIndex,
                        end: iIndex
                    };
                });
            };
            break;
        case 'MONTH':
            datePartFunc = function(array) {
                return array.slice(iStart, iEnd + 1).map(function(iItem, iIndex) {
                    var oDate = new Date(iItem);
                    return {
                        value: months[oDate.getMonth()],
                        start: iIndex,
                        end: iIndex
                    };
                });
            };
            break;
        default:
            datePartFunc = function(array) {
                return array.slice(iStart, iEnd + 1).map(function(iItem, iIndex) {
                    var oDate = new Date(iItem);
                    return {
                        value: oDate.getFullYear(),
                        start: iIndex,
                        end: iIndex
                    };
                });
            };
    }
    var tempArr = datePartFunc(dateArray);
    if (0 === tempArr.length) {
        return null;
    }
    var returnArr = [];
    var lastPushed = {};
    var lastStart = tempArr[0].end;
    var iCount;
    Object.keys(tempArr).forEach(function(iCount) {
        if (undefined !== lastPushed.value && lastPushed.value !== tempArr[iCount].value) {
            lastPushed.start = iStart + lastStart;
            returnArr.push(lastPushed);
            lastStart = tempArr[iCount].start;
        }
        lastPushed = {
            value: tempArr[iCount].value,
            end: iStart + tempArr[iCount].end
        };
    });
    if (undefined !== lastPushed.value && (undefined === returnArr[returnArr.length - 1] || lastPushed.value !== returnArr[returnArr.length - 1].value)) {
        lastPushed.start = iStart + lastStart;
        returnArr.push(lastPushed);
    }
    return returnArr;
}

function getNextDrillLevel(sCurrentLevel) {
    'use strict';
    sCurrentLevel = sCurrentLevel.toUpperCase();
    if ('YEAR' === sCurrentLevel) {
        return 'MONTH';
    } else if ('MONTH' === sCurrentLevel) {
        return 'WEEK';
    } else {
        return 'DAY';
    }
}
/*TimeLine Drill Functions*/
function createRangeSlider(chartConfigOptions, dateArray, sRangeSliderId, sDatePart, iStart, iEnd) {
    'use strict';
    if (null === sDatePart || '' === sDatePart) {
        return;
    }
    var items = getDateParts(dateArray, sDatePart, iStart, iEnd),
        divRangeSlider = document.getElementById(sRangeSliderId),
        dateItems = [],
        oParam;
    if (null === items) {
        return;
    }
    var currentDrillLevel = sDatePart;
    sDatePart = getNextDrillLevel(currentDrillLevel);
    var iCounter = 0,
        oRectAttr, oRect, iWidth, iRectX = 0,
        oTextAttr, oText;
    if (undefined !== divRangeSlider) {
        if (undefined !== divRangeSlider.innerHTML) {
            divRangeSlider.innerHTML = '';
        } else {
            while (0 < divRangeSlider.childNodes.length) {
                divRangeSlider.removeChild(divRangeSlider.lastChild);
            }
        }
        iWidth = chartConfigOptions.fNavigatorWidth / items.length;
        //this width is stored in the config object to be used later for snapping the navigator (snapping is not yet implemented)
        chartConfigOptions.timeline.drillWidth = iWidth;
        var rangeStart = items[0].start;
        chartConfigOptions.timeline.rangeStart = items[0].start;
        var rangeEnd = items[items.length - 1].end;
        chartConfigOptions.timeline.rangeEnd = items[items.length - 1].end;
        var fNavigatorShiftRatio = (rangeEnd - rangeStart) / chartConfigOptions.fNavigatorWidth,
            oDim, sVal, bToolTip, oToolTip;
        chartConfigOptions.timeline.shiftRatio = fNavigatorShiftRatio;
        for (iCounter = 0; iCounter < items.length; iCounter += 1) {
            //if the current drill level is the lowest level drill, don't draw it
            //or if the interval is not the lowest drill level and still has single data point and also it is the first or last interval, don't draw it
            if ('DAY' === currentDrillLevel && items.length - 1 === iCounter || 'DAY' !== currentDrillLevel && items[iCounter].end === items[iCounter].start && (0 === iCounter || items.length - 1 === iCounter)) {
                continue;
            }
            if (iCounter === items.length - 1) {
                iWidth = chartConfigOptions.fNavigatorWidth - iRectX;
            } else {
                //start - 1 is done to ensure width calculation starts from previous elements end
                iWidth = Math.ceil((items[iCounter].end - Math.max(items[iCounter].start - 1, 0)) / fNavigatorShiftRatio);
            }
            oRectAttr = {
                x: iRectX,
                y: 0,
                width: iWidth,
                height: chartConfigOptions.fNavigatorHeight,
                cursor: 'pointer',
                'pointer-events': 'visibleFill',
                fill: chartConfigOptions.timeline.drillBoxes.fill,
                stroke: chartConfigOptions.timeline.drillBoxes.stroke,
                'stroke-width': chartConfigOptions.timeline.drillBoxes['stroke-width']
            };
            oRect = MAQ.createSVGElement(chartConfigOptions.svgNS, 'rect', oRectAttr);
            oRect.setAttribute('data-start', items[iCounter].start);
            oRect.setAttribute('data-end', items[iCounter].end);
            oTextAttr = {
                x: iRectX + iWidth / 2,
                y: oRectAttr.height / 2 + 5,
                text: items[iCounter].value,
                'pointer-events': 'none',
                style: chartConfigOptions.timeline.drillBoxes.fontStyle
            };
            //if text width is more than clip it and show tooltip
            oDim = MAQ.utils.getTextDim('X', oTextAttr.style, chartConfigOptions);
            sVal = oTextAttr.text;
            bToolTip = false;
            if (oDim.width * sVal.length > iWidth) {
                oTextAttr.text = sVal.substr(0, Math.floor(iWidth / oDim.width));
                oTextAttr.title = items[iCounter].value;
                //show tooltip
                bToolTip = true;
            }
            oText = MAQ.createSVGElement(chartConfigOptions.svgNS, 'text', oTextAttr);
            divRangeSlider.appendChild(oRect);
            divRangeSlider.appendChild(oText);
            dateItems.push(oRect);
            if (bToolTip) {
                oParam = {
                    value: sVal,
                    config: chartConfigOptions,
                    type: 'axis'
                };
                oToolTip = chartConfigOptions.tooltipDiv;
                MAQ.addEventListener(oRect, 'mouseover', showToolTip, oParam);
                MAQ.addEventListener(oRect, 'mouseout', hideToolTip, oToolTip);
            }
            //increment x position by width of previous drill box
            iRectX += iWidth;
        }
        dateItems.forEach(function(oEle) {
            oEle.addEventListener('click', function() {
                var dataStart = parseInt(oEle.getAttribute('data-start'));
                var dataEnd = parseInt(oEle.getAttribute('data-end'));
                var oNavigatorWindow = document.getElementById('MAQCharts-NavWindow-' + chartConfigOptions.chart.renderTo);
                if (dataStart === dataEnd) {
                    resetTimeline(chartConfigOptions);
                    return;
                }
                if (chartConfigOptions.timeline.resetElementId) {
                    document.getElementById(chartConfigOptions.timeline.resetElementId).style.display = 'block';
                }
                createRangeSlider(chartConfigOptions, dateArray, sRangeSliderId, sDatePart, dataStart, dataEnd);
                expandFullNavigator(chartConfigOptions);
                MAQ.updateTimeLineDisplayArea(chartConfigOptions, dataStart + chartConfigOptions.timeline.shiftRatio * oNavigatorWindow.x.baseVal.value, dataStart + chartConfigOptions.timeline.shiftRatio * (oNavigatorWindow.x.baseVal.value + oNavigatorWindow.width.baseVal.value));
            }, false);
        });
    } else {
        console.log('Error: No element exists with id ' + sRangeSliderId + '.');
    }
}
Date.prototype.getWeek = function() {
    'use strict';
    var startDate = new Date(this.getFullYear(), 0);
    startDate.setHours(0, 0, 0, 0);
    //daysLeft stores the no. of days left from the week in last year
    var daysLeft = 6 - startDate.getDay();
    var currentDate = new Date(this.getTime());
    currentDate.setHours(0, 0, 0, 0);
    var week = 1;
    //if daysLeft is 6 then the week starts with this date
    if (6 !== daysLeft) {
        startDate = new Date(startDate.getFullYear(), 0, startDate.getDate() + daysLeft + 1);
        week += 1;
    }
    while (startDate < currentDate) {
        startDate.setDate(startDate.getDate() + 7);
        week += 1;
    }
    if (startDate === currentDate) {
        return week;
    } else {
        return week - 1;
    }
};
/*
onRangeChange: calls the user-defined callback function after moving the slider of lift chart
@param {config} user configuration parameters
@param {start} the x-position of left slider
@param {end} the x-position of right slider
*/
function onRangeChange(config, start, end) {
    'use strict';
    if (typeof config.plotOptions.lift.onDisplayAreaChange === 'function') {
        var circleCoordsStart = MAQ.getIntersectionPoints(config, start);
        var circleCoordsEnd = MAQ.getIntersectionPoints(config, end);
        var obj = {
            values: circleCoordsEnd.values,
            range: [
                circleCoordsStart.higherIndex,
                circleCoordsEnd.higherIndex
            ]
        };
        config.plotOptions.lift.onDisplayAreaChange(obj);
    }
}